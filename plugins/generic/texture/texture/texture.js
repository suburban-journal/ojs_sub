(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('substance'), require('katex')) :
  typeof define === 'function' && define.amd ? define(['exports', 'substance', 'katex'], factory) :
  (factory((global.texture = {}),global.substance,global.katex));
}(this, (function (exports,substance,katex) { 'use strict';

  katex = katex && katex.hasOwnProperty('default') ? katex['default'] : katex;

  function getText (rootEl, selector) {
    let el = rootEl.find(selector);
    if (el) {
      return el.textContent
    } else {
      return ''
    }
  }

  function getSeparatedText (rootEl, selector) {
    let el = rootEl.findAll(selector);
    if (el) {
      return el.map(m => { return m.textContent }).join('; ')
    } else {
      return ''
    }
  }

  function getAttr (rootEl, selector, attr) {
    let el = rootEl.find(selector);
    if (el) {
      return el.attr(attr)
    } else {
      return ''
    }
  }

  function findChild (el, cssSelector) {
    const children = el.getChildren();
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.is(cssSelector)) return child
    }
  }

  function findAllChildren (el, cssSelector) {
    const children = el.getChildren();
    let result = [];
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.is(cssSelector)) {
        result.push(child);
      }
    }
    return result
  }

  function printElement (el, options = {}) {
    let maxLevel = options.maxLevel || 1000;
    let res = _printElement(el, 1, maxLevel);
    return res
  }

  function retainChildren (el, ...allowedTagNames) {
    allowedTagNames = new Set(allowedTagNames);
    let childNodes = el.getChildNodes();
    for (let idx = childNodes.length - 1; idx >= 0; idx--) {
      let child = childNodes[idx];
      if (!allowedTagNames.has(child.tagName)) {
        el.removeAt(idx);
      }
    }
    return el
  }

  function _printElement (el, level, maxLevel) {
    let INDENT = new Array(level - 1);
    INDENT.fill('  ');
    INDENT = INDENT.join('');

    if (el.isElementNode()) {
      if (level <= maxLevel) {
        let res = [];
        res.push(INDENT + _openTag(el));
        res = res.concat(
          el.childNodes.map((child) => {
            return _printElement(child, level + 1, maxLevel)
          }).filter(Boolean)
        );
        res.push(INDENT + _closeTag(el));
        return res.join('\n')
      } else {
        return INDENT + _openTag(el) + '...' + _closeTag(el)
      }
    } else if (el.isTextNode()) {
      let textContent = el.textContent;
      if (/^\s*$/.exec(textContent)) {
        return ''
      } else {
        return INDENT + JSON.stringify(el.textContent)
      }
    } else {
      // TODO: render other node types and consider maxLevel
      return INDENT + el.serialize()
    }
  }

  function _openTag (el) {
    let attribStr = substance.DomUtils.formatAttribs(el);
    if (attribStr) {
      return `<${el.tagName} ${attribStr}>`
    } else {
      return `<${el.tagName}>`
    }
  }

  function _closeTag (el) {
    return `</${el.tagName}>`
  }

  class JATSImportDialog extends substance.Component {
    render ($$) {
      const errors = this.props.errors;
      let el = $$('div').addClass('sc-jats-import-dialog');
      el.append($$('h1').addClass('se-title').text('Importing JATS'));
      errors.forEach((error) => {
        el.append($$(ImportStage, {
          stage: error.name,
          errors: error.errors
        }));
      });
      return el
    }
  }

  class ImportStage extends substance.Component {
    render ($$) {
      const errors = this.props.errors;
      let el = $$('div').addClass('sc-import-stage');
      el.append($$('h2').addClass('se-title').text(_getTitle(this.props.stage)));

      if (this.props.errors.length > 0) {
        let errorsEl = $$('div').addClass('se-errors');
        errors.forEach((err) => {
          errorsEl.append(this._renderError($$, err));
        });
        el.append(errorsEl);
      }
      return el
    }

    _renderError ($$, err) {
      let el = $$('div').addClass('se-error');
      // TODO: maybe we will have more structured errors
      el.append(
        $$('div').addClass('se-message').text(err.msg)
      );
      if (err.el) {
        el.append(
          $$('pre').addClass('se-element').text(printElement(err.el, { maxLevel: 1 }))
        );
      }
      return el
    }
  }

  const TITLES = {
    'parse': 'Parse XML',
    'validate-jats': 'Validate JATS',
    'validate-texture-article': 'Validate Texture Article',
    'j2r': 'Transform JATS -> TextureArticle',
    'r2t': 'Transform TextureArticle -> InternalArticle'
  };

  function _getTitle (stage) {
    return TITLES[stage]
  }

  // TODO: do we really need this anymore?
  // we use XML stuff only for validation
  function createSchema (XMLSchemaData, name, version, DocumentClass, docTypeParams) {
    let xmlSchema = substance.XMLSchema.fromJSON(XMLSchemaData);
    const tagNames = xmlSchema.getTagNames();
    let nodeClasses = [];
    // add node definitions and converters
    tagNames.forEach((tagName) => {
      const elementSchema = xmlSchema.getElementSchema(tagName);
      let targetTypes = [];
      if (elementSchema.expr._allowedChildren) {
        targetTypes = Object.keys(elementSchema.expr._allowedChildren);
      }
      let NodeClass;
      const elementType = elementSchema.type;
      const type = elementSchema.name;
      switch (elementType) {
        case 'element': {
          NodeClass = class _XMLElementNode extends substance.XMLElementNode {};
          NodeClass.schema = {
            _childNodes: { type: ['array', 'id'], default: [], owned: true, targetTypes }
          };
          break
        }
        case 'hybrid': {
          throw new Error('Mixed element types are not supported yet.')
        }
        case 'text': {
          NodeClass = class _XMLTextElement extends substance.XMLTextElement {};
          NodeClass.schema = {
            content: { type: 'text', targetTypes }
          };
          break
        }
        case 'annotation': {
          NodeClass = class _XMLAnnotationElement extends substance.XMLAnnotationNode {};
          break
        }
        case 'anchor': {
          NodeClass = class _XMLAnchorNode extends substance.XMLAnchorNode {};
          break
        }
        case 'inline-element': {
          NodeClass = class _XMLInlineElementNode extends substance.XMLInlineElementNode {};
          NodeClass.schema = {
            _childNodes: { type: ['array', 'id'], default: [], owned: true, targetTypes }
          };
          break
        }
        case 'external':
        case 'not-implemented': {
          NodeClass = class _XMLExternalNode extends substance.XMLExternalNode {};
          break
        }
        case 'container': {
          NodeClass = class _XMLContainerNode extends substance.XMLContainerNode {};
          NodeClass.schema = {
            _childNodes: { type: ['array', 'id'], default: [], owned: true, targetTypes }
          };
          break
        }
        default:
          throw new Error('Illegal state')
      }
      NodeClass.type = type;
      NodeClass._elementSchema = elementSchema;

      nodeClasses.push(NodeClass);
    });

    let schema = new substance.DocumentSchema({
      name,
      version,
      DocumentClass,
      // TODO: try to get rid of this
      defaultTextType: 'p'
    });
    schema.addNodes(nodeClasses)
    // HACK: add legacy API (Formerly XMLSchema)
    ;['getStartElement', 'validateElement', 'getElementSchema'].forEach(methodName => {
      schema[methodName] = (...args) => {
        return xmlSchema[methodName](...args)
      };
    });
    // other legacy functions that we had add manually
    schema.getName = () => { return name };
    schema.getDocTypeParams = () => { return docTypeParams };
    schema.xmlSchema = xmlSchema;

    return schema
  }

  var JATSArchivingData = {"start":"article","elements":{"abbrev":{"name":"abbrev","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"alt":{"name":"alt"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"abbrev","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","def"]}}}},"abbrev-journal-title":{"name":"abbrev-journal-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"abbrev-type":{"name":"abbrev-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"abbrev-journal-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"abstract":{"name":"abstract","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"abstract-type":{"name":"abstract-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"abstract","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"access-date":{"name":"access-date","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"access-date","content":{"type":"*","block":{"type":"|","blocks":["TEXT","day","era","month","season","year","x"]}}}},"ack":{"name":"ack","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"content-type":{"name":"content-type"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"ack","content":{"type":",","blocks":[{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"addr-line":{"name":"addr-line","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"addr-line","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","city","country","fax","institution","institution-wrap","phone","postal-code","state"]}}}},"address":{"name":"address","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"address","content":{"type":"*","block":{"type":"|","blocks":["addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state","email","ext-link","uri","label","x"]}}}},"aff":{"name":"aff","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"aff","content":{"type":"*","block":{"type":"|","blocks":["TEXT","addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","label"]}}}},"aff-alternatives":{"name":"aff-alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"aff-alternatives","content":{"type":"+","block":"aff"}}},"ali:free_to_read":{"name":"ali:free_to_read","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"end_date":{"name":"end_date"},"start_date":{"name":"start_date"}},"elements":{"name":"ali:free_to_read","content":{"type":",","blocks":[]}}},"ali:license_ref":{"name":"ali:license_ref","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"start_date":{"name":"start_date"}},"elements":{"name":"ali:license_ref","content":"TEXT"}},"alt-text":{"name":"alt-text","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"alt-text","content":"TEXT"}},"alt-title":{"name":"alt-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"alt-title-type":{"name":"alt-title-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"alt-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"alternatives":{"name":"alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"alternatives","content":{"type":"+","block":{"type":"|","blocks":["array","chem-struct","code","graphic","inline-graphic","inline-supplementary-material","media","preformat","private-char","supplementary-material","table","oasis:table","textual-form","tex-math","mml:math"]}}}},"annotation":{"name":"annotation","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"annotation","content":{"type":"+","block":"p"}}},"anonymous":{"name":"anonymous","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"anonymous","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"app":{"name":"app","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"app","content":{"type":",","blocks":[{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}},{"type":"?","block":"permissions"}]}}},"app-group":{"name":"app-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"app-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":{"type":"|","blocks":["app","ref-list"]}}]}}},"array":{"name":"array","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"orientation":{"name":"orientation"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"array","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"|","blocks":[{"type":"*","block":{"type":"|","blocks":["alternatives","graphic","media"]}},"tbody","oasis:tbody"]},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"article":{"name":"article","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"article-type":{"name":"article-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"dtd-version":{"name":"dtd-version"}},"elements":{"name":"article","content":{"type":",","blocks":["front",{"type":"?","block":"body"},{"type":"?","block":"back"},{"type":"?","block":"floats-group"},{"type":"|","blocks":[{"type":"*","block":"sub-article"},{"type":"*","block":"response"}]}]}}},"article-categories":{"name":"article-categories","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"article-categories","content":{"type":",","blocks":[{"type":"*","block":"subj-group"},{"type":"*","block":"series-title"},{"type":"*","block":"series-text"}]}}},"article-id":{"name":"article-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"article-id","content":"TEXT"}},"article-meta":{"name":"article-meta","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"article-meta","content":{"type":",","blocks":[{"type":"*","block":"article-id"},{"type":"?","block":"article-categories"},{"type":"?","block":"title-group"},{"type":"*","block":{"type":"|","blocks":["contrib-group","aff","aff-alternatives","x"]}},{"type":"?","block":"author-notes"},{"type":"*","block":"pub-date"},{"type":"*","block":"volume"},{"type":"*","block":"volume-id"},{"type":"?","block":"volume-series"},{"type":"*","block":"issue"},{"type":"*","block":"issue-id"},{"type":"*","block":"issue-title"},{"type":"*","block":"issue-sponsor"},{"type":"?","block":"issue-part"},{"type":"*","block":"volume-issue-group"},{"type":"*","block":"isbn"},{"type":"?","block":"supplement"},{"type":"?","block":{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":{"type":",","blocks":["fpage",{"type":"?","block":"lpage"}]}},{"type":"?","block":"page-range"}]},"elocation-id"]}},{"type":"*","block":{"type":"|","blocks":["email","ext-link","uri","product","supplementary-material"]}},{"type":"?","block":"history"},{"type":"?","block":"permissions"},{"type":"*","block":"self-uri"},{"type":"*","block":{"type":"|","blocks":["related-article","related-object"]}},{"type":"*","block":"abstract"},{"type":"*","block":"trans-abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":"funding-group"},{"type":"*","block":"conference"},{"type":"?","block":"counts"},{"type":"?","block":"custom-meta-group"}]}}},"article-title":{"name":"article-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"article-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"attrib":{"name":"attrib","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"attrib","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"author-comment":{"name":"author-comment","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"author-comment","content":{"type":",","blocks":[{"type":"?","block":"title"},{"type":"+","block":"p"}]}}},"author-notes":{"name":"author-notes","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"}},"elements":{"name":"author-notes","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":{"type":"|","blocks":["corresp","fn","p","x"]}}]}}},"award-group":{"name":"award-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"award-type":{"name":"award-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"award-group","content":{"type":",","blocks":[{"type":"*","block":"funding-source"},{"type":"*","block":"award-id"},{"type":"*","block":"principal-award-recipient"},{"type":"*","block":"principal-investigator"}]}}},"award-id":{"name":"award-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"award-type":{"name":"award-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"award-id","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"back":{"name":"back","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"back","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"*","block":"title"},{"type":"*","block":{"type":"|","blocks":["ack","app-group","bio","fn-group","glossary","ref-list","notes","sec"]}}]}}},"bio":{"name":"bio","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"bio","content":{"type":",","blocks":[{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"body":{"name":"body","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"}},"elements":{"name":"body","content":{"type":",","blocks":[{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"?","block":"sig-block"}]}}},"bold":{"name":"bold","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"bold","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"boxed-text":{"name":"boxed-text","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"boxed-text","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"break":{"name":"break","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"break","content":{"type":",","blocks":[]}}},"caption":{"name":"caption","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"style":{"name":"style"}},"elements":{"name":"caption","content":{"type":",","blocks":[{"type":"?","block":"title"},{"type":"*","block":"p"}]}}},"chapter-title":{"name":"chapter-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"chapter-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"chem-struct":{"name":"chem-struct","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"chem-struct","content":{"type":"*","block":{"type":"|","blocks":["TEXT","alt-text","long-desc","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","object-id","label","def-list","list","array","code","graphic","media","preformat"]}}}},"chem-struct-wrap":{"name":"chem-struct-wrap","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"chem-struct-wrap","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"+","block":{"type":"|","blocks":["alternatives","chem-struct","code","graphic","media","preformat","textual-form"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"citation-alternatives":{"name":"citation-alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"citation-alternatives","content":{"type":"+","block":{"type":"|","blocks":["element-citation","mixed-citation","nlm-citation"]}}}},"city":{"name":"city","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"city","content":"TEXT"}},"code":{"name":"code","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"code-type":{"name":"code-type"},"code-version":{"name":"code-version"},"executable":{"name":"executable"},"language":{"name":"language"},"language-version":{"name":"language-version"},"platforms":{"name":"platforms"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"}},"elements":{"name":"code","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup"]}}}},"col":{"name":"col","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"span":{"name":"span"},"width":{"name":"width"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"col","content":{"type":",","blocks":[]}}},"colgroup":{"name":"colgroup","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"span":{"name":"span"},"width":{"name":"width"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"colgroup","content":{"type":"*","block":"col"}}},"collab":{"name":"collab","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"collab-type":{"name":"collab-type"},"symbol":{"name":"symbol"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"collab","content":{"type":"*","block":{"type":"|","blocks":["TEXT","inline-supplementary-material","related-article","related-object","addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state","hr","break","contrib-group","address","aff","aff-alternatives","author-comment","bio","email","etal","ext-link","fn","on-behalf-of","role","uri","xref","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","sub","sup","x"]}}}},"collab-alternatives":{"name":"collab-alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"collab-alternatives","content":{"type":"+","block":"collab"}}},"comment":{"name":"comment","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"comment","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"compound-kwd":{"name":"compound-kwd","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"compound-kwd","content":{"type":"+","block":"compound-kwd-part"}}},"compound-kwd-part":{"name":"compound-kwd-part","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"compound-kwd-part","content":{"type":"*","block":{"type":"|","blocks":["TEXT","break","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"compound-subject":{"name":"compound-subject","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"compound-subject","content":{"type":"+","block":"compound-subject-part"}}},"compound-subject-part":{"name":"compound-subject-part","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"compound-subject-part","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","named-content","styled-content","sub","sup"]}}}},"conf-acronym":{"name":"conf-acronym","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-acronym","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"conf-date":{"name":"conf-date","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-date","content":{"type":"*","block":{"type":"|","blocks":["TEXT","day","era","month","season","year","x"]}}}},"conf-loc":{"name":"conf-loc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-loc","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state"]}}}},"conf-name":{"name":"conf-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-name","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"conf-num":{"name":"conf-num","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-num","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"conf-sponsor":{"name":"conf-sponsor","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-sponsor","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","institution","institution-wrap"]}}}},"conf-theme":{"name":"conf-theme","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-theme","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"conference":{"name":"conference","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"conference","content":{"type":"*","block":{"type":"|","blocks":["conf-date","conf-name","conf-num","conf-loc","conf-sponsor","conf-theme","conf-acronym","string-conf","x"]}}}},"contrib":{"name":"contrib","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"contrib-type":{"name":"contrib-type"},"corresp":{"name":"corresp"},"equal-contrib":{"name":"equal-contrib"},"deceased":{"name":"deceased"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"contrib","content":{"type":"*","block":{"type":"|","blocks":["contrib-id","anonymous","collab","collab-alternatives","name","name-alternatives","string-name","degrees","address","aff","aff-alternatives","author-comment","bio","email","etal","ext-link","fn","on-behalf-of","role","uri","xref","x"]}}}},"contrib-group":{"name":"contrib-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"contrib-group","content":{"type":"+","block":{"type":"|","blocks":["contrib","address","aff","aff-alternatives","author-comment","bio","email","etal","ext-link","fn","on-behalf-of","role","uri","xref","x"]}}}},"contrib-id":{"name":"contrib-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"contrib-id-type":{"name":"contrib-id-type"},"authenticated":{"name":"authenticated"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"contrib-id","content":"TEXT"}},"copyright-holder":{"name":"copyright-holder","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"copyright-holder","content":{"type":"*","block":{"type":"|","blocks":["TEXT","institution","institution-wrap","sub","sup","x"]}}}},"copyright-statement":{"name":"copyright-statement","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"copyright-statement","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"copyright-year":{"name":"copyright-year","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"copyright-year","content":"TEXT"}},"corresp":{"name":"corresp","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"corresp","content":{"type":"*","block":{"type":"|","blocks":["TEXT","addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","label"]}}}},"count":{"name":"count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count-type":{"name":"count-type"},"count":{"name":"count"}},"elements":{"name":"count","content":{"type":",","blocks":[]}}},"country":{"name":"country","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"country","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"counts":{"name":"counts","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"counts","content":{"type":",","blocks":[{"type":"*","block":"count"},{"type":"?","block":"fig-count"},{"type":"?","block":"table-count"},{"type":"?","block":"equation-count"},{"type":"?","block":"ref-count"},{"type":"?","block":"page-count"},{"type":"?","block":"word-count"}]}}},"custom-meta":{"name":"custom-meta","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"custom-meta","content":{"type":",","blocks":["meta-name","meta-value"]}}},"custom-meta-group":{"name":"custom-meta-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"custom-meta-group","content":{"type":"+","block":"custom-meta"}}},"data-title":{"name":"data-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"data-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","named-content","styled-content","sub","sup"]}}}},"date":{"name":"date","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"date-type":{"name":"date-type"},"publication-format":{"name":"publication-format"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"specific-use":{"name":"specific-use"}},"elements":{"name":"date","content":{"type":",","blocks":[{"type":"?","block":{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":"day"},{"type":"?","block":"month"}]},"season"]}},{"type":"?","block":"year"},{"type":"?","block":"era"},{"type":"?","block":"string-date"}]}}},"date-in-citation":{"name":"date-in-citation","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"date-in-citation","content":{"type":"*","block":{"type":"|","blocks":["TEXT","day","era","month","season","year","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","x"]}}}},"day":{"name":"day","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"day","content":"TEXT"}},"def":{"name":"def","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"def","content":{"type":"+","block":"p"}}},"def-head":{"name":"def-head","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"def-head","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"def-item":{"name":"def-item","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"def-item","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"*","block":"term"},{"type":"*","block":{"type":"|","blocks":["def","x"]}}]}}},"def-list":{"name":"def-list","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"list-type":{"name":"list-type"},"prefix-word":{"name":"prefix-word"},"list-content":{"name":"list-content"},"continued-from":{"name":"continued-from"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"def-list","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"?","block":"term-head"},{"type":"?","block":"def-head"},{"type":"*","block":{"type":"|","blocks":["def-item","x"]}},{"type":"*","block":"def-list"}]}}},"degrees":{"name":"degrees","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"degrees","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"disp-formula":{"name":"disp-formula","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"disp-formula","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","abstract","alt-text","long-desc","break","attrib","permissions","kwd-group","label","array","code","graphic","media","preformat"]}}}},"disp-formula-group":{"name":"disp-formula-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"disp-formula-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"*","block":{"type":"|","blocks":["disp-formula","disp-formula-group"]}}]}}},"disp-quote":{"name":"disp-quote","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"disp-quote","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"edition":{"name":"edition","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"designator":{"name":"designator"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"edition","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"element-citation":{"name":"element-citation","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-type":{"name":"publication-type"},"publisher-type":{"name":"publisher-type"},"publication-format":{"name":"publication-format"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"element-citation","content":{"type":"+","block":{"type":"|","blocks":["inline-supplementary-material","related-article","related-object","hr","string-date","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","label","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","annotation","article-title","chapter-title","collab","collab-alternatives","comment","conf-acronym","conf-date","conf-loc","conf-name","conf-sponsor","data-title","date","date-in-citation","day","edition","email","elocation-id","etal","ext-link","fpage","gov","institution","institution-wrap","isbn","issn","issn-l","issue","issue-id","issue-part","issue-title","lpage","month","name","name-alternatives","object-id","page-range","part-title","patent","person-group","pub-id","publisher-loc","publisher-name","role","season","series","size","source","std","string-name","supplement","trans-source","trans-title","uri","version","volume","volume-id","volume-series","year","fn","target","xref","sub","sup","x"]}}}},"elocation-id":{"name":"elocation-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"}},"elements":{"name":"elocation-id","content":"TEXT"}},"email":{"name":"email","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"email","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"equation-count":{"name":"equation-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"equation-count","content":{"type":",","blocks":[]}}},"era":{"name":"era","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"era","content":"TEXT"}},"etal":{"name":"etal","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"etal","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"ext-link":{"name":"ext-link","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"ext-link-type":{"name":"ext-link-type"},"assigning-authority":{"name":"assigning-authority"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"ext-link","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"fax":{"name":"fax","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"fax","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"fig":{"name":"fig","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"fig-type":{"name":"fig-type"}},"elements":{"name":"fig","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"label"},{"type":"*","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"*","block":{"type":"|","blocks":["disp-formula","disp-formula-group","chem-struct-wrap","disp-quote","speech","statement","verse-group","table-wrap","p","def-list","list","alternatives","array","code","graphic","media","preformat"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"fig-count":{"name":"fig-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"fig-count","content":{"type":",","blocks":[]}}},"fig-group":{"name":"fig-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"fig-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"*","block":{"type":"|","blocks":["fig","alternatives","graphic","media"]}}]}}},"fixed-case":{"name":"fixed-case","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"fixed-case","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"floats-group":{"name":"floats-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"floats-group","content":{"type":"*","block":{"type":"|","blocks":["alternatives","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group"]}}}},"fn":{"name":"fn","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"symbol":{"name":"symbol"},"fn-type":{"name":"fn-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fn","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"+","block":"p"}]}}},"fn-group":{"name":"fn-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fn-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":{"type":"|","blocks":["fn","x"]}}]}}},"fpage":{"name":"fpage","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fpage","content":"TEXT"}},"front":{"name":"front","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"front","content":{"type":",","blocks":[{"type":"?","block":"journal-meta"},"article-meta",{"type":"*","block":{"type":"|","blocks":["def-list","list","ack","bio","fn-group","glossary","notes"]}}]}}},"front-stub":{"name":"front-stub","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"front-stub","content":{"type":",","blocks":[{"type":"*","block":"article-id"},{"type":"?","block":"article-categories"},{"type":"?","block":"title-group"},{"type":"*","block":{"type":"|","blocks":["contrib-group","aff","aff-alternatives","x"]}},{"type":"?","block":"author-notes"},{"type":"*","block":"pub-date"},{"type":"*","block":"volume"},{"type":"*","block":"volume-id"},{"type":"?","block":"volume-series"},{"type":"*","block":"issue"},{"type":"*","block":"issue-id"},{"type":"*","block":"issue-title"},{"type":"*","block":"issue-sponsor"},{"type":"?","block":"issue-part"},{"type":"*","block":"volume-issue-group"},{"type":"*","block":"isbn"},{"type":"?","block":"supplement"},{"type":"?","block":{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":{"type":",","blocks":["fpage",{"type":"?","block":"lpage"}]}},{"type":"?","block":"page-range"}]},"elocation-id"]}},{"type":"*","block":{"type":"|","blocks":["email","ext-link","uri","product","supplementary-material"]}},{"type":"?","block":"history"},{"type":"?","block":"permissions"},{"type":"*","block":"self-uri"},{"type":"*","block":{"type":"|","blocks":["related-article","related-object"]}},{"type":"*","block":"abstract"},{"type":"*","block":"trans-abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":"funding-group"},{"type":"*","block":"conference"},{"type":"?","block":"counts"},{"type":"?","block":"custom-meta-group"}]}}},"funding-group":{"name":"funding-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"funding-group","content":{"type":",","blocks":[{"type":"*","block":"award-group"},{"type":"*","block":"funding-statement"},{"type":"*","block":"open-access"}]}}},"funding-source":{"name":"funding-source","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"source-type":{"name":"source-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"funding-source","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","institution","institution-wrap"]}}}},"funding-statement":{"name":"funding-statement","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"funding-statement","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","award-id","funding-source","open-access"]}}}},"given-names":{"name":"given-names","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"initials":{"name":"initials"}},"elements":{"name":"given-names","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"glossary":{"name":"glossary","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"glossary","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"glossary"}]}}},"glyph-data":{"name":"glyph-data","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"fontchar":{"name":"fontchar"},"fontname":{"name":"fontname"},"format":{"name":"format"},"resolution":{"name":"resolution"},"xml:space":{"name":"xml:space"},"x-size":{"name":"x-size"},"y-size":{"name":"y-size"}},"elements":{"name":"glyph-data","content":"TEXT"}},"glyph-ref":{"name":"glyph-ref","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"glyph-data":{"name":"glyph-data"}},"elements":{"name":"glyph-ref","content":{"type":",","blocks":[]}}},"gov":{"name":"gov","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"gov","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"graphic":{"name":"graphic","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"},"mime-subtype":{"name":"mime-subtype"},"mimetype":{"name":"mimetype"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"graphic","content":{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","abstract","email","ext-link","uri","caption","object-id","kwd-group","label","attrib","permissions"]}}}},"history":{"name":"history","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"history","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","date","string-date"]}}}},"hr":{"name":"hr","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"hr","content":{"type":",","blocks":[]}}},"inline-formula":{"name":"inline-formula","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"inline-formula","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"inline-graphic":{"name":"inline-graphic","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"baseline-shift":{"name":"baseline-shift"},"mimetype":{"name":"mimetype"},"mime-subtype":{"name":"mime-subtype"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"inline-graphic","content":{"type":"?","block":"alt-text"}}},"inline-supplementary-material":{"name":"inline-supplementary-material","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"mimetype":{"name":"mimetype"},"mime-subtype":{"name":"mime-subtype"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"inline-supplementary-material","content":{"type":"*","block":{"type":"|","blocks":["TEXT","alt-text","long-desc","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"institution":{"name":"institution","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"institution","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"institution-id":{"name":"institution-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"institution-id-type":{"name":"institution-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"institution-id","content":"TEXT"}},"institution-wrap":{"name":"institution-wrap","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"institution-wrap","content":{"type":"*","block":{"type":"|","blocks":["institution","institution-id"]}}}},"isbn":{"name":"isbn","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-format":{"name":"publication-format"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"isbn","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"issn":{"name":"issn","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-type":{"name":"pub-type"},"publication-format":{"name":"publication-format"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"issn","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"issn-l":{"name":"issn-l","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"}},"elements":{"name":"issn-l","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"issue":{"name":"issue","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"issue-id":{"name":"issue-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"issue-id","content":"TEXT"}},"issue-part":{"name":"issue-part","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue-part","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"issue-sponsor":{"name":"issue-sponsor","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue-sponsor","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"issue-title":{"name":"issue-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"italic":{"name":"italic","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"italic","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"journal-id":{"name":"journal-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"journal-id-type":{"name":"journal-id-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"journal-id","content":"TEXT"}},"journal-meta":{"name":"journal-meta","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"journal-meta","content":{"type":",","blocks":[{"type":"*","block":"journal-id"},{"type":"*","block":"journal-title-group"},{"type":"*","block":{"type":"|","blocks":["contrib-group","aff","aff-alternatives"]}},{"type":"*","block":"issn"},{"type":"?","block":"issn-l"},{"type":"*","block":"isbn"},{"type":"?","block":"publisher"},{"type":"*","block":"notes"},{"type":"*","block":"self-uri"},{"type":"?","block":"custom-meta-group"}]}}},"journal-subtitle":{"name":"journal-subtitle","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"journal-subtitle","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"journal-title":{"name":"journal-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"journal-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"journal-title-group":{"name":"journal-title-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"journal-title-group","content":{"type":",","blocks":[{"type":"*","block":"journal-title"},{"type":"*","block":"journal-subtitle"},{"type":"*","block":"trans-title-group"},{"type":"*","block":"abbrev-journal-title"}]}}},"kwd":{"name":"kwd","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"kwd","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"kwd-group":{"name":"kwd-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"kwd-group-type":{"name":"kwd-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"kwd-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"|","blocks":[{"type":"+","block":{"type":"|","blocks":["kwd","compound-kwd","nested-kwd","x"]}},{"type":"*","block":"unstructured-kwd-group"}]}]}}},"label":{"name":"label","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"alt":{"name":"alt"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"label","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"license":{"name":"license","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"license-type":{"name":"license-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"license","content":{"type":"+","block":{"type":"|","blocks":["ali:license_ref","license-p"]}}}},"license-p":{"name":"license-p","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"license-p","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","address","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","citation-alternatives","element-citation","mixed-citation","nlm-citation","award-id","funding-source","open-access","def-list","list","ack","disp-quote","speech","statement","verse-group","price"]}}}},"list":{"name":"list","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"list-type":{"name":"list-type"},"prefix-word":{"name":"prefix-word"},"list-content":{"name":"list-content"},"continued-from":{"name":"continued-from"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"list","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":{"type":"|","blocks":["list-item","x"]}}]}}},"list-item":{"name":"list-item","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"list-item","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":{"type":"|","blocks":["p","def-list","list"]}}]}}},"long-desc":{"name":"long-desc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"long-desc","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"lpage":{"name":"lpage","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"lpage","content":"TEXT"}},"media":{"name":"media","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"},"mimetype":{"name":"mimetype"},"mime-subtype":{"name":"mime-subtype"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"media","content":{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","abstract","email","ext-link","uri","caption","object-id","kwd-group","label","attrib","permissions"]}}}},"meta-name":{"name":"meta-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"meta-name","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"meta-value":{"name":"meta-value","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"meta-value","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"milestone-end":{"name":"milestone-end","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"rationale":{"name":"rationale"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"milestone-end","content":{"type":",","blocks":[]}}},"milestone-start":{"name":"milestone-start","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"rationale":{"name":"rationale"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"milestone-start","content":{"type":",","blocks":[]}}},"mixed-citation":{"name":"mixed-citation","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-type":{"name":"publication-type"},"publisher-type":{"name":"publisher-type"},"publication-format":{"name":"publication-format"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"mixed-citation","content":{"type":"*","block":{"type":"|","blocks":["TEXT","inline-supplementary-material","related-article","related-object","hr","string-date","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","label","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","annotation","article-title","chapter-title","collab","collab-alternatives","comment","conf-acronym","conf-date","conf-loc","conf-name","conf-sponsor","data-title","date","date-in-citation","day","edition","email","elocation-id","etal","ext-link","fpage","gov","institution","institution-wrap","isbn","issn","issn-l","issue","issue-id","issue-part","issue-title","lpage","month","name","name-alternatives","object-id","page-range","part-title","patent","person-group","pub-id","publisher-loc","publisher-name","role","season","series","size","source","std","string-name","supplement","trans-source","trans-title","uri","version","volume","volume-id","volume-series","year","fn","target","xref","sub","sup","x"]}}}},"mml:abs":{"name":"mml:abs","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:abs","content":{"type":",","blocks":[]}}},"mml:and":{"name":"mml:and","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:and","content":{"type":",","blocks":[]}}},"mml:annotation":{"name":"mml:annotation","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"cd":{"name":"cd"},"name":{"name":"name"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"src":{"name":"src"}},"elements":{"name":"mml:annotation","content":"TEXT"}},"mml:annotation-xml":{"name":"mml:annotation-xml","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"cd":{"name":"cd"},"name":{"name":"name"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"src":{"name":"src"}},"elements":{"name":"mml:annotation-xml","content":{"type":"+","block":"p"}}},"mml:apply":{"name":"mml:apply","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"}},"elements":{"name":"mml:apply","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]},{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":[{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},"mml:degree","mml:momentabout","mml:logbase"]}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:approx":{"name":"mml:approx","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:approx","content":{"type":",","blocks":[]}}},"mml:arccos":{"name":"mml:arccos","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccos","content":{"type":",","blocks":[]}}},"mml:arccosh":{"name":"mml:arccosh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccosh","content":{"type":",","blocks":[]}}},"mml:arccot":{"name":"mml:arccot","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccot","content":{"type":",","blocks":[]}}},"mml:arccoth":{"name":"mml:arccoth","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccoth","content":{"type":",","blocks":[]}}},"mml:arccsc":{"name":"mml:arccsc","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccsc","content":{"type":",","blocks":[]}}},"mml:arccsch":{"name":"mml:arccsch","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arccsch","content":{"type":",","blocks":[]}}},"mml:arcsec":{"name":"mml:arcsec","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arcsec","content":{"type":",","blocks":[]}}},"mml:arcsech":{"name":"mml:arcsech","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arcsech","content":{"type":",","blocks":[]}}},"mml:arcsin":{"name":"mml:arcsin","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arcsin","content":{"type":",","blocks":[]}}},"mml:arcsinh":{"name":"mml:arcsinh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arcsinh","content":{"type":",","blocks":[]}}},"mml:arctan":{"name":"mml:arctan","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arctan","content":{"type":",","blocks":[]}}},"mml:arctanh":{"name":"mml:arctanh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arctanh","content":{"type":",","blocks":[]}}},"mml:arg":{"name":"mml:arg","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:arg","content":{"type":",","blocks":[]}}},"mml:bind":{"name":"mml:bind","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"}},"elements":{"name":"mml:bind","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]},{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":[{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},"mml:degree","mml:momentabout","mml:logbase"]}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:bvar":{"name":"mml:bvar","type":"element","attributes":{},"elements":{"name":"mml:bvar","content":{"type":"|","blocks":[{"type":",","blocks":["mml:degree",{"type":"|","blocks":["mml:ci","mml:semantics"]}]},{"type":",","blocks":[{"type":"|","blocks":["mml:ci","mml:semantics"]},{"type":"?","block":"mml:degree"}]}]}}},"mml:card":{"name":"mml:card","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:card","content":{"type":",","blocks":[]}}},"mml:cartesianproduct":{"name":"mml:cartesianproduct","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cartesianproduct","content":{"type":",","blocks":[]}}},"mml:cbytes":{"name":"mml:cbytes","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cbytes","content":"TEXT"}},"mml:ceiling":{"name":"mml:ceiling","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:ceiling","content":{"type":",","blocks":[]}}},"mml:cerror":{"name":"mml:cerror","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"}},"elements":{"name":"mml:cerror","content":{"type":",","blocks":["mml:csymbol",{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:ci":{"name":"mml:ci","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"type":{"name":"type"}},"elements":{"name":"mml:ci","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:cn":{"name":"mml:cn","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"type":{"name":"type"},"base":{"name":"base"}},"elements":{"name":"mml:cn","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:sep","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:codomain":{"name":"mml:codomain","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:codomain","content":{"type":",","blocks":[]}}},"mml:complexes":{"name":"mml:complexes","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:complexes","content":{"type":",","blocks":[]}}},"mml:compose":{"name":"mml:compose","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:compose","content":{"type":",","blocks":[]}}},"mml:condition":{"name":"mml:condition","type":"element","attributes":{},"elements":{"name":"mml:condition","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:conjugate":{"name":"mml:conjugate","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:conjugate","content":{"type":",","blocks":[]}}},"mml:cos":{"name":"mml:cos","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cos","content":{"type":",","blocks":[]}}},"mml:cosh":{"name":"mml:cosh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cosh","content":{"type":",","blocks":[]}}},"mml:cot":{"name":"mml:cot","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cot","content":{"type":",","blocks":[]}}},"mml:coth":{"name":"mml:coth","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:coth","content":{"type":",","blocks":[]}}},"mml:cs":{"name":"mml:cs","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:cs","content":"TEXT"}},"mml:csc":{"name":"mml:csc","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:csc","content":{"type":",","blocks":[]}}},"mml:csch":{"name":"mml:csch","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:csch","content":{"type":",","blocks":[]}}},"mml:csymbol":{"name":"mml:csymbol","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"type":{"name":"type"},"cd":{"name":"cd"}},"elements":{"name":"mml:csymbol","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:curl":{"name":"mml:curl","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:curl","content":{"type":",","blocks":[]}}},"mml:declare":{"name":"mml:declare","type":"element","attributes":{"type":{"name":"type"},"scope":{"name":"scope"},"nargs":{"name":"nargs"},"occurrence":{"name":"occurrence"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:declare","content":{"type":"+","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}}},"mml:degree":{"name":"mml:degree","type":"element","attributes":{},"elements":{"name":"mml:degree","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:determinant":{"name":"mml:determinant","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:determinant","content":{"type":",","blocks":[]}}},"mml:diff":{"name":"mml:diff","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:diff","content":{"type":",","blocks":[]}}},"mml:divergence":{"name":"mml:divergence","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:divergence","content":{"type":",","blocks":[]}}},"mml:divide":{"name":"mml:divide","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:divide","content":{"type":",","blocks":[]}}},"mml:domain":{"name":"mml:domain","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:domain","content":{"type":",","blocks":[]}}},"mml:domainofapplication":{"name":"mml:domainofapplication","type":"element","attributes":{},"elements":{"name":"mml:domainofapplication","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:emptyset":{"name":"mml:emptyset","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:emptyset","content":{"type":",","blocks":[]}}},"mml:eq":{"name":"mml:eq","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:eq","content":{"type":",","blocks":[]}}},"mml:equivalent":{"name":"mml:equivalent","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:equivalent","content":{"type":",","blocks":[]}}},"mml:eulergamma":{"name":"mml:eulergamma","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:eulergamma","content":{"type":",","blocks":[]}}},"mml:exists":{"name":"mml:exists","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:exists","content":{"type":",","blocks":[]}}},"mml:exp":{"name":"mml:exp","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:exp","content":{"type":",","blocks":[]}}},"mml:exponentiale":{"name":"mml:exponentiale","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:exponentiale","content":{"type":",","blocks":[]}}},"mml:factorial":{"name":"mml:factorial","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:factorial","content":{"type":",","blocks":[]}}},"mml:factorof":{"name":"mml:factorof","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:factorof","content":{"type":",","blocks":[]}}},"mml:false":{"name":"mml:false","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:false","content":{"type":",","blocks":[]}}},"mml:floor":{"name":"mml:floor","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:floor","content":{"type":",","blocks":[]}}},"mml:fn":{"name":"mml:fn","type":"element","attributes":{},"elements":{"name":"mml:fn","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:forall":{"name":"mml:forall","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:forall","content":{"type":",","blocks":[]}}},"mml:gcd":{"name":"mml:gcd","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:gcd","content":{"type":",","blocks":[]}}},"mml:geq":{"name":"mml:geq","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:geq","content":{"type":",","blocks":[]}}},"mml:grad":{"name":"mml:grad","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:grad","content":{"type":",","blocks":[]}}},"mml:gt":{"name":"mml:gt","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:gt","content":{"type":",","blocks":[]}}},"mml:ident":{"name":"mml:ident","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:ident","content":{"type":",","blocks":[]}}},"mml:image":{"name":"mml:image","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:image","content":{"type":",","blocks":[]}}},"mml:imaginary":{"name":"mml:imaginary","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:imaginary","content":{"type":",","blocks":[]}}},"mml:imaginaryi":{"name":"mml:imaginaryi","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:imaginaryi","content":{"type":",","blocks":[]}}},"mml:implies":{"name":"mml:implies","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:implies","content":{"type":",","blocks":[]}}},"mml:in":{"name":"mml:in","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:in","content":{"type":",","blocks":[]}}},"mml:infinity":{"name":"mml:infinity","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:infinity","content":{"type":",","blocks":[]}}},"mml:int":{"name":"mml:int","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:int","content":{"type":",","blocks":[]}}},"mml:integers":{"name":"mml:integers","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:integers","content":{"type":",","blocks":[]}}},"mml:intersect":{"name":"mml:intersect","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:intersect","content":{"type":",","blocks":[]}}},"mml:interval":{"name":"mml:interval","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"closure":{"name":"closure"}},"elements":{"name":"mml:interval","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}]}}},"mml:inverse":{"name":"mml:inverse","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:inverse","content":{"type":",","blocks":[]}}},"mml:lambda":{"name":"mml:lambda","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:lambda","content":{"type":",","blocks":[{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}]}}},"mml:laplacian":{"name":"mml:laplacian","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:laplacian","content":{"type":",","blocks":[]}}},"mml:lcm":{"name":"mml:lcm","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:lcm","content":{"type":",","blocks":[]}}},"mml:leq":{"name":"mml:leq","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:leq","content":{"type":",","blocks":[]}}},"mml:limit":{"name":"mml:limit","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:limit","content":{"type":",","blocks":[]}}},"mml:list":{"name":"mml:list","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"order":{"name":"order"}},"elements":{"name":"mml:list","content":{"type":",","blocks":[{"type":"*","block":{"type":"*","block":"mml:bvar"}},{"type":"*","block":{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:ln":{"name":"mml:ln","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:ln","content":{"type":",","blocks":[]}}},"mml:log":{"name":"mml:log","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:log","content":{"type":",","blocks":[]}}},"mml:logbase":{"name":"mml:logbase","type":"element","attributes":{},"elements":{"name":"mml:logbase","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:lowlimit":{"name":"mml:lowlimit","type":"element","attributes":{},"elements":{"name":"mml:lowlimit","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:lt":{"name":"mml:lt","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:lt","content":{"type":",","blocks":[]}}},"mml:maction":{"name":"mml:maction","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"actiontype":{"name":"actiontype"},"selection":{"name":"selection"}},"elements":{"name":"mml:maction","content":{"type":"+","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:maligngroup":{"name":"mml:maligngroup","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"groupalign":{"name":"groupalign"}},"elements":{"name":"mml:maligngroup","content":{"type":",","blocks":[]}}},"mml:malignmark":{"name":"mml:malignmark","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"edge":{"name":"edge"}},"elements":{"name":"mml:malignmark","content":{"type":",","blocks":[]}}},"mml:math":{"name":"mml:math","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"display":{"name":"display"},"maxwidth":{"name":"maxwidth"},"overflow":{"name":"overflow"},"altimg":{"name":"altimg"},"altimg-width":{"name":"altimg-width"},"altimg-height":{"name":"altimg-height"},"altimg-valign":{"name":"altimg-valign"},"alttext":{"name":"alttext"},"cdgroup":{"name":"cdgroup"},"mode":{"name":"mode"},"macros":{"name":"macros"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"scriptlevel":{"name":"scriptlevel"},"displaystyle":{"name":"displaystyle"},"scriptsizemultiplier":{"name":"scriptsizemultiplier"},"scriptminsize":{"name":"scriptminsize"},"infixlinebreakstyle":{"name":"infixlinebreakstyle"},"decimalpoint":{"name":"decimalpoint"},"accent":{"name":"accent"},"accentunder":{"name":"accentunder"},"align":{"name":"align"},"alignmentscope":{"name":"alignmentscope"},"bevelled":{"name":"bevelled"},"charalign":{"name":"charalign"},"charspacing":{"name":"charspacing"},"close":{"name":"close"},"columnalign":{"name":"columnalign"},"columnlines":{"name":"columnlines"},"columnspacing":{"name":"columnspacing"},"columnspan":{"name":"columnspan"},"columnwidth":{"name":"columnwidth"},"crossout":{"name":"crossout"},"denomalign":{"name":"denomalign"},"depth":{"name":"depth"},"dir":{"name":"dir"},"edge":{"name":"edge"},"equalcolumns":{"name":"equalcolumns"},"equalrows":{"name":"equalrows"},"fence":{"name":"fence"},"form":{"name":"form"},"frame":{"name":"frame"},"framespacing":{"name":"framespacing"},"groupalign":{"name":"groupalign"},"height":{"name":"height"},"indentalign":{"name":"indentalign"},"indentalignfirst":{"name":"indentalignfirst"},"indentalignlast":{"name":"indentalignlast"},"indentshift":{"name":"indentshift"},"indentshiftfirst":{"name":"indentshiftfirst"},"indentshiftlast":{"name":"indentshiftlast"},"indenttarget":{"name":"indenttarget"},"largeop":{"name":"largeop"},"leftoverhang":{"name":"leftoverhang"},"length":{"name":"length"},"linebreak":{"name":"linebreak"},"linebreakmultchar":{"name":"linebreakmultchar"},"linebreakstyle":{"name":"linebreakstyle"},"lineleading":{"name":"lineleading"},"linethickness":{"name":"linethickness"},"location":{"name":"location"},"longdivstyle":{"name":"longdivstyle"},"lquote":{"name":"lquote"},"lspace":{"name":"lspace"},"mathsize":{"name":"mathsize"},"mathvariant":{"name":"mathvariant"},"maxsize":{"name":"maxsize"},"minlabelspacing":{"name":"minlabelspacing"},"minsize":{"name":"minsize"},"movablelimits":{"name":"movablelimits"},"mslinethickness":{"name":"mslinethickness"},"notation":{"name":"notation"},"numalign":{"name":"numalign"},"open":{"name":"open"},"position":{"name":"position"},"rightoverhang":{"name":"rightoverhang"},"rowalign":{"name":"rowalign"},"rowlines":{"name":"rowlines"},"rowspacing":{"name":"rowspacing"},"rowspan":{"name":"rowspan"},"rquote":{"name":"rquote"},"rspace":{"name":"rspace"},"selection":{"name":"selection"},"separator":{"name":"separator"},"separators":{"name":"separators"},"shift":{"name":"shift"},"side":{"name":"side"},"stackalign":{"name":"stackalign"},"stretchy":{"name":"stretchy"},"subscriptshift":{"name":"subscriptshift"},"superscriptshift":{"name":"superscriptshift"},"symmetric":{"name":"symmetric"},"valign":{"name":"valign"},"width":{"name":"width"}},"elements":{"name":"mml:math","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:matrix":{"name":"mml:matrix","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:matrix","content":{"type":",","blocks":[{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:matrixrow":{"name":"mml:matrixrow","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:matrixrow","content":{"type":",","blocks":[{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:max":{"name":"mml:max","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:max","content":{"type":",","blocks":[]}}},"mml:mean":{"name":"mml:mean","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:mean","content":{"type":",","blocks":[]}}},"mml:median":{"name":"mml:median","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:median","content":{"type":",","blocks":[]}}},"mml:menclose":{"name":"mml:menclose","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"notation":{"name":"notation"}},"elements":{"name":"mml:menclose","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:merror":{"name":"mml:merror","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:merror","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:mfenced":{"name":"mml:mfenced","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"open":{"name":"open"},"close":{"name":"close"},"separators":{"name":"separators"}},"elements":{"name":"mml:mfenced","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:mfrac":{"name":"mml:mfrac","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"linethickness":{"name":"linethickness"},"numalign":{"name":"numalign"},"denomalign":{"name":"denomalign"},"bevelled":{"name":"bevelled"}},"elements":{"name":"mml:mfrac","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:mglyph":{"name":"mml:mglyph","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"src":{"name":"src"},"width":{"name":"width"},"height":{"name":"height"},"valign":{"name":"valign"},"alt":{"name":"alt"},"index":{"name":"index"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"}},"elements":{"name":"mml:mglyph","content":{"type":",","blocks":[]}}},"mml:mi":{"name":"mml:mi","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"}},"elements":{"name":"mml:mi","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:malignmark"]}}}},"mml:min":{"name":"mml:min","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:min","content":{"type":",","blocks":[]}}},"mml:minus":{"name":"mml:minus","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:minus","content":{"type":",","blocks":[]}}},"mml:mlabeledtr":{"name":"mml:mlabeledtr","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"rowalign":{"name":"rowalign"},"columnalign":{"name":"columnalign"},"groupalign":{"name":"groupalign"}},"elements":{"name":"mml:mlabeledtr","content":{"type":"+","block":"mml:mtd"}}},"mml:mlongdiv":{"name":"mml:mlongdiv","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"position":{"name":"position"},"shift":{"name":"shift"},"longdivstyle":{"name":"longdivstyle"}},"elements":{"name":"mml:mlongdiv","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:mscarries","mml:msline","mml:msrow","mml:msgroup"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:mscarries","mml:msline","mml:msrow","mml:msgroup"]},{"type":"+","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:mscarries","mml:msline","mml:msrow","mml:msgroup"]}}]}}},"mml:mmultiscripts":{"name":"mml:mmultiscripts","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"subscriptshift":{"name":"subscriptshift"},"superscriptshift":{"name":"superscriptshift"}},"elements":{"name":"mml:mmultiscripts","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"*","block":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]}]}},{"type":"?","block":{"type":",","blocks":["mml:mprescripts",{"type":"*","block":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]}]}}]}}]}}},"mml:mn":{"name":"mml:mn","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"}},"elements":{"name":"mml:mn","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:malignmark"]}}}},"mml:mo":{"name":"mml:mo","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"},"form":{"name":"form"},"fence":{"name":"fence"},"separator":{"name":"separator"},"lspace":{"name":"lspace"},"rspace":{"name":"rspace"},"stretchy":{"name":"stretchy"},"symmetric":{"name":"symmetric"},"maxsize":{"name":"maxsize"},"minsize":{"name":"minsize"},"largeop":{"name":"largeop"},"movablelimits":{"name":"movablelimits"},"accent":{"name":"accent"},"linebreak":{"name":"linebreak"},"lineleading":{"name":"lineleading"},"linebreakstyle":{"name":"linebreakstyle"},"linebreakmultchar":{"name":"linebreakmultchar"},"indentalign":{"name":"indentalign"},"indentshift":{"name":"indentshift"},"indenttarget":{"name":"indenttarget"},"indentalignfirst":{"name":"indentalignfirst"},"indentshiftfirst":{"name":"indentshiftfirst"},"indentalignlast":{"name":"indentalignlast"},"indentshiftlast":{"name":"indentshiftlast"}},"elements":{"name":"mml:mo","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:malignmark"]}}}},"mml:mode":{"name":"mml:mode","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:mode","content":{"type":",","blocks":[]}}},"mml:moment":{"name":"mml:moment","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:moment","content":{"type":",","blocks":[]}}},"mml:momentabout":{"name":"mml:momentabout","type":"element","attributes":{},"elements":{"name":"mml:momentabout","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:mover":{"name":"mml:mover","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"accent":{"name":"accent"},"align":{"name":"align"}},"elements":{"name":"mml:mover","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:mpadded":{"name":"mml:mpadded","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"height":{"name":"height"},"depth":{"name":"depth"},"width":{"name":"width"},"lspace":{"name":"lspace"},"voffset":{"name":"voffset"}},"elements":{"name":"mml:mpadded","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:mphantom":{"name":"mml:mphantom","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:mphantom","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:mprescripts":{"name":"mml:mprescripts","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:mprescripts","content":{"type":",","blocks":[]}}},"mml:mroot":{"name":"mml:mroot","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:mroot","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:mrow":{"name":"mml:mrow","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"dir":{"name":"dir"}},"elements":{"name":"mml:mrow","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:ms":{"name":"mml:ms","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"},"lquote":{"name":"lquote"},"rquote":{"name":"rquote"}},"elements":{"name":"mml:ms","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:malignmark"]}}}},"mml:mscarries":{"name":"mml:mscarries","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"position":{"name":"position"},"location":{"name":"location"},"crossout":{"name":"crossout"},"scriptsizemultiplier":{"name":"scriptsizemultiplier"}},"elements":{"name":"mml:mscarries","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none","mml:mscarry"]}}}},"mml:mscarry":{"name":"mml:mscarry","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"location":{"name":"location"},"crossout":{"name":"crossout"}},"elements":{"name":"mml:mscarry","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]}}}},"mml:msgroup":{"name":"mml:msgroup","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"position":{"name":"position"},"shift":{"name":"shift"}},"elements":{"name":"mml:msgroup","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:mscarries","mml:msline","mml:msrow","mml:msgroup"]}}}},"mml:msline":{"name":"mml:msline","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"position":{"name":"position"},"length":{"name":"length"},"leftoverhang":{"name":"leftoverhang"},"rightoverhang":{"name":"rightoverhang"},"mslinethickness":{"name":"mslinethickness"}},"elements":{"name":"mml:msline","content":{"type":",","blocks":[]}}},"mml:mspace":{"name":"mml:mspace","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"},"width":{"name":"width"},"height":{"name":"height"},"depth":{"name":"depth"},"linebreak":{"name":"linebreak"}},"elements":{"name":"mml:mspace","content":{"type":",","blocks":[]}}},"mml:msqrt":{"name":"mml:msqrt","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:msqrt","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:msrow":{"name":"mml:msrow","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"position":{"name":"position"}},"elements":{"name":"mml:msrow","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:none"]}}}},"mml:mstack":{"name":"mml:mstack","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"align":{"name":"align"},"stackalign":{"name":"stackalign"},"charalign":{"name":"charalign"},"charspacing":{"name":"charspacing"}},"elements":{"name":"mml:mstack","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction","mml:mscarries","mml:msline","mml:msrow","mml:msgroup"]}}}},"mml:mstyle":{"name":"mml:mstyle","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"scriptlevel":{"name":"scriptlevel"},"displaystyle":{"name":"displaystyle"},"scriptsizemultiplier":{"name":"scriptsizemultiplier"},"scriptminsize":{"name":"scriptminsize"},"infixlinebreakstyle":{"name":"infixlinebreakstyle"},"decimalpoint":{"name":"decimalpoint"},"accent":{"name":"accent"},"accentunder":{"name":"accentunder"},"align":{"name":"align"},"alignmentscope":{"name":"alignmentscope"},"bevelled":{"name":"bevelled"},"charalign":{"name":"charalign"},"charspacing":{"name":"charspacing"},"close":{"name":"close"},"columnalign":{"name":"columnalign"},"columnlines":{"name":"columnlines"},"columnspacing":{"name":"columnspacing"},"columnspan":{"name":"columnspan"},"columnwidth":{"name":"columnwidth"},"crossout":{"name":"crossout"},"denomalign":{"name":"denomalign"},"depth":{"name":"depth"},"dir":{"name":"dir"},"edge":{"name":"edge"},"equalcolumns":{"name":"equalcolumns"},"equalrows":{"name":"equalrows"},"fence":{"name":"fence"},"form":{"name":"form"},"frame":{"name":"frame"},"framespacing":{"name":"framespacing"},"groupalign":{"name":"groupalign"},"height":{"name":"height"},"indentalign":{"name":"indentalign"},"indentalignfirst":{"name":"indentalignfirst"},"indentalignlast":{"name":"indentalignlast"},"indentshift":{"name":"indentshift"},"indentshiftfirst":{"name":"indentshiftfirst"},"indentshiftlast":{"name":"indentshiftlast"},"indenttarget":{"name":"indenttarget"},"largeop":{"name":"largeop"},"leftoverhang":{"name":"leftoverhang"},"length":{"name":"length"},"linebreak":{"name":"linebreak"},"linebreakmultchar":{"name":"linebreakmultchar"},"linebreakstyle":{"name":"linebreakstyle"},"lineleading":{"name":"lineleading"},"linethickness":{"name":"linethickness"},"location":{"name":"location"},"longdivstyle":{"name":"longdivstyle"},"lquote":{"name":"lquote"},"lspace":{"name":"lspace"},"mathsize":{"name":"mathsize"},"mathvariant":{"name":"mathvariant"},"maxsize":{"name":"maxsize"},"minlabelspacing":{"name":"minlabelspacing"},"minsize":{"name":"minsize"},"movablelimits":{"name":"movablelimits"},"mslinethickness":{"name":"mslinethickness"},"notation":{"name":"notation"},"numalign":{"name":"numalign"},"open":{"name":"open"},"position":{"name":"position"},"rightoverhang":{"name":"rightoverhang"},"rowalign":{"name":"rowalign"},"rowlines":{"name":"rowlines"},"rowspacing":{"name":"rowspacing"},"rowspan":{"name":"rowspan"},"rquote":{"name":"rquote"},"rspace":{"name":"rspace"},"selection":{"name":"selection"},"separator":{"name":"separator"},"separators":{"name":"separators"},"shift":{"name":"shift"},"side":{"name":"side"},"stackalign":{"name":"stackalign"},"stretchy":{"name":"stretchy"},"subscriptshift":{"name":"subscriptshift"},"superscriptshift":{"name":"superscriptshift"},"symmetric":{"name":"symmetric"},"valign":{"name":"valign"},"width":{"name":"width"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"},"veryverythinmathspace":{"name":"veryverythinmathspace"},"verythinmathspace":{"name":"verythinmathspace"},"thinmathspace":{"name":"thinmathspace"},"mediummathspace":{"name":"mediummathspace"},"thickmathspace":{"name":"thickmathspace"},"verythickmathspace":{"name":"verythickmathspace"},"veryverythickmathspace":{"name":"veryverythickmathspace"}},"elements":{"name":"mml:mstyle","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:msub":{"name":"mml:msub","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"subscriptshift":{"name":"subscriptshift"}},"elements":{"name":"mml:msub","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:msubsup":{"name":"mml:msubsup","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"subscriptshift":{"name":"subscriptshift"},"superscriptshift":{"name":"superscriptshift"}},"elements":{"name":"mml:msubsup","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:msup":{"name":"mml:msup","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"superscriptshift":{"name":"superscriptshift"}},"elements":{"name":"mml:msup","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:mtable":{"name":"mml:mtable","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"align":{"name":"align"},"rowalign":{"name":"rowalign"},"columnalign":{"name":"columnalign"},"groupalign":{"name":"groupalign"},"alignmentscope":{"name":"alignmentscope"},"columnwidth":{"name":"columnwidth"},"width":{"name":"width"},"rowspacing":{"name":"rowspacing"},"columnspacing":{"name":"columnspacing"},"rowlines":{"name":"rowlines"},"columnlines":{"name":"columnlines"},"frame":{"name":"frame"},"framespacing":{"name":"framespacing"},"equalrows":{"name":"equalrows"},"equalcolumns":{"name":"equalcolumns"},"displaystyle":{"name":"displaystyle"},"side":{"name":"side"},"minlabelspacing":{"name":"minlabelspacing"}},"elements":{"name":"mml:mtable","content":{"type":"*","block":{"type":"|","blocks":["mml:mtr","mml:mlabeledtr"]}}}},"mml:mtd":{"name":"mml:mtd","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"rowspan":{"name":"rowspan"},"columnspan":{"name":"columnspan"},"rowalign":{"name":"rowalign"},"columnalign":{"name":"columnalign"},"groupalign":{"name":"groupalign"}},"elements":{"name":"mml:mtd","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}}}},"mml:mtext":{"name":"mml:mtext","type":"text","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"mathvariant":{"name":"mathvariant"},"mathsize":{"name":"mathsize"},"dir":{"name":"dir"},"fontfamily":{"name":"fontfamily"},"fontweight":{"name":"fontweight"},"fontstyle":{"name":"fontstyle"},"fontsize":{"name":"fontsize"},"color":{"name":"color"},"background":{"name":"background"}},"elements":{"name":"mml:mtext","content":{"type":"*","block":{"type":"|","blocks":["TEXT","mml:mglyph","mml:malignmark"]}}}},"mml:mtr":{"name":"mml:mtr","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"rowalign":{"name":"rowalign"},"columnalign":{"name":"columnalign"},"groupalign":{"name":"groupalign"}},"elements":{"name":"mml:mtr","content":{"type":"*","block":"mml:mtd"}}},"mml:munder":{"name":"mml:munder","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"accentunder":{"name":"accentunder"},"align":{"name":"align"}},"elements":{"name":"mml:munder","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:munderover":{"name":"mml:munderover","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"},"accent":{"name":"accent"},"accentunder":{"name":"accentunder"},"align":{"name":"align"}},"elements":{"name":"mml:munderover","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]}]}}},"mml:naturalnumbers":{"name":"mml:naturalnumbers","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:naturalnumbers","content":{"type":",","blocks":[]}}},"mml:neq":{"name":"mml:neq","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:neq","content":{"type":",","blocks":[]}}},"mml:none":{"name":"mml:none","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"mathcolor":{"name":"mathcolor"},"mathbackground":{"name":"mathbackground"}},"elements":{"name":"mml:none","content":{"type":",","blocks":[]}}},"mml:not":{"name":"mml:not","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:not","content":{"type":",","blocks":[]}}},"mml:notanumber":{"name":"mml:notanumber","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:notanumber","content":{"type":",","blocks":[]}}},"mml:notin":{"name":"mml:notin","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:notin","content":{"type":",","blocks":[]}}},"mml:notprsubset":{"name":"mml:notprsubset","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:notprsubset","content":{"type":",","blocks":[]}}},"mml:notsubset":{"name":"mml:notsubset","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:notsubset","content":{"type":",","blocks":[]}}},"mml:or":{"name":"mml:or","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:or","content":{"type":",","blocks":[]}}},"mml:otherwise":{"name":"mml:otherwise","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:otherwise","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:outerproduct":{"name":"mml:outerproduct","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:outerproduct","content":{"type":",","blocks":[]}}},"mml:partialdiff":{"name":"mml:partialdiff","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:partialdiff","content":{"type":",","blocks":[]}}},"mml:pi":{"name":"mml:pi","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:pi","content":{"type":",","blocks":[]}}},"mml:piece":{"name":"mml:piece","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:piece","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]},{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}]}}},"mml:piecewise":{"name":"mml:piecewise","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:piecewise","content":{"type":"*","block":{"type":"|","blocks":["mml:piece","mml:otherwise"]}}}},"mml:plus":{"name":"mml:plus","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:plus","content":{"type":",","blocks":[]}}},"mml:power":{"name":"mml:power","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:power","content":{"type":",","blocks":[]}}},"mml:primes":{"name":"mml:primes","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:primes","content":{"type":",","blocks":[]}}},"mml:product":{"name":"mml:product","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:product","content":{"type":",","blocks":[]}}},"mml:prsubset":{"name":"mml:prsubset","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:prsubset","content":{"type":",","blocks":[]}}},"mml:quotient":{"name":"mml:quotient","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:quotient","content":{"type":",","blocks":[]}}},"mml:rationals":{"name":"mml:rationals","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:rationals","content":{"type":",","blocks":[]}}},"mml:real":{"name":"mml:real","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:real","content":{"type":",","blocks":[]}}},"mml:reals":{"name":"mml:reals","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:reals","content":{"type":",","blocks":[]}}},"mml:reln":{"name":"mml:reln","type":"element","attributes":{},"elements":{"name":"mml:reln","content":{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}}},"mml:rem":{"name":"mml:rem","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:rem","content":{"type":",","blocks":[]}}},"mml:root":{"name":"mml:root","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:root","content":{"type":",","blocks":[]}}},"mml:scalarproduct":{"name":"mml:scalarproduct","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:scalarproduct","content":{"type":",","blocks":[]}}},"mml:sdev":{"name":"mml:sdev","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sdev","content":{"type":",","blocks":[]}}},"mml:sec":{"name":"mml:sec","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sec","content":{"type":",","blocks":[]}}},"mml:sech":{"name":"mml:sech","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sech","content":{"type":",","blocks":[]}}},"mml:selector":{"name":"mml:selector","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:selector","content":{"type":",","blocks":[]}}},"mml:semantics":{"name":"mml:semantics","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"cd":{"name":"cd"},"name":{"name":"name"}},"elements":{"name":"mml:semantics","content":{"type":",","blocks":[{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs","mml:mi","mml:mn","mml:mo","mml:mtext","mml:mspace","mml:ms","mml:maligngroup","mml:malignmark","mml:mrow","mml:mfrac","mml:msqrt","mml:mroot","mml:mstyle","mml:merror","mml:mpadded","mml:mphantom","mml:mfenced","mml:menclose","mml:msub","mml:msup","mml:msubsup","mml:munder","mml:mover","mml:munderover","mml:mmultiscripts","mml:mtable","mml:mstack","mml:mlongdiv","mml:maction"]},{"type":"*","block":{"type":"|","blocks":["mml:annotation","mml:annotation-xml"]}}]}}},"mml:sep":{"name":"mml:sep","type":"element","attributes":{},"elements":{"name":"mml:sep","content":{"type":",","blocks":[]}}},"mml:set":{"name":"mml:set","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"type":{"name":"type"}},"elements":{"name":"mml:set","content":{"type":",","blocks":[{"type":"*","block":{"type":"*","block":"mml:bvar"}},{"type":"*","block":{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:setdiff":{"name":"mml:setdiff","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:setdiff","content":{"type":",","blocks":[]}}},"mml:share":{"name":"mml:share","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"src":{"name":"src"}},"elements":{"name":"mml:share","content":{"type":",","blocks":[]}}},"mml:sin":{"name":"mml:sin","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sin","content":{"type":",","blocks":[]}}},"mml:sinh":{"name":"mml:sinh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sinh","content":{"type":",","blocks":[]}}},"mml:subset":{"name":"mml:subset","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:subset","content":{"type":",","blocks":[]}}},"mml:sum":{"name":"mml:sum","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:sum","content":{"type":",","blocks":[]}}},"mml:tan":{"name":"mml:tan","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:tan","content":{"type":",","blocks":[]}}},"mml:tanh":{"name":"mml:tanh","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:tanh","content":{"type":",","blocks":[]}}},"mml:tendsto":{"name":"mml:tendsto","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"},"type":{"name":"type"}},"elements":{"name":"mml:tendsto","content":{"type":",","blocks":[]}}},"mml:times":{"name":"mml:times","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:times","content":{"type":",","blocks":[]}}},"mml:transpose":{"name":"mml:transpose","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:transpose","content":{"type":",","blocks":[]}}},"mml:true":{"name":"mml:true","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:true","content":{"type":",","blocks":[]}}},"mml:union":{"name":"mml:union","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:union","content":{"type":",","blocks":[]}}},"mml:uplimit":{"name":"mml:uplimit","type":"element","attributes":{},"elements":{"name":"mml:uplimit","content":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}},"mml:variance":{"name":"mml:variance","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:variance","content":{"type":",","blocks":[]}}},"mml:vector":{"name":"mml:vector","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:vector","content":{"type":",","blocks":[{"type":"*","block":"mml:bvar"},{"type":"*","block":{"type":"|","blocks":["mml:domainofapplication","mml:condition",{"type":",","blocks":["mml:lowlimit",{"type":"?","block":"mml:uplimit"}]}]}},{"type":"*","block":{"type":"|","blocks":["mml:piecewise","mml:reln","mml:fn","mml:declare","mml:interval","mml:inverse","mml:ident","mml:domain","mml:codomain","mml:image","mml:ln","mml:log","mml:moment","mml:lambda","mml:compose","mml:quotient","mml:divide","mml:minus","mml:power","mml:rem","mml:root","mml:factorial","mml:abs","mml:conjugate","mml:arg","mml:real","mml:imaginary","mml:floor","mml:ceiling","mml:exp","mml:max","mml:min","mml:plus","mml:times","mml:gcd","mml:lcm","mml:and","mml:or","mml:xor","mml:not","mml:implies","mml:equivalent","mml:forall","mml:exists","mml:eq","mml:gt","mml:lt","mml:geq","mml:leq","mml:neq","mml:approx","mml:factorof","mml:tendsto","mml:int","mml:diff","mml:partialdiff","mml:divergence","mml:grad","mml:curl","mml:laplacian","mml:set","mml:list","mml:union","mml:intersect","mml:cartesianproduct","mml:in","mml:notin","mml:notsubset","mml:notprsubset","mml:setdiff","mml:subset","mml:prsubset","mml:card","mml:sum","mml:product","mml:limit","mml:sin","mml:cos","mml:tan","mml:sec","mml:csc","mml:cot","mml:sinh","mml:cosh","mml:tanh","mml:sech","mml:csch","mml:coth","mml:arcsin","mml:arccos","mml:arctan","mml:arccosh","mml:arccot","mml:arccoth","mml:arccsc","mml:arccsch","mml:arcsec","mml:arcsech","mml:arcsinh","mml:arctanh","mml:mean","mml:sdev","mml:variance","mml:median","mml:mode","mml:vector","mml:matrix","mml:matrixrow","mml:determinant","mml:transpose","mml:selector","mml:vectorproduct","mml:scalarproduct","mml:outerproduct","mml:integers","mml:reals","mml:rationals","mml:naturalnumbers","mml:complexes","mml:primes","mml:emptyset","mml:exponentiale","mml:imaginaryi","mml:notanumber","mml:true","mml:false","mml:pi","mml:eulergamma","mml:infinity","mml:semantics","mml:cn","mml:ci","mml:csymbol","mml:apply","mml:bind","mml:share","mml:cerror","mml:cbytes","mml:cs"]}}]}}},"mml:vectorproduct":{"name":"mml:vectorproduct","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:vectorproduct","content":{"type":",","blocks":[]}}},"mml:xor":{"name":"mml:xor","type":"element","attributes":{"xlink:href":{"name":"xlink:href"},"xlink:type":{"name":"xlink:type"},"xml:lang":{"name":"xml:lang"},"xml:space":{"name":"xml:space"},"id":{"name":"id"},"xref":{"name":"xref"},"class":{"name":"class"},"style":{"name":"style"},"href":{"name":"href"},"other":{"name":"other"},"encoding":{"name":"encoding"},"definitionURL":{"name":"definitionURL"}},"elements":{"name":"mml:xor","content":{"type":",","blocks":[]}}},"monospace":{"name":"monospace","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"monospace","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"month":{"name":"month","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"month","content":"TEXT"}},"name":{"name":"name","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"name-style":{"name":"name-style"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"name","content":{"type":",","blocks":[{"type":"|","blocks":[{"type":",","blocks":["surname",{"type":"?","block":"given-names"}]},"given-names"]},{"type":"?","block":"prefix"},{"type":"?","block":"suffix"}]}}},"name-alternatives":{"name":"name-alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"name-alternatives","content":{"type":"+","block":{"type":"|","blocks":["name","string-name"]}}}},"named-content":{"name":"named-content","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"alt":{"name":"alt"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"named-content","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","address","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","ack","disp-quote","speech","statement","verse-group"]}}}},"nested-kwd":{"name":"nested-kwd","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"nested-kwd","content":{"type":",","blocks":[{"type":"+","block":{"type":"|","blocks":["kwd","compound-kwd"]}},{"type":"*","block":"nested-kwd"}]}}},"nlm-citation":{"name":"nlm-citation","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-type":{"name":"publication-type"},"publisher-type":{"name":"publisher-type"},"publication-format":{"name":"publication-format"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"nlm-citation","content":{"type":",","blocks":[{"type":"*","block":{"type":"|","blocks":["person-group","collab"]}},{"type":"*","block":{"type":"|","blocks":["article-title","trans-title"]}},{"type":"?","block":"source"},{"type":"?","block":"patent"},{"type":"?","block":"trans-source"},{"type":"?","block":"year"},{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":"month"},{"type":"?","block":"day"},{"type":"?","block":"time-stamp"}]},{"type":"?","block":"season"}]},{"type":"?","block":"access-date"},{"type":"?","block":"volume"},{"type":"?","block":"edition"},{"type":"?","block":"conf-name"},{"type":"?","block":"conf-date"},{"type":"?","block":"conf-loc"},{"type":"*","block":{"type":"|","blocks":["issue","supplement"]}},{"type":"?","block":"publisher-loc"},{"type":"?","block":"publisher-name"},{"type":"*","block":{"type":",","blocks":[{"type":"?","block":"fpage"},{"type":"?","block":"lpage"}]}},{"type":"?","block":"page-count"},{"type":"?","block":"series"},{"type":"*","block":"comment"},{"type":"*","block":"pub-id"},{"type":"?","block":"annotation"}]}}},"note":{"name":"note","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"note","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"+","block":{"type":"|","blocks":["p","product"]}}]}}},"notes":{"name":"notes","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"notes-type":{"name":"notes-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"notes","content":{"type":",","blocks":[{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"oasis:colspec":{"name":"oasis:colspec","type":"element","attributes":{"colnum":{"name":"colnum"},"colname":{"name":"colname"},"colwidth":{"name":"colwidth"},"colsep":{"name":"colsep"},"rowsep":{"name":"rowsep"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:colspec","content":{"type":",","blocks":[]}}},"oasis:entry":{"name":"oasis:entry","type":"text","attributes":{"colname":{"name":"colname"},"namest":{"name":"namest"},"nameend":{"name":"nameend"},"morerows":{"name":"morerows"},"colsep":{"name":"colsep"},"rowsep":{"name":"rowsep"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:entry","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","disp-formula","disp-formula-group","break","chem-struct-wrap","citation-alternatives","element-citation","mixed-citation","nlm-citation","def-list","list","p","array","code","graphic","media","preformat"]}}}},"oasis:row":{"name":"oasis:row","type":"element","attributes":{"rowsep":{"name":"rowsep"},"valign":{"name":"valign"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:row","content":{"type":"+","block":"oasis:entry"}}},"oasis:table":{"name":"oasis:table","type":"element","attributes":{"frame":{"name":"frame"},"colsep":{"name":"colsep"},"rowsep":{"name":"rowsep"},"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"content-type":{"name":"content-type"}},"elements":{"name":"oasis:table","content":{"type":"+","block":"oasis:tgroup"}}},"oasis:tbody":{"name":"oasis:tbody","type":"element","attributes":{"valign":{"name":"valign"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:tbody","content":{"type":"+","block":"oasis:row"}}},"oasis:tgroup":{"name":"oasis:tgroup","type":"element","attributes":{"cols":{"name":"cols"},"colsep":{"name":"colsep"},"rowsep":{"name":"rowsep"},"align":{"name":"align"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:tgroup","content":{"type":",","blocks":[{"type":"*","block":"oasis:colspec"},{"type":"?","block":"oasis:thead"},"oasis:tbody"]}}},"oasis:thead":{"name":"oasis:thead","type":"element","attributes":{"valign":{"name":"valign"},"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"oasis:thead","content":{"type":"+","block":"oasis:row"}}},"object-id":{"name":"object-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"object-id","content":"TEXT"}},"on-behalf-of":{"name":"on-behalf-of","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"on-behalf-of","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","institution","institution-wrap"]}}}},"open-access":{"name":"open-access","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"open-access","content":{"type":"+","block":"p"}}},"overline":{"name":"overline","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"overline","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"overline-end":{"name":"overline-end","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"}},"elements":{"name":"overline-end","content":{"type":",","blocks":[]}}},"overline-start":{"name":"overline-start","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"}},"elements":{"name":"overline-start","content":{"type":",","blocks":[]}}},"p":{"name":"p","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"p","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","address","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","citation-alternatives","element-citation","mixed-citation","nlm-citation","award-id","funding-source","open-access","def-list","list","ack","disp-quote","speech","statement","verse-group"]}}}},"page-count":{"name":"page-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"page-count","content":{"type":",","blocks":[]}}},"page-range":{"name":"page-range","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"page-range","content":"TEXT"}},"part-title":{"name":"part-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"part-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"patent":{"name":"patent","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"patent","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"permissions":{"name":"permissions","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"permissions","content":{"type":",","blocks":[{"type":"*","block":"copyright-statement"},{"type":"*","block":"copyright-year"},{"type":"*","block":"copyright-holder"},{"type":"*","block":{"type":"|","blocks":["ali:free_to_read","license"]}}]}}},"person-group":{"name":"person-group","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"person-group-type":{"name":"person-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"person-group","content":{"type":"*","block":{"type":"|","blocks":["TEXT","anonymous","collab","collab-alternatives","name","name-alternatives","string-name","aff","aff-alternatives","etal","role","x"]}}}},"phone":{"name":"phone","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"phone","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"postal-code":{"name":"postal-code","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"postal-code","content":"TEXT"}},"prefix":{"name":"prefix","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"prefix","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"preformat":{"name":"preformat","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"preformat-type":{"name":"preformat-type"},"xml:space":{"name":"xml:space"}},"elements":{"name":"preformat","content":{"type":"*","block":{"type":"|","blocks":["TEXT","alt-text","long-desc","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","attrib","permissions"]}}}},"price":{"name":"price","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"currency":{"name":"currency"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"price","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby"]}}}},"principal-award-recipient":{"name":"principal-award-recipient","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"principal-award-recipient","content":{"type":"*","block":{"type":"|","blocks":["TEXT","contrib-id","name","name-alternatives","institution","institution-wrap","string-name"]}}}},"principal-investigator":{"name":"principal-investigator","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"principal-investigator","content":{"type":"*","block":{"type":"|","blocks":["TEXT","contrib-id","name","name-alternatives","string-name"]}}}},"private-char":{"name":"private-char","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"description":{"name":"description"},"name":{"name":"name"},"specific-use":{"name":"specific-use"}},"elements":{"name":"private-char","content":{"type":"|","blocks":["glyph-data","glyph-ref",{"type":"*","block":"inline-graphic"}]}}},"product":{"name":"product","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"product-type":{"name":"product-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"product","content":{"type":"*","block":{"type":"|","blocks":["TEXT","inline-supplementary-material","related-article","related-object","hr","break","string-date","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","label","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","price","annotation","article-title","chapter-title","collab","collab-alternatives","comment","conf-acronym","conf-date","conf-loc","conf-name","conf-sponsor","data-title","date","date-in-citation","day","edition","email","elocation-id","etal","ext-link","fpage","gov","institution","institution-wrap","isbn","issn","issn-l","issue","issue-id","issue-part","issue-title","lpage","month","name","name-alternatives","object-id","page-range","part-title","patent","person-group","pub-id","publisher-loc","publisher-name","role","season","series","size","source","std","string-name","supplement","trans-source","trans-title","uri","version","volume","volume-id","volume-series","year","fn","target","xref","sub","sup","x"]}}}},"pub-date":{"name":"pub-date","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-type":{"name":"pub-type"},"publication-format":{"name":"publication-format"},"date-type":{"name":"date-type"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"pub-date","content":{"type":"*","block":{"type":"|","blocks":["day","era","month","season","year","string-date","x"]}}}},"pub-id":{"name":"pub-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"assigning-authority":{"name":"assigning-authority"},"specific-use":{"name":"specific-use"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"pub-id","content":"TEXT"}},"publisher":{"name":"publisher","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"publisher","content":{"type":"+","block":{"type":",","blocks":["publisher-name",{"type":"?","block":"publisher-loc"}]}}}},"publisher-loc":{"name":"publisher-loc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"publisher-loc","content":{"type":"*","block":{"type":"|","blocks":["TEXT","addr-line","city","country","fax","institution","institution-wrap","phone","postal-code","state","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"publisher-name":{"name":"publisher-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"publisher-name","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","institution","institution-wrap"]}}}},"rb":{"name":"rb","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"rb","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"ref":{"name":"ref","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"ref","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"+","block":{"type":"|","blocks":["citation-alternatives","element-citation","mixed-citation","nlm-citation","note","x"]}}]}}},"ref-count":{"name":"ref-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"ref-count","content":{"type":",","blocks":[]}}},"ref-list":{"name":"ref-list","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"ref-list","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x","ref"]}},{"type":"*","block":"ref-list"}]}}},"related-article":{"name":"related-article","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"related-article-type":{"name":"related-article-type"},"ext-link-type":{"name":"ext-link-type"},"vol":{"name":"vol"},"page":{"name":"page"},"issue":{"name":"issue"},"elocation-id":{"name":"elocation-id"},"journal-id":{"name":"journal-id"},"journal-id-type":{"name":"journal-id-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"related-article","content":{"type":"*","block":{"type":"|","blocks":["TEXT","inline-supplementary-material","related-article","related-object","hr","break","string-date","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","journal-id","label","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","annotation","article-title","chapter-title","collab","collab-alternatives","comment","conf-acronym","conf-date","conf-loc","conf-name","conf-sponsor","data-title","date","date-in-citation","day","edition","email","elocation-id","etal","ext-link","fpage","gov","institution","institution-wrap","isbn","issn","issn-l","issue","issue-id","issue-part","issue-title","lpage","month","name","name-alternatives","object-id","page-range","part-title","patent","person-group","pub-id","publisher-loc","publisher-name","role","season","series","size","source","std","string-name","supplement","trans-source","trans-title","uri","version","volume","volume-id","volume-series","year","fn","target","xref","sub","sup","x"]}}}},"related-object":{"name":"related-object","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"link-type":{"name":"link-type"},"ext-link-type":{"name":"ext-link-type"},"source-id":{"name":"source-id"},"source-id-type":{"name":"source-id-type"},"source-type":{"name":"source-type"},"document-id":{"name":"document-id"},"document-id-type":{"name":"document-id-type"},"document-type":{"name":"document-type"},"object-id":{"name":"object-id"},"object-id-type":{"name":"object-id-type"},"object-type":{"name":"object-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"related-object","content":{"type":"*","block":{"type":"|","blocks":["TEXT","inline-supplementary-material","related-article","related-object","hr","break","string-date","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","label","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","annotation","article-title","chapter-title","collab","collab-alternatives","comment","conf-acronym","conf-date","conf-loc","conf-name","conf-sponsor","data-title","date","date-in-citation","day","edition","email","elocation-id","etal","ext-link","fpage","gov","institution","institution-wrap","isbn","issn","issn-l","issue","issue-id","issue-part","issue-title","lpage","month","name","name-alternatives","object-id","page-range","part-title","patent","person-group","pub-id","publisher-loc","publisher-name","role","season","series","size","source","std","string-name","supplement","trans-source","trans-title","uri","version","volume","volume-id","volume-series","year","fn","target","xref","sub","sup","x"]}}}},"response":{"name":"response","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"response-type":{"name":"response-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"response","content":{"type":",","blocks":[{"type":"|","blocks":["front","front-stub"]},{"type":"?","block":"body"},{"type":"?","block":"back"},{"type":"?","block":"floats-group"}]}}},"role":{"name":"role","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"role","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"roman":{"name":"roman","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"roman","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"rp":{"name":"rp","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"rp","content":"TEXT"}},"rt":{"name":"rt","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"rt","content":"TEXT"}},"ruby":{"name":"ruby","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"ruby","content":{"type":",","blocks":["rb",{"type":"|","blocks":["rt",{"type":",","blocks":["rp","rt","rp"]}]}]}}},"sans-serif":{"name":"sans-serif","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sans-serif","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"sc":{"name":"sc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sc","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"season":{"name":"season","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"season","content":"TEXT"}},"sec":{"name":"sec","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"xml:lang":{"name":"xml:lang"},"sec-type":{"name":"sec-type"},"disp-level":{"name":"disp-level"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sec","content":{"type":",","blocks":[{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"sec-meta":{"name":"sec-meta","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"sec-meta","content":{"type":",","blocks":[{"type":"*","block":"contrib-group"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"?","block":"permissions"}]}}},"self-uri":{"name":"self-uri","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"self-uri","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"series":{"name":"series","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"series","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"series-text":{"name":"series-text","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"series-text","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"series-title":{"name":"series-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"series-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"sig":{"name":"sig","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"sig","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","graphic","media"]}}}},"sig-block":{"name":"sig-block","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sig-block","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","contrib","graphic","media","aff","aff-alternatives","etal","role","sig"]}}}},"size":{"name":"size","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"units":{"name":"units"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"size","content":{"type":"*","block":{"type":"|","blocks":["TEXT","x"]}}}},"source":{"name":"source","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"source","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"speaker":{"name":"speaker","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"speaker","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","degrees","given-names","prefix","surname","suffix"]}}}},"speech":{"name":"speech","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"speech","content":{"type":",","blocks":["speaker",{"type":"+","block":"p"}]}}},"state":{"name":"state","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"state","content":"TEXT"}},"statement":{"name":"statement","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"statement","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"+","block":{"type":"|","blocks":["p","statement"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"std":{"name":"std","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"std","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","named-content","styled-content","day","month","pub-id","source","std-organization","year","sub","sup"]}}}},"std-organization":{"name":"std-organization","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"std-organization","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","institution","institution-wrap","break"]}}}},"strike":{"name":"strike","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"strike","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"string-conf":{"name":"string-conf","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"string-conf","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","conf-date","conf-name","conf-num","conf-loc","conf-sponsor","conf-theme","conf-acronym","string-conf"]}}}},"string-date":{"name":"string-date","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"string-date","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","day","era","month","season","year"]}}}},"string-name":{"name":"string-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"name-style":{"name":"name-style"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"string-name","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","degrees","given-names","prefix","surname","suffix"]}}}},"styled-content":{"name":"styled-content","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"style":{"name":"style"},"style-type":{"name":"style-type"},"alt":{"name":"alt"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"styled-content","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","address","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","ack","disp-quote","speech","statement","verse-group"]}}}},"sub":{"name":"sub","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"arrange":{"name":"arrange"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sub","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"sub-article":{"name":"sub-article","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"article-type":{"name":"article-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"sub-article","content":{"type":",","blocks":[{"type":"|","blocks":["front","front-stub"]},{"type":"?","block":"body"},{"type":"?","block":"back"},{"type":"?","block":"floats-group"},{"type":"|","blocks":[{"type":"*","block":"sub-article"},{"type":"*","block":"response"}]}]}}},"subj-group":{"name":"subj-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"subj-group-type":{"name":"subj-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"subj-group","content":{"type":",","blocks":[{"type":"+","block":{"type":"|","blocks":["subject","compound-subject"]}},{"type":"*","block":"subj-group"}]}}},"subject":{"name":"subject","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"subject","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"subtitle":{"name":"subtitle","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"subtitle","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"suffix":{"name":"suffix","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"suffix","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"sup":{"name":"sup","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"arrange":{"name":"arrange"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sup","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"supplement":{"name":"supplement","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"supplement-type":{"name":"supplement-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"supplement","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","contrib-group","title"]}}}},"supplementary-material":{"name":"supplementary-material","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"},"mimetype":{"name":"mimetype"},"mime-subtype":{"name":"mime-subtype"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"supplementary-material","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"label"},{"type":"*","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"*","block":{"type":"|","blocks":["disp-formula","disp-formula-group","chem-struct-wrap","disp-quote","speech","statement","verse-group","table-wrap","p","def-list","list","alternatives","array","code","graphic","media","preformat"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"surname":{"name":"surname","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"initials":{"name":"initials"}},"elements":{"name":"surname","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"table":{"name":"table","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"summary":{"name":"summary"},"width":{"name":"width"},"border":{"name":"border"},"frame":{"name":"frame"},"rules":{"name":"rules"},"cellspacing":{"name":"cellspacing"},"cellpadding":{"name":"cellpadding"},"specific-use":{"name":"specific-use"}},"elements":{"name":"table","content":{"type":",","blocks":[{"type":"|","blocks":[{"type":"*","block":"col"},{"type":"*","block":"colgroup"}]},{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":"thead"},{"type":"?","block":"tfoot"},{"type":"+","block":"tbody"}]},{"type":"+","block":"tr"}]}]}}},"table-count":{"name":"table-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"table-count","content":{"type":",","blocks":[]}}},"table-wrap":{"name":"table-wrap","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"table-wrap","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"*","block":{"type":"|","blocks":["disp-quote","speech","statement","verse-group","def-list","list","alternatives","chem-struct-wrap","code","graphic","media","preformat","table","oasis:table"]}},{"type":"*","block":{"type":"|","blocks":["table-wrap-foot","attrib","permissions"]}}]}}},"table-wrap-foot":{"name":"table-wrap-foot","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"table-wrap-foot","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":{"type":"|","blocks":["p","fn-group","fn","attrib","permissions","x"]}}]}}},"table-wrap-group":{"name":"table-wrap-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"table-wrap-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":{"type":"|","blocks":["alt-text","long-desc","email","ext-link","uri"]}},{"type":"+","block":"table-wrap"}]}}},"target":{"name":"target","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"target-type":{"name":"target-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"target","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"tbody":{"name":"tbody","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tbody","content":{"type":"+","block":"tr"}}},"td":{"name":"td","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"abbr":{"name":"abbr"},"axis":{"name":"axis"},"headers":{"name":"headers"},"scope":{"name":"scope"},"rowspan":{"name":"rowspan"},"colspan":{"name":"colspan"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"td","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","disp-formula","disp-formula-group","break","chem-struct-wrap","citation-alternatives","element-citation","mixed-citation","nlm-citation","def-list","list","p","array","code","graphic","media","preformat"]}}}},"term":{"name":"term","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"term","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","disp-formula","disp-formula-group","chem-struct-wrap","array","code","graphic","media","preformat"]}}}},"term-head":{"name":"term-head","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"term-head","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"tex-math":{"name":"tex-math","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"notation":{"name":"notation"},"version":{"name":"version"}},"elements":{"name":"tex-math","content":"TEXT"}},"textual-form":{"name":"textual-form","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"textual-form","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","inline-graphic","private-char","label","tex-math","mml:math","named-content","styled-content","sub","sup"]}}}},"tfoot":{"name":"tfoot","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tfoot","content":{"type":"+","block":"tr"}}},"th":{"name":"th","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"abbr":{"name":"abbr"},"axis":{"name":"axis"},"headers":{"name":"headers"},"scope":{"name":"scope"},"rowspan":{"name":"rowspan"},"colspan":{"name":"colspan"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"th","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","disp-formula","disp-formula-group","break","chem-struct-wrap","citation-alternatives","element-citation","mixed-citation","nlm-citation","def-list","list","p","array","code","graphic","media","preformat"]}}}},"thead":{"name":"thead","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"thead","content":{"type":"+","block":"tr"}}},"time-stamp":{"name":"time-stamp","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"time-stamp","content":{"type":"*","block":{"type":"|","blocks":["TEXT","day","era","month","season","year","x"]}}}},"title":{"name":"title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break","citation-alternatives","element-citation","mixed-citation","nlm-citation"]}}}},"title-group":{"name":"title-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"title-group","content":{"type":",","blocks":["article-title",{"type":"*","block":"subtitle"},{"type":"*","block":"trans-title-group"},{"type":"*","block":"alt-title"},{"type":"?","block":"fn-group"}]}}},"tr":{"name":"tr","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tr","content":{"type":"+","block":{"type":"|","blocks":["th","td"]}}}},"trans-abstract":{"name":"trans-abstract","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"abstract-type":{"name":"abstract-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-abstract","content":{"type":",","blocks":[{"type":"*","block":"object-id"},{"type":"?","block":"sec-meta"},{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["address","alternatives","array","boxed-text","chem-struct-wrap","code","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","tex-math","mml:math","p","related-article","related-object","ack","disp-quote","speech","statement","verse-group","x"]}},{"type":"*","block":"sec"},{"type":"*","block":{"type":"|","blocks":["notes","fn-group","glossary","ref-list"]}}]}}},"trans-source":{"name":"trans-source","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-source","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"trans-subtitle":{"name":"trans-subtitle","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-subtitle","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"trans-title":{"name":"trans-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"trans-title-group":{"name":"trans-title-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-title-group","content":{"type":",","blocks":["trans-title",{"type":"*","block":"trans-subtitle"}]}}},"underline":{"name":"underline","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"underline-style":{"name":"underline-style"},"specific-use":{"name":"specific-use"}},"elements":{"name":"underline","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"underline-end":{"name":"underline-end","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"}},"elements":{"name":"underline-end","content":{"type":",","blocks":[]}}},"underline-start":{"name":"underline-start","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"}},"elements":{"name":"underline-start","content":{"type":",","blocks":[]}}},"unstructured-kwd-group":{"name":"unstructured-kwd-group","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"kwd-group-type":{"name":"kwd-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"unstructured-kwd-group","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"uri":{"name":"uri","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"uri","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"verse-group":{"name":"verse-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"verse-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"?","block":"subtitle"},{"type":"+","block":{"type":"|","blocks":["verse-line","verse-group"]}},{"type":"*","block":{"type":"|","blocks":["attrib","permissions"]}}]}}},"verse-line":{"name":"verse-line","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"verse-line","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"version":{"name":"version","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"designator":{"name":"designator"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"version","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"volume":{"name":"volume","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"seq":{"name":"seq"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"volume","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"volume-id":{"name":"volume-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"volume-id","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"volume-issue-group":{"name":"volume-issue-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"volume-issue-group","content":{"type":",","blocks":[{"type":"*","block":"volume"},{"type":"*","block":"volume-id"},{"type":"?","block":"volume-series"},{"type":"*","block":"issue"},{"type":"*","block":"issue-id"},{"type":"*","block":"issue-title"},{"type":"*","block":"issue-sponsor"},{"type":"?","block":"issue-part"}]}}},"volume-series":{"name":"volume-series","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"volume-series","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x"]}}}},"word-count":{"name":"word-count","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"count":{"name":"count"}},"elements":{"name":"word-count","content":{"type":",","blocks":[]}}},"x":{"name":"x","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"xml:space":{"name":"xml:space"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"x","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","named-content","styled-content","sub","sup","x"]}}}},"xref":{"name":"xref","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"ref-type":{"name":"ref-type"},"alt":{"name":"alt"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"xref","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","inline-supplementary-material","related-article","related-object","hr","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","tex-math","mml:math","abbrev","milestone-end","milestone-start","named-content","styled-content","fn","target","xref","sub","sup","x","break"]}}}},"year":{"name":"year","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"year","content":"TEXT"}}}}

  const DOC_TYPE_PARAMS = [
    'article',
    '-//NLM//DTD JATS (Z39.96) Journal Archiving DTD v1.0 20120330//EN',
    'JATS-journalarchiving.dtd'
  ];

  var JATS = createSchema(JATSArchivingData, 'jats', '1.1', DOC_TYPE_PARAMS)

  var TextureArticleData = {"start":"article","elements":{"abbrev":{"name":"abbrev","type":"not-implemented","attributes":{},"elements":{"name":"abbrev","content":{"type":",","blocks":[]}}},"abbrev-journal-title":{"name":"abbrev-journal-title","type":"not-implemented","attributes":{},"elements":{"name":"abbrev-journal-title","content":{"type":",","blocks":[]}}},"abstract":{"name":"abstract","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"abstract-type":{"name":"abstract-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"abstract","content":{"type":"*","block":"p"}}},"ack":{"name":"ack","type":"not-implemented","attributes":{},"elements":{"name":"ack","content":{"type":",","blocks":[]}}},"addr-line":{"name":"addr-line","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"addr-line","content":"TEXT"}},"address":{"name":"address","type":"not-implemented","attributes":{},"elements":{"name":"address","content":{"type":",","blocks":[]}}},"aff":{"name":"aff","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"aff","content":{"type":"~","blocks":[{"type":"*","block":"addr-line"},{"type":"?","block":"label"},{"type":"?","block":"city"},{"type":"?","block":"country"},{"type":"?","block":"fax"},{"type":"*","block":"institution"},{"type":"*","block":"institution-wrap"},{"type":"?","block":"phone"},{"type":"?","block":"postal-code"},{"type":"?","block":"state"},{"type":"?","block":"email"},{"type":"*","block":"ext-link"},{"type":"?","block":"uri"}]}}},"aff-alternatives":{"name":"aff-alternatives","type":"not-implemented","attributes":{},"elements":{"name":"aff-alternatives","content":{"type":",","blocks":[]}}},"ali:free_to_read":{"name":"ali:free_to_read","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"end_date":{"name":"end_date"},"start_date":{"name":"start_date"}},"elements":{"name":"ali:free_to_read","content":{"type":",","blocks":[]}}},"ali:license_ref":{"name":"ali:license_ref","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"start_date":{"name":"start_date"}},"elements":{"name":"ali:license_ref","content":"TEXT"}},"alt-text":{"name":"alt-text","type":"not-implemented","attributes":{},"elements":{"name":"alt-text","content":{"type":",","blocks":[]}}},"alt-title":{"name":"alt-title","type":"not-implemented","attributes":{},"elements":{"name":"alt-title","content":{"type":",","blocks":[]}}},"alternatives":{"name":"alternatives","type":"not-implemented","attributes":{},"elements":{"name":"alternatives","content":{"type":",","blocks":[]}}},"annotation":{"name":"annotation","type":"not-implemented","attributes":{},"elements":{"name":"annotation","content":{"type":",","blocks":[]}}},"anonymous":{"name":"anonymous","type":"not-implemented","attributes":{},"elements":{"name":"anonymous","content":{"type":",","blocks":[]}}},"app":{"name":"app","type":"not-implemented","attributes":{},"elements":{"name":"app","content":{"type":",","blocks":[]}}},"app-group":{"name":"app-group","type":"not-implemented","attributes":{},"elements":{"name":"app-group","content":{"type":",","blocks":[]}}},"array":{"name":"array","type":"not-implemented","attributes":{},"elements":{"name":"array","content":{"type":",","blocks":[]}}},"article":{"name":"article","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"article-type":{"name":"article-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"dtd-version":{"name":"dtd-version"}},"elements":{"name":"article","content":{"type":",","blocks":["front",{"type":"?","block":"body"},{"type":"?","block":"back"}]}}},"article-categories":{"name":"article-categories","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"article-categories","content":{"type":"*","block":"subj-group"}}},"article-id":{"name":"article-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"article-id","content":"TEXT"}},"article-meta":{"name":"article-meta","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"article-meta","content":{"type":",","blocks":[{"type":"*","block":"article-id"},{"type":"?","block":"article-categories"},{"type":"?","block":"title-group"},{"type":"*","block":"contrib-group"},{"type":"*","block":"aff"},{"type":"*","block":"pub-date"},{"type":"?","block":"volume"},{"type":"?","block":"issue"},{"type":"?","block":"issue-title"},{"type":"?","block":"isbn"},{"type":"?","block":{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":{"type":",","blocks":["fpage",{"type":"?","block":"lpage"}]}},{"type":"?","block":"page-range"}]},"elocation-id"]}},{"type":"?","block":"history"},{"type":"?","block":"permissions"},{"type":"?","block":"abstract"},{"type":"*","block":"trans-abstract"},{"type":"*","block":"kwd-group"},{"type":"*","block":"funding-group"}]}}},"article-title":{"name":"article-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"article-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"attrib":{"name":"attrib","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"attrib","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"author-comment":{"name":"author-comment","type":"not-implemented","attributes":{},"elements":{"name":"author-comment","content":{"type":",","blocks":[]}}},"author-notes":{"name":"author-notes","type":"not-implemented","attributes":{},"elements":{"name":"author-notes","content":{"type":",","blocks":[]}}},"award-group":{"name":"award-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"award-type":{"name":"award-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"award-group","content":{"type":",","blocks":[{"type":"*","block":"funding-source"},{"type":"*","block":"award-id"},{"type":"*","block":"principal-award-recipient"},{"type":"*","block":"principal-investigator"}]}}},"award-id":{"name":"award-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"award-type":{"name":"award-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"award-id","content":"TEXT"}},"back":{"name":"back","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"back","content":{"type":"~","blocks":[{"type":"?","block":"fn-group"},{"type":"?","block":"ref-list"}]}}},"bio":{"name":"bio","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"bio","content":{"type":"*","block":"p"}}},"body":{"name":"body","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"}},"elements":{"name":"body","content":{"type":"*","block":{"type":"|","blocks":["sec","boxed-text","chem-struct-wrap","fig","fig-group","table-wrap","disp-formula","disp-formula-group","def-list","list","p","preformat","disp-quote","supplementary-material","disp-formula","disp-formula-group","def-list","list","p","ack","disp-quote","speech","statement","verse-group"]}}}},"bold":{"name":"bold","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"bold","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"boxed-text":{"name":"boxed-text","type":"not-implemented","attributes":{},"elements":{"name":"boxed-text","content":{"type":",","blocks":[]}}},"break":{"name":"break","type":"inline-element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"break","content":{"type":",","blocks":[]}}},"caption":{"name":"caption","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"style":{"name":"style"}},"elements":{"name":"caption","content":{"type":",","blocks":[{"type":"?","block":"title"},{"type":"*","block":"p"}]}}},"chapter-title":{"name":"chapter-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"chapter-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"chem-struct":{"name":"chem-struct","type":"not-implemented","attributes":{},"elements":{"name":"chem-struct","content":{"type":",","blocks":[]}}},"chem-struct-wrap":{"name":"chem-struct-wrap","type":"not-implemented","attributes":{},"elements":{"name":"chem-struct-wrap","content":{"type":",","blocks":[]}}},"citation-alternatives":{"name":"citation-alternatives","type":"not-implemented","attributes":{},"elements":{"name":"citation-alternatives","content":{"type":",","blocks":[]}}},"city":{"name":"city","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"city","content":"TEXT"}},"col":{"name":"col","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"span":{"name":"span"},"width":{"name":"width"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"col","content":{"type":",","blocks":[]}}},"colgroup":{"name":"colgroup","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"span":{"name":"span"},"width":{"name":"width"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"colgroup","content":{"type":"*","block":"col"}}},"collab":{"name":"collab","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"collab-type":{"name":"collab-type"},"symbol":{"name":"symbol"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"collab","content":{"type":"~","blocks":[{"type":"?","block":"email"},"named-content",{"type":"?","block":"contrib-group"},{"type":"*","block":"xref"}]}}},"collab-alternatives":{"name":"collab-alternatives","type":"not-implemented","attributes":{},"elements":{"name":"collab-alternatives","content":{"type":",","blocks":[]}}},"comment":{"name":"comment","type":"not-implemented","attributes":{},"elements":{"name":"comment","content":{"type":",","blocks":[]}}},"compound-kwd":{"name":"compound-kwd","type":"not-implemented","attributes":{},"elements":{"name":"compound-kwd","content":{"type":",","blocks":[]}}},"compound-kwd-part":{"name":"compound-kwd-part","type":"not-implemented","attributes":{},"elements":{"name":"compound-kwd-part","content":{"type":",","blocks":[]}}},"compound-subject":{"name":"compound-subject","type":"not-implemented","attributes":{},"elements":{"name":"compound-subject","content":{"type":",","blocks":[]}}},"compound-subject-part":{"name":"compound-subject-part","type":"not-implemented","attributes":{},"elements":{"name":"compound-subject-part","content":{"type":",","blocks":[]}}},"conf-acronym":{"name":"conf-acronym","type":"not-implemented","attributes":{},"elements":{"name":"conf-acronym","content":{"type":",","blocks":[]}}},"conf-date":{"name":"conf-date","type":"not-implemented","attributes":{},"elements":{"name":"conf-date","content":{"type":",","blocks":[]}}},"conf-loc":{"name":"conf-loc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-loc","content":"TEXT"}},"conf-name":{"name":"conf-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"conf-name","content":"TEXT"}},"conf-num":{"name":"conf-num","type":"not-implemented","attributes":{},"elements":{"name":"conf-num","content":{"type":",","blocks":[]}}},"conf-sponsor":{"name":"conf-sponsor","type":"not-implemented","attributes":{},"elements":{"name":"conf-sponsor","content":{"type":",","blocks":[]}}},"conf-theme":{"name":"conf-theme","type":"not-implemented","attributes":{},"elements":{"name":"conf-theme","content":{"type":",","blocks":[]}}},"conference":{"name":"conference","type":"not-implemented","attributes":{},"elements":{"name":"conference","content":{"type":",","blocks":[]}}},"contrib":{"name":"contrib","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"contrib-type":{"name":"contrib-type"},"corresp":{"name":"corresp"},"equal-contrib":{"name":"equal-contrib"},"deceased":{"name":"deceased"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"contrib","content":{"type":"~","blocks":[{"type":"*","block":"contrib-id"},{"type":"?","block":"name"},{"type":"?","block":"email"},{"type":"?","block":"string-name"},{"type":"?","block":"bio"},{"type":"?","block":"collab"},{"type":"?","block":"role"},{"type":"*","block":"xref"}]}}},"contrib-group":{"name":"contrib-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"contrib-group","content":{"type":"*","block":"contrib"}}},"contrib-id":{"name":"contrib-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"contrib-id-type":{"name":"contrib-id-type"},"authenticated":{"name":"authenticated"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"contrib-id","content":"TEXT"}},"copyright-holder":{"name":"copyright-holder","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"copyright-holder","content":"TEXT"}},"copyright-statement":{"name":"copyright-statement","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"copyright-statement","content":"TEXT"}},"copyright-year":{"name":"copyright-year","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"copyright-year","content":"TEXT"}},"corresp":{"name":"corresp","type":"not-implemented","attributes":{},"elements":{"name":"corresp","content":{"type":",","blocks":[]}}},"count":{"name":"count","type":"not-implemented","attributes":{},"elements":{"name":"count","content":{"type":",","blocks":[]}}},"country":{"name":"country","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"country","content":"TEXT"}},"counts":{"name":"counts","type":"not-implemented","attributes":{},"elements":{"name":"counts","content":{"type":",","blocks":[]}}},"custom-meta":{"name":"custom-meta","type":"not-implemented","attributes":{},"elements":{"name":"custom-meta","content":{"type":",","blocks":[]}}},"custom-meta-group":{"name":"custom-meta-group","type":"not-implemented","attributes":{},"elements":{"name":"custom-meta-group","content":{"type":",","blocks":[]}}},"data-title":{"name":"data-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"data-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","email","ext-link","uri","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","named-content","styled-content","sub","sup"]}}}},"date":{"name":"date","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"date-type":{"name":"date-type"},"publication-format":{"name":"publication-format"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"specific-use":{"name":"specific-use"}},"elements":{"name":"date","content":{"type":",","blocks":[{"type":"?","block":{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":"day"},{"type":"?","block":"month"}]},"season"]}},{"type":"?","block":"year"},{"type":"?","block":"era"},{"type":"?","block":"string-date"}]}}},"date-in-citation":{"name":"date-in-citation","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"date-in-citation","content":"TEXT"}},"day":{"name":"day","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"day","content":"TEXT"}},"def":{"name":"def","type":"not-implemented","attributes":{},"elements":{"name":"def","content":{"type":",","blocks":[]}}},"def-head":{"name":"def-head","type":"not-implemented","attributes":{},"elements":{"name":"def-head","content":{"type":",","blocks":[]}}},"def-item":{"name":"def-item","type":"not-implemented","attributes":{},"elements":{"name":"def-item","content":{"type":",","blocks":[]}}},"def-list":{"name":"def-list","type":"not-implemented","attributes":{},"elements":{"name":"def-list","content":{"type":",","blocks":[]}}},"degrees":{"name":"degrees","type":"not-implemented","attributes":{},"elements":{"name":"degrees","content":{"type":",","blocks":[]}}},"disp-formula":{"name":"disp-formula","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"disp-formula","content":{"type":",","blocks":[{"type":"?","block":"label"},"tex-math"]}}},"disp-formula-group":{"name":"disp-formula-group","type":"not-implemented","attributes":{},"elements":{"name":"disp-formula-group","content":{"type":",","blocks":[]}}},"disp-quote":{"name":"disp-quote","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"disp-quote","content":{"type":",","blocks":[{"type":"+","block":"p"},{"type":"?","block":"attrib"}]}}},"edition":{"name":"edition","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"designator":{"name":"designator"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"edition","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"element-citation":{"name":"element-citation","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-type":{"name":"publication-type"},"publisher-type":{"name":"publisher-type"},"publication-format":{"name":"publication-format"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"element-citation","content":{"type":"~","blocks":[{"type":"?","block":"article-title"},{"type":"?","block":"chapter-title"},{"type":"?","block":"comment"},{"type":"?","block":"collab"},{"type":"?","block":"edition"},{"type":"?","block":"elocation-id"},{"type":"?","block":"fpage"},{"type":"?","block":"issue"},{"type":"?","block":"lpage"},{"type":"?","block":"page-range"},{"type":"*","block":"person-group"},{"type":"*","block":"pub-id"},{"type":"*","block":"publisher-loc"},{"type":"*","block":"publisher-name"},{"type":"?","block":"source"},{"type":"?","block":"volume"},{"type":"?","block":"year"},{"type":"?","block":"month"},{"type":"?","block":"day"},{"type":"?","block":"conf-name"},{"type":"?","block":"conf-loc"},{"type":"?","block":"data-title"},{"type":"?","block":"part-title"},{"type":"?","block":"patent"},{"type":"?","block":"series"},{"type":"?","block":"version"},{"type":"?","block":"uri"},{"type":"?","block":"date-in-citation"}]}}},"elocation-id":{"name":"elocation-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"}},"elements":{"name":"elocation-id","content":"TEXT"}},"email":{"name":"email","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"email","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"equation-count":{"name":"equation-count","type":"not-implemented","attributes":{},"elements":{"name":"equation-count","content":{"type":",","blocks":[]}}},"era":{"name":"era","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"era","content":"TEXT"}},"etal":{"name":"etal","type":"not-implemented","attributes":{},"elements":{"name":"etal","content":{"type":",","blocks":[]}}},"ext-link":{"name":"ext-link","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"ext-link-type":{"name":"ext-link-type"},"assigning-authority":{"name":"assigning-authority"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"ext-link","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"fax":{"name":"fax","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"fax","content":"TEXT"}},"fig":{"name":"fig","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"fig-type":{"name":"fig-type"}},"elements":{"name":"fig","content":{"type":",","blocks":[{"type":"?","block":"object-id"},{"type":"?","block":"label"},{"type":"?","block":"caption"},{"type":"*","block":"kwd-group"},"graphic",{"type":"?","block":"permissions"}]}}},"fig-count":{"name":"fig-count","type":"not-implemented","attributes":{},"elements":{"name":"fig-count","content":{"type":",","blocks":[]}}},"fig-group":{"name":"fig-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"fig-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"+","block":"fig"}]}}},"fixed-case":{"name":"fixed-case","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"fixed-case","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"floats-group":{"name":"floats-group","type":"not-implemented","attributes":{},"elements":{"name":"floats-group","content":{"type":",","blocks":[]}}},"fn":{"name":"fn","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"symbol":{"name":"symbol"},"fn-type":{"name":"fn-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fn","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"+","block":"p"}]}}},"fn-group":{"name":"fn-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fn-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"title"},{"type":"+","block":"fn"}]}}},"fpage":{"name":"fpage","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"fpage","content":"TEXT"}},"front":{"name":"front","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"front","content":{"type":",","blocks":[{"type":"?","block":"journal-meta"},"article-meta"]}}},"front-stub":{"name":"front-stub","type":"not-implemented","attributes":{},"elements":{"name":"front-stub","content":{"type":",","blocks":[]}}},"funding-group":{"name":"funding-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"funding-group","content":{"type":"*","block":"award-group"}}},"funding-source":{"name":"funding-source","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"source-type":{"name":"source-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"funding-source","content":"institution-wrap"}},"funding-statement":{"name":"funding-statement","type":"not-implemented","attributes":{},"elements":{"name":"funding-statement","content":{"type":",","blocks":[]}}},"given-names":{"name":"given-names","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"initials":{"name":"initials"}},"elements":{"name":"given-names","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"glossary":{"name":"glossary","type":"not-implemented","attributes":{},"elements":{"name":"glossary","content":{"type":",","blocks":[]}}},"glyph-data":{"name":"glyph-data","type":"not-implemented","attributes":{},"elements":{"name":"glyph-data","content":{"type":",","blocks":[]}}},"glyph-ref":{"name":"glyph-ref","type":"not-implemented","attributes":{},"elements":{"name":"glyph-ref","content":{"type":",","blocks":[]}}},"gov":{"name":"gov","type":"not-implemented","attributes":{},"elements":{"name":"gov","content":{"type":",","blocks":[]}}},"graphic":{"name":"graphic","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"},"mime-subtype":{"name":"mime-subtype"},"mimetype":{"name":"mimetype"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"graphic","content":{"type":",","blocks":[]}}},"history":{"name":"history","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"history","content":{"type":"*","block":"date"}}},"hr":{"name":"hr","type":"not-implemented","attributes":{},"elements":{"name":"hr","content":{"type":",","blocks":[]}}},"inline-formula":{"name":"inline-formula","type":"inline-element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"inline-formula","content":"tex-math"}},"inline-graphic":{"name":"inline-graphic","type":"inline-element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"baseline-shift":{"name":"baseline-shift"},"mimetype":{"name":"mimetype"},"mime-subtype":{"name":"mime-subtype"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"inline-graphic","content":{"type":"?","block":"alt-text"}}},"inline-supplementary-material":{"name":"inline-supplementary-material","type":"not-implemented","attributes":{},"elements":{"name":"inline-supplementary-material","content":{"type":",","blocks":[]}}},"institution":{"name":"institution","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"institution","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"institution-id":{"name":"institution-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"institution-id-type":{"name":"institution-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"institution-id","content":"TEXT"}},"institution-wrap":{"name":"institution-wrap","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"institution-wrap","content":{"type":"*","block":{"type":"|","blocks":["institution","institution-id"]}}}},"isbn":{"name":"isbn","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"publication-format":{"name":"publication-format"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"isbn","content":"TEXT"}},"issn":{"name":"issn","type":"not-implemented","attributes":{},"elements":{"name":"issn","content":{"type":",","blocks":[]}}},"issn-l":{"name":"issn-l","type":"not-implemented","attributes":{},"elements":{"name":"issn-l","content":{"type":",","blocks":[]}}},"issue":{"name":"issue","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"seq":{"name":"seq"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue","content":"TEXT"}},"issue-id":{"name":"issue-id","type":"not-implemented","attributes":{},"elements":{"name":"issue-id","content":{"type":",","blocks":[]}}},"issue-part":{"name":"issue-part","type":"not-implemented","attributes":{},"elements":{"name":"issue-part","content":{"type":",","blocks":[]}}},"issue-sponsor":{"name":"issue-sponsor","type":"not-implemented","attributes":{},"elements":{"name":"issue-sponsor","content":{"type":",","blocks":[]}}},"issue-title":{"name":"issue-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"issue-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"italic":{"name":"italic","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"italic","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"journal-id":{"name":"journal-id","type":"not-implemented","attributes":{},"elements":{"name":"journal-id","content":{"type":",","blocks":[]}}},"journal-meta":{"name":"journal-meta","type":"not-implemented","attributes":{},"elements":{"name":"journal-meta","content":{"type":",","blocks":[]}}},"journal-subtitle":{"name":"journal-subtitle","type":"not-implemented","attributes":{},"elements":{"name":"journal-subtitle","content":{"type":",","blocks":[]}}},"journal-title":{"name":"journal-title","type":"not-implemented","attributes":{},"elements":{"name":"journal-title","content":{"type":",","blocks":[]}}},"journal-title-group":{"name":"journal-title-group","type":"not-implemented","attributes":{},"elements":{"name":"journal-title-group","content":{"type":",","blocks":[]}}},"kwd":{"name":"kwd","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"kwd","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"kwd-group":{"name":"kwd-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"kwd-group-type":{"name":"kwd-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"kwd-group","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"*","block":"kwd"}]}}},"label":{"name":"label","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"alt":{"name":"alt"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"label","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"license":{"name":"license","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"license-type":{"name":"license-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"license","content":{"type":"~","blocks":[{"type":"?","block":"ali:license_ref"},{"type":"?","block":"license-p"}]}}},"license-p":{"name":"license-p","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"license-p","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","chem-struct","inline-formula","inline-graphic","private-char","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","supplementary-material","price"]}}}},"list":{"name":"list","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"list-type":{"name":"list-type"},"prefix-word":{"name":"prefix-word"},"list-content":{"name":"list-content"},"continued-from":{"name":"continued-from"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"list","content":{"type":"+","block":"list-item"}}},"list-item":{"name":"list-item","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"list-item","content":{"type":"+","block":{"type":"|","blocks":["p","list"]}}}},"long-desc":{"name":"long-desc","type":"not-implemented","attributes":{},"elements":{"name":"long-desc","content":{"type":",","blocks":[]}}},"lpage":{"name":"lpage","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"lpage","content":"TEXT"}},"media":{"name":"media","type":"not-implemented","attributes":{},"elements":{"name":"media","content":{"type":",","blocks":[]}}},"meta-name":{"name":"meta-name","type":"not-implemented","attributes":{},"elements":{"name":"meta-name","content":{"type":",","blocks":[]}}},"meta-value":{"name":"meta-value","type":"not-implemented","attributes":{},"elements":{"name":"meta-value","content":{"type":",","blocks":[]}}},"milestone-end":{"name":"milestone-end","type":"not-implemented","attributes":{},"elements":{"name":"milestone-end","content":{"type":",","blocks":[]}}},"milestone-start":{"name":"milestone-start","type":"not-implemented","attributes":{},"elements":{"name":"milestone-start","content":{"type":",","blocks":[]}}},"mixed-citation":{"name":"mixed-citation","type":"not-implemented","attributes":{},"elements":{"name":"mixed-citation","content":{"type":",","blocks":[]}}},"monospace":{"name":"monospace","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"monospace","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"month":{"name":"month","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"month","content":"TEXT"}},"name":{"name":"name","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"name-style":{"name":"name-style"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"name","content":{"type":",","blocks":[{"type":"|","blocks":[{"type":",","blocks":["surname",{"type":"?","block":"given-names"}]},"given-names"]},{"type":"?","block":"prefix"},{"type":"?","block":"suffix"}]}}},"name-alternatives":{"name":"name-alternatives","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"name-alternatives","content":{"type":"+","block":{"type":"|","blocks":["name","string-name"]}}}},"named-content":{"name":"named-content","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"rid":{"name":"rid"},"alt":{"name":"alt"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"named-content","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","address","array","boxed-text","chem-struct-wrap","fig","fig-group","graphic","media","preformat","supplementary-material","table-wrap","table-wrap-group","disp-formula","disp-formula-group","def-list","list","ack","disp-quote","speech","statement","verse-group"]}}}},"nested-kwd":{"name":"nested-kwd","type":"not-implemented","attributes":{},"elements":{"name":"nested-kwd","content":{"type":",","blocks":[]}}},"note":{"name":"note","type":"not-implemented","attributes":{},"elements":{"name":"note","content":{"type":",","blocks":[]}}},"notes":{"name":"notes","type":"not-implemented","attributes":{},"elements":{"name":"notes","content":{"type":",","blocks":[]}}},"object-id":{"name":"object-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"object-id","content":"TEXT"}},"on-behalf-of":{"name":"on-behalf-of","type":"not-implemented","attributes":{},"elements":{"name":"on-behalf-of","content":{"type":",","blocks":[]}}},"open-access":{"name":"open-access","type":"not-implemented","attributes":{},"elements":{"name":"open-access","content":{"type":",","blocks":[]}}},"overline":{"name":"overline","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"overline","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"overline-end":{"name":"overline-end","type":"not-implemented","attributes":{},"elements":{"name":"overline-end","content":{"type":",","blocks":[]}}},"overline-start":{"name":"overline-start","type":"not-implemented","attributes":{},"elements":{"name":"overline-start","content":{"type":",","blocks":[]}}},"p":{"name":"p","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"p","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","chem-struct","inline-formula","inline-graphic","private-char","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","supplementary-material"]}}}},"page-count":{"name":"page-count","type":"not-implemented","attributes":{},"elements":{"name":"page-count","content":{"type":",","blocks":[]}}},"page-range":{"name":"page-range","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"page-range","content":"TEXT"}},"part-title":{"name":"part-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"part-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"patent":{"name":"patent","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"country":{"name":"country"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"patent","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"permissions":{"name":"permissions","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"permissions","content":{"type":",","blocks":[{"type":"*","block":"copyright-statement"},{"type":"*","block":"copyright-year"},{"type":"*","block":"copyright-holder"},{"type":"*","block":{"type":"|","blocks":["ali:free_to_read","license"]}}]}}},"person-group":{"name":"person-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"person-group-type":{"name":"person-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"person-group","content":{"type":"*","block":{"type":"|","blocks":["anonymous","collab","collab-alternatives","name","name-alternatives","string-name","aff","aff-alternatives","etal","role"]}}}},"phone":{"name":"phone","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"phone","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"postal-code":{"name":"postal-code","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"postal-code","content":"TEXT"}},"prefix":{"name":"prefix","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"prefix","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"preformat":{"name":"preformat","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"preformat-type":{"name":"preformat-type"},"xml:space":{"name":"xml:space"}},"elements":{"name":"preformat","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","abbrev","milestone-end","milestone-start","named-content","styled-content","sub","sup"]}}}},"price":{"name":"price","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"currency":{"name":"currency"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"price","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby"]}}}},"principal-award-recipient":{"name":"principal-award-recipient","type":"not-implemented","attributes":{},"elements":{"name":"principal-award-recipient","content":{"type":",","blocks":[]}}},"principal-investigator":{"name":"principal-investigator","type":"not-implemented","attributes":{},"elements":{"name":"principal-investigator","content":{"type":",","blocks":[]}}},"private-char":{"name":"private-char","type":"not-implemented","attributes":{},"elements":{"name":"private-char","content":{"type":",","blocks":[]}}},"product":{"name":"product","type":"not-implemented","attributes":{},"elements":{"name":"product","content":{"type":",","blocks":[]}}},"pub-date":{"name":"pub-date","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-type":{"name":"pub-type"},"publication-format":{"name":"publication-format"},"date-type":{"name":"date-type"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"pub-date","content":{"type":"*","block":{"type":"|","blocks":["day","era","month","season","year","string-date"]}}}},"pub-id":{"name":"pub-id","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"pub-id-type":{"name":"pub-id-type"},"assigning-authority":{"name":"assigning-authority"},"specific-use":{"name":"specific-use"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"pub-id","content":"TEXT"}},"publisher":{"name":"publisher","type":"not-implemented","attributes":{},"elements":{"name":"publisher","content":{"type":",","blocks":[]}}},"publisher-loc":{"name":"publisher-loc","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"publisher-loc","content":"TEXT"}},"publisher-name":{"name":"publisher-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"publisher-name","content":"TEXT"}},"rb":{"name":"rb","type":"not-implemented","attributes":{},"elements":{"name":"rb","content":{"type":",","blocks":[]}}},"ref":{"name":"ref","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"ref","content":"element-citation"}},"ref-count":{"name":"ref-count","type":"not-implemented","attributes":{},"elements":{"name":"ref-count","content":{"type":",","blocks":[]}}},"ref-list":{"name":"ref-list","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"ref-list","content":{"type":"*","block":"ref"}}},"related-article":{"name":"related-article","type":"not-implemented","attributes":{},"elements":{"name":"related-article","content":{"type":",","blocks":[]}}},"related-object":{"name":"related-object","type":"not-implemented","attributes":{},"elements":{"name":"related-object","content":{"type":",","blocks":[]}}},"response":{"name":"response","type":"not-implemented","attributes":{},"elements":{"name":"response","content":{"type":",","blocks":[]}}},"role":{"name":"role","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"role","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"roman":{"name":"roman","type":"not-implemented","attributes":{},"elements":{"name":"roman","content":{"type":",","blocks":[]}}},"rp":{"name":"rp","type":"not-implemented","attributes":{},"elements":{"name":"rp","content":{"type":",","blocks":[]}}},"rt":{"name":"rt","type":"not-implemented","attributes":{},"elements":{"name":"rt","content":{"type":",","blocks":[]}}},"ruby":{"name":"ruby","type":"not-implemented","attributes":{},"elements":{"name":"ruby","content":{"type":",","blocks":[]}}},"sans-serif":{"name":"sans-serif","type":"not-implemented","attributes":{},"elements":{"name":"sans-serif","content":{"type":",","blocks":[]}}},"sc":{"name":"sc","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sc","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"season":{"name":"season","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"season","content":"TEXT"}},"sec":{"name":"sec","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"xml:lang":{"name":"xml:lang"},"sec-type":{"name":"sec-type"},"disp-level":{"name":"disp-level"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sec","content":{"type":",","blocks":[{"type":"?","block":"title"},{"type":"*","block":{"type":"|","blocks":["boxed-text","chem-struct-wrap","fig","fig-group","table-wrap","disp-formula","disp-formula-group","def-list","list","p","preformat","disp-quote","supplementary-material","disp-formula","disp-formula-group","def-list","list","p","ack","disp-quote","speech","statement","verse-group"]}},{"type":"*","block":"sec"}]}}},"sec-meta":{"name":"sec-meta","type":"not-implemented","attributes":{},"elements":{"name":"sec-meta","content":{"type":",","blocks":[]}}},"self-uri":{"name":"self-uri","type":"not-implemented","attributes":{},"elements":{"name":"self-uri","content":{"type":",","blocks":[]}}},"series":{"name":"series","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"series","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"series-text":{"name":"series-text","type":"not-implemented","attributes":{},"elements":{"name":"series-text","content":{"type":",","blocks":[]}}},"series-title":{"name":"series-title","type":"not-implemented","attributes":{},"elements":{"name":"series-title","content":{"type":",","blocks":[]}}},"sig":{"name":"sig","type":"not-implemented","attributes":{},"elements":{"name":"sig","content":{"type":",","blocks":[]}}},"sig-block":{"name":"sig-block","type":"not-implemented","attributes":{},"elements":{"name":"sig-block","content":{"type":",","blocks":[]}}},"size":{"name":"size","type":"not-implemented","attributes":{},"elements":{"name":"size","content":{"type":",","blocks":[]}}},"source":{"name":"source","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"source","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"speaker":{"name":"speaker","type":"not-implemented","attributes":{},"elements":{"name":"speaker","content":{"type":",","blocks":[]}}},"speech":{"name":"speech","type":"not-implemented","attributes":{},"elements":{"name":"speech","content":{"type":",","blocks":[]}}},"state":{"name":"state","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"state","content":"TEXT"}},"statement":{"name":"statement","type":"not-implemented","attributes":{},"elements":{"name":"statement","content":{"type":",","blocks":[]}}},"std":{"name":"std","type":"not-implemented","attributes":{},"elements":{"name":"std","content":{"type":",","blocks":[]}}},"std-organization":{"name":"std-organization","type":"not-implemented","attributes":{},"elements":{"name":"std-organization","content":{"type":",","blocks":[]}}},"strike":{"name":"strike","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"specific-use":{"name":"specific-use"}},"elements":{"name":"strike","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"string-conf":{"name":"string-conf","type":"not-implemented","attributes":{},"elements":{"name":"string-conf","content":{"type":",","blocks":[]}}},"string-date":{"name":"string-date","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"iso-8601-date":{"name":"iso-8601-date"},"calendar":{"name":"calendar"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"string-date","content":"TEXT"}},"string-name":{"name":"string-name","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"name-style":{"name":"name-style"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"string-name","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"styled-content":{"name":"styled-content","type":"not-implemented","attributes":{},"elements":{"name":"styled-content","content":{"type":",","blocks":[]}}},"sub":{"name":"sub","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"arrange":{"name":"arrange"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sub","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"sub-article":{"name":"sub-article","type":"not-implemented","attributes":{},"elements":{"name":"sub-article","content":{"type":",","blocks":[]}}},"subj-group":{"name":"subj-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"subj-group-type":{"name":"subj-group-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"subj-group","content":{"type":",","blocks":[{"type":"+","block":{"type":"|","blocks":["subject","compound-subject"]}},{"type":"*","block":"subj-group"}]}}},"subject":{"name":"subject","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"}},"elements":{"name":"subject","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"subtitle":{"name":"subtitle","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"subtitle","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"suffix":{"name":"suffix","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"suffix","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"sup":{"name":"sup","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"arrange":{"name":"arrange"},"specific-use":{"name":"specific-use"}},"elements":{"name":"sup","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"supplement":{"name":"supplement","type":"not-implemented","attributes":{},"elements":{"name":"supplement","content":{"type":",","blocks":[]}}},"supplementary-material":{"name":"supplementary-material","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"},"mimetype":{"name":"mimetype"},"mime-subtype":{"name":"mime-subtype"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"supplementary-material","content":{"type":",","blocks":[{"type":"?","block":"label"},{"type":"?","block":"caption"}]}}},"surname":{"name":"surname","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"initials":{"name":"initials"}},"elements":{"name":"surname","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"table":{"name":"table","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"summary":{"name":"summary"},"width":{"name":"width"},"border":{"name":"border"},"frame":{"name":"frame"},"rules":{"name":"rules"},"cellspacing":{"name":"cellspacing"},"cellpadding":{"name":"cellpadding"},"specific-use":{"name":"specific-use"}},"elements":{"name":"table","content":{"type":",","blocks":[{"type":"|","blocks":[{"type":"*","block":"col"},{"type":"*","block":"colgroup"}]},{"type":"|","blocks":[{"type":",","blocks":[{"type":"?","block":"thead"},{"type":"?","block":"tfoot"},{"type":"+","block":"tbody"}]},{"type":"+","block":"tr"}]}]}}},"table-count":{"name":"table-count","type":"not-implemented","attributes":{},"elements":{"name":"table-count","content":{"type":",","blocks":[]}}},"table-wrap":{"name":"table-wrap","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"position":{"name":"position"},"orientation":{"name":"orientation"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"content-type":{"name":"content-type"}},"elements":{"name":"table-wrap","content":{"type":",","blocks":[{"type":"?","block":"object-id"},{"type":"?","block":"label"},{"type":"?","block":"caption"},"table",{"type":"?","block":"permissions"},{"type":"?","block":"table-wrap-foot"}]}}},"table-wrap-foot":{"name":"table-wrap-foot","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"table-wrap-foot","content":{"type":"?","block":"fn-group"}}},"table-wrap-group":{"name":"table-wrap-group","type":"not-implemented","attributes":{},"elements":{"name":"table-wrap-group","content":{"type":",","blocks":[]}}},"target":{"name":"target","type":"not-implemented","attributes":{},"elements":{"name":"target","content":{"type":",","blocks":[]}}},"tbody":{"name":"tbody","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tbody","content":{"type":"+","block":"tr"}}},"td":{"name":"td","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"abbr":{"name":"abbr"},"axis":{"name":"axis"},"headers":{"name":"headers"},"scope":{"name":"scope"},"rowspan":{"name":"rowspan"},"colspan":{"name":"colspan"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"td","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"term":{"name":"term","type":"not-implemented","attributes":{},"elements":{"name":"term","content":{"type":",","blocks":[]}}},"term-head":{"name":"term-head","type":"not-implemented","attributes":{},"elements":{"name":"term-head","content":{"type":",","blocks":[]}}},"tex-math":{"name":"tex-math","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"notation":{"name":"notation"},"version":{"name":"version"}},"elements":{"name":"tex-math","content":"TEXT"}},"textual-form":{"name":"textual-form","type":"not-implemented","attributes":{},"elements":{"name":"textual-form","content":{"type":",","blocks":[]}}},"tfoot":{"name":"tfoot","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tfoot","content":{"type":"+","block":"tr"}}},"th":{"name":"th","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"abbr":{"name":"abbr"},"axis":{"name":"axis"},"headers":{"name":"headers"},"scope":{"name":"scope"},"rowspan":{"name":"rowspan"},"colspan":{"name":"colspan"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"th","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"thead":{"name":"thead","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"thead","content":{"type":"+","block":"tr"}}},"title":{"name":"title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"}},"elements":{"name":"title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"title-group":{"name":"title-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"}},"elements":{"name":"title-group","content":{"type":",","blocks":["article-title",{"type":"?","block":"subtitle"},{"type":"*","block":"trans-title-group"}]}}},"tr":{"name":"tr","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"style":{"name":"style"},"align":{"name":"align"},"char":{"name":"char"},"charoff":{"name":"charoff"},"valign":{"name":"valign"}},"elements":{"name":"tr","content":{"type":"+","block":{"type":"|","blocks":["th","td"]}}}},"trans-abstract":{"name":"trans-abstract","type":"container","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"abstract-type":{"name":"abstract-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-abstract","content":{"type":"*","block":"p"}}},"trans-source":{"name":"trans-source","type":"not-implemented","attributes":{},"elements":{"name":"trans-source","content":{"type":",","blocks":[]}}},"trans-subtitle":{"name":"trans-subtitle","type":"not-implemented","attributes":{},"elements":{"name":"trans-subtitle","content":{"type":",","blocks":[]}}},"trans-title":{"name":"trans-title","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-title","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"trans-title-group":{"name":"trans-title-group","type":"element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"trans-title-group","content":{"type":",","blocks":["trans-title",{"type":"*","block":"trans-subtitle"}]}}},"underline":{"name":"underline","type":"annotation","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"toggle":{"name":"toggle"},"underline-style":{"name":"underline-style"},"specific-use":{"name":"specific-use"}},"elements":{"name":"underline","content":{"type":"*","block":{"type":"|","blocks":["TEXT","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","sub","sup"]}}}},"underline-end":{"name":"underline-end","type":"not-implemented","attributes":{},"elements":{"name":"underline-end","content":{"type":",","blocks":[]}}},"underline-start":{"name":"underline-start","type":"not-implemented","attributes":{},"elements":{"name":"underline-start","content":{"type":",","blocks":[]}}},"unstructured-kwd-group":{"name":"unstructured-kwd-group","type":"not-implemented","attributes":{},"elements":{"name":"unstructured-kwd-group","content":{"type":",","blocks":[]}}},"uri":{"name":"uri","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"},"xlink:type":{"name":"xlink:type"},"xlink:href":{"name":"xlink:href"},"xlink:role":{"name":"xlink:role"},"xlink:title":{"name":"xlink:title"},"xlink:show":{"name":"xlink:show"},"xlink:actuate":{"name":"xlink:actuate"}},"elements":{"name":"uri","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"verse-group":{"name":"verse-group","type":"not-implemented","attributes":{},"elements":{"name":"verse-group","content":{"type":",","blocks":[]}}},"verse-line":{"name":"verse-line","type":"not-implemented","attributes":{},"elements":{"name":"verse-line","content":{"type":",","blocks":[]}}},"version":{"name":"version","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"designator":{"name":"designator"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"version","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup"]}}}},"volume":{"name":"volume","type":"text","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"seq":{"name":"seq"},"content-type":{"name":"content-type"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"volume","content":"TEXT"}},"volume-id":{"name":"volume-id","type":"not-implemented","attributes":{},"elements":{"name":"volume-id","content":{"type":",","blocks":[]}}},"volume-issue-group":{"name":"volume-issue-group","type":"not-implemented","attributes":{},"elements":{"name":"volume-issue-group","content":{"type":",","blocks":[]}}},"volume-series":{"name":"volume-series","type":"not-implemented","attributes":{},"elements":{"name":"volume-series","content":{"type":",","blocks":[]}}},"word-count":{"name":"word-count","type":"not-implemented","attributes":{},"elements":{"name":"word-count","content":{"type":",","blocks":[]}}},"xref":{"name":"xref","type":"inline-element","attributes":{"id":{"name":"id"},"xml:base":{"name":"xml:base"},"ref-type":{"name":"ref-type"},"alt":{"name":"alt"},"rid":{"name":"rid"},"specific-use":{"name":"specific-use"},"xml:lang":{"name":"xml:lang"}},"elements":{"name":"xref","content":{"type":"*","block":{"type":"|","blocks":["TEXT","ext-link","inline-supplementary-material","bold","fixed-case","italic","monospace","overline","overline-start","overline-end","roman","sans-serif","sc","strike","underline","underline-start","underline-end","ruby","alternatives","inline-graphic","private-char","chem-struct","inline-formula","abbrev","milestone-end","milestone-start","named-content","styled-content","target","xref","sub","sup","break"]}}}},"year":{"name":"year","type":"text","attributes":{},"elements":{"name":"year","content":"TEXT"}}}}

  const DOC_TYPE_PARAMS$1 = ['article', 'TextureArticle 0.1.0', 'http://substance.io/TextureArticle-1.0.0.dtd'];

  var TextureArticleSchema = createSchema(TextureArticleData, 'texture-article', '0.1.0', DOC_TYPE_PARAMS$1)

  const PRESERVE_WHITESPACE = {
    'preformat': true
  };

  function pruneText (el, xmlSchema) {
    if (el.isElementNode()) {
      let schema = xmlSchema.getElementSchema(el.tagName);
      if (!schema.isTextAllowed()) {
        _pruneText(el, xmlSchema);
      } else if (schema.type === 'text' && !PRESERVE_WHITESPACE[el.tagName]) {
        _pruneWhiteSpace(el, xmlSchema);
      }
    }
  }

  function _pruneText (el, xmlSchema) {
    let childNodes = el.childNodes;
    for (let i = childNodes.length - 1; i >= 0; i--) {
      let child = childNodes[i];
      if (child.isTextNode()) {
        el.removeChild(child);
      } else if (child.isElementNode()) {
        pruneText(child, xmlSchema);
      }
    }
  }

  function _pruneWhiteSpace (el, xmlSchema) {
    // TODO:
    // - remove all leading ws
    // - replace all inner ws with one space
    // - remove all trailing ws
    let childNodes = el.childNodes;
    if (childNodes.length === 0) return
    let firstChild = childNodes[0];
    let lastChild = substance.last(childNodes);
    // trim leading ws
    if (firstChild.isTextNode()) {
      let text = firstChild.textContent;
      text = text.replace(/^\s+/g, '');
      firstChild.textContent = text;
    }
    // trim trailing ws
    if (lastChild.isTextNode()) {
      let text = lastChild.textContent;
      text = text.replace(/\s+$/g, '');
      lastChild.textContent = text;
    }
    for (let i = 0; i < childNodes.length; i++) {
      let child = childNodes[i];
      if (child.isTextNode()) {
        let text = child.textContent;
        let m;
        while ((m = /\s\s+/g.exec(text))) {
          const L = m[0].length;
          text = text.slice(0, m.index) + ' ' + text.slice(m.index + L);
        }
        child.textContent = text;
      } else if (child.isElementNode()) {
        let schema = xmlSchema.getElementSchema(child.tagName);
        if (schema.type === '@annotation') {
          _pruneWhiteSpace(child, xmlSchema);
        }
      }
    }
  }

  /*
    Removes all native TextNodes from elements which we specified to be
    not-mixed.
  */
  class PruneText {
    import (dom) {
      pruneText(dom.find('article'), TextureArticleSchema);
    }

    export () {
      // nothing
    }
  }

  /*
    Normalize footnotes contents.
    Removes everything except textual paragraphs from footnotes.
  */
  class NormalizeFn {
    import (dom) {
      let fns = dom.findAll('fn');
      fns.forEach(fn => {
        // Find all ptags that are nested in another p tag
        let ptags = fn.findAll('p p');
        // If any nested paragraphs are found we need to take action
        if (ptags.length > 0) {
          fn.empty();
          fn.append(ptags);
        }
      });
    }

    export () {
      // nothing
    }
  }

  /*
    Ensures the first contrib-group is tagged as authors and second as editors
  */
  class NormalizeContribGroup {
    import (dom) {
      let contribGroups = dom.findAll('article-meta > contrib-group');
      if (contribGroups[0]) {
        _normalizeContribGroup(contribGroups[0], 'author');
      }

      if (contribGroups[1]) {
        _normalizeContribGroup(contribGroups[1], 'editor');
      }

      if (contribGroups.length > 2) {
        console.warn(`Only the first 2 found contrib-groups (authors, editors) will be editable.`);
      }
    }

    export () {
      // nothing
    }
  }

  function _normalizeContribGroup (contribGroup, targetType) {
    contribGroup.attr('content-type', targetType);
  }

  /*
    This pulls block-elements such as `<fig>` which are
    wrapped in a `<p>` one level up.
    In the opposite direction only those elements are wrapped
    which would otherwise violate JATS
  */
  class UnwrapBlockLevelElements {
    import (dom) {
      dom.findAll('body > p').forEach(_pBlock);
    }

    export () {}
  }

  // TODO: add all of them
  const BLOCKS = ['fig', 'fig-group', 'media', 'list', 'disp-formula', 'disp-quote'];
  const isBlock = BLOCKS.reduce((m, n) => { m[n] = true; return m }, {});

  function _pBlock (p) {
    let parent = p.parentNode;
    let children = p.children;
    let L = children.length;
    // doing it reverse so that we don't miss elements due to the ongoing tranformations
    for (var i = L - 1; i >= 0; i--) {
      let child = children[i];
      if (isBlock[child.tagName]) {
        // create a new <p>
        let newP = parent.createElement('p');
        let childPos = p.getChildIndex(child);
        let siblings = p.childNodes.slice(childPos + 1);
        // move all subsequent siblings to the new <p>
        // and insert the block element and the new one after the current <p>
        let pos = parent.getChildIndex(p) + 1;
        parent.insertAt(pos, child);
        if (siblings.length > 0 && _needsP(siblings)) {
          newP.append(siblings);
          parent.insertAt(pos + 1, newP);
        }
      }
    }
    // if the original <p> is now empty, remove it
    if (!_needsP(p.childNodes)) {
      p.parentNode.removeChild(p);
    }
  }

  function _needsP (nodes) {
    for (let i = 0; i < nodes.length; i++) {
      let child = nodes[i];
      // don't prune if there is something else left
      if (!child.isTextNode() || !(/^\s*$/.exec(child.textContent))) return true
    }
    return false
  }

  /*
    Creates empty ref-list if there is no one
    and removes everything except refs from existing ref-list.
  */
  class RefList {
    import (dom) {
      let refLists = dom.findAll('ref-list');
      if (refLists.length > 0) {
        refLists.forEach(refList => {
          let refs = refList.findAll('ref');
          refList.empty();
          refList.append(refs);
        });
      } else {
        let back = dom.find('back');
        back.append(
          dom.createElement('ref-list')
        );
      }
    }

    export () {
      // nothing
    }
  }

  const trafos = [
    NormalizeContribGroup,
    NormalizeFn,
    RefList,
    UnwrapBlockLevelElements,
    PruneText
  ].map(C => new C());

  function jats2restrictedJats (dom, api) {
    for (let i = 0; i < trafos.length; i++) {
      trafos[i].import(dom, api);
    }
  }

  /*
    EXPERIMENTAL: an 'Editing' interface that takes the XML schema into account.
    TODO: try to generalize this and add it to the 'app dev kit'
  */
  class TextureEditing extends substance.Editing {
    /*
      2.0 API suggestion (pass only id, not data)
    */
    insertInlineNode (tx, node) {
      let text = '\uFEFF';
      this.insertText(tx, text);
      let sel = tx.selection;
      let endOffset = tx.selection.end.offset;
      let startOffset = endOffset - text.length;
      // TODO: introduce a coordinate operation for that
      tx.set([node.id, 'start', 'path'], sel.path);
      tx.set([node.id, 'start', 'offset'], startOffset);
      tx.set([node.id, 'end', 'path'], sel.path);
      tx.set([node.id, 'end', 'offset'], endOffset);
      return node
    }

    createListNode (tx, containerPath, params) {
      let prop = tx.getProperty(containerPath);
      if (prop.targetTypes.indexOf('list') >= 0) {
        return tx.create({ type: 'list', listType: params.listType })
      } else {
        throw new Error(`'list' is not a valid child node for ${containerPath}`)
      }
    }

    insertBlockNode (tx, node) {
      // HACK: deviating from the current implementation
      // to replace selected node, because it happens quite often
      let sel = tx.selection;
      if (sel.isNodeSelection() && sel.mode !== 'before') {
        tx.setSelection(Object.assign(sel.toJSON(), { mode: 'after' }));
      }
      super.insertBlockNode(tx, node);
    }
  }

  class InternalArticleDocument extends substance.Document {
    getRootNode () {
      return this.get('article')
    }

    getXRefs () {
      let articleEl = this.get('article');
      return articleEl.findAll('xref')
    }

    getTitle () {
      return this.get(['article', 'title'])
    }

    createEditingInterface () {
      return new substance.EditingInterface(this, { editing: new TextureEditing() })
    }

    find (selector) {
      return this.getRootNode().find(selector)
    }

    findAll (selector) {
      return this.getRootNode().findAll(selector)
    }

    invert (change) {
      let inverted = change.invert();
      let info = inverted.info || {};
      switch (change.info.action) {
        case 'insertRows': {
          info.action = 'deleteRows';
          break
        }
        case 'deleteRows': {
          info.action = 'insertRows';
          break
        }
        case 'insertCols': {
          info.action = 'deleteCols';
          break
        }
        case 'deleteCols': {
          info.action = 'insertCols';
          break
        }
        default:
          //
      }
      inverted.info = info;
      return inverted
    }

    static createEmptyArticle (schema) {
      let doc = new InternalArticleDocument(schema);
      substance.documentHelpers.createNodeFromJson(doc, {
        type: 'article',
        id: 'article',
        metadata: {
          type: 'metadata',
          id: 'metadata',
          permission: {
            type: 'permission',
            id: 'permission'
          }
        },
        abstract: {
          type: 'abstract',
          id: 'abstract',
          content: [{ type: 'paragraph' }]
        },
        body: {
          type: 'body',
          id: 'body'
        }
      });
      return doc
    }
  }

  class Abstract extends substance.DocumentNode {}
  Abstract.schema = {
    type: 'abstract',
    abstractType: substance.STRING,
    content: substance.CONTAINER('paragraph')
  };

  // annotations that are simple annotations
  const RICH_TEXT_ANNOS = ['bold', 'italic', 'superscript', 'subscript'];

  const EXTENDED_FORMATTING = ['monospace', 'small-caps', 'strike-through', 'underline', 'overline'];

  const LINKS_AND_XREFS = ['xref', 'external-link'];

  const INLINE_NODES = ['inline-formula', 'inline-graphic'];

  class Article extends substance.DocumentNode {}
  Article.schema = {
    type: 'article',
    metadata: substance.CHILD('metadata'),
    title: substance.TEXT(RICH_TEXT_ANNOS),
    subTitle: substance.TEXT(RICH_TEXT_ANNOS),
    abstract: substance.CHILD('abstract'),
    body: substance.CHILD('body'),
    references: substance.CHILDREN('reference'),
    footnotes: substance.CHILDREN('footnote'),
    // EXPERIMENTAL: a translation has a link to the original content property
    // e.g. a translation for the article abstract points to 'article.abstract'
    // and has the same 'targetTypes' as the source property
    // FIXME: implement a UI for translations
    translations: substance.CHILDREN('translation')
  };

  // Note: this is used as a indicator class for all types of references
  class Reference extends substance.DocumentNode {}

  Reference.schema = {
    type: 'reference'
  };

  /*
    <element-citation publication-type="article">
      <year>2016</year>
      <pub-id pub-id-type="doi">10.1101/029983</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Bloss</surname>
          <given-names>CS</given-names>
        </name>
      </person-group>
      <source>bioRxiv</source>
      <article-title>A prospective randomized trial examining...</article-title>
    </element-citation>
  */
  class ArticleRef extends Reference {}
  ArticleRef.schema = {
    type: 'article-ref', // publication-type="article"
    title: substance.STRING, // <article-title>
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    editors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="editor">
    containerTitle: substance.STRING, // <source>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    elocationId: substance.STRING, // <elocation-id>
    doi: substance.STRING, // <pub-id pub-id-type="doi">
    pmid: substance.STRING // <pub-id pub-id-type="pmid">
  };

  class BlockFormula extends substance.DocumentNode {
    static get refType () {
      return 'disp-formula'
    }
  }

  BlockFormula.schema = {
    type: 'block-formula',
    label: substance.STRING,
    content: substance.STRING
  };

  class BlockQuote extends substance.DocumentNode {
    // used to create an empty node
    static getTemplate () {
      return {
        type: 'block-quote',
        content: [
          { type: 'paragraph' }
        ]
      }
    }
  }
  BlockQuote.schema = {
    type: 'block-quote',
    content: substance.CONTAINER('paragraph'),
    attrib: 'text'
  };

  class Body extends substance.ContainerMixin(substance.DocumentNode) {
    getContent () {
      return this.content
    }
    getContentPath () {
      return [this.id, 'content']
    }
  }
  Body.schema = {
    type: 'body',
    content: substance.CONTAINER({
      nodeTypes: ['block-formula', 'block-quote', 'figure', 'heading', 'list', 'paragraph', 'preformat', 'supplementary-file', 'table-figure'],
      defaultTextType: 'paragraph'
    })
  };

  class Annotation extends substance.PropertyAnnotation {}
  Annotation.schema = {
    type: 'annotation'
  };

  class Bold extends Annotation {}
  Bold.schema = {
    type: 'bold'
  };

  /*
    <element-citation publication-type="book">
      <publisher-loc>New York</publisher-loc>
      <publisher-name>Oxford University Press</publisher-name>
      <year>2006</year>
      <pub-id pub-id-type="isbn">978-0195301069</pub-id>
      <pub-id pub-id-type="doi">10.1093/acprof:oso/9780195301069.001.0001</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Buzsaki</surname>
          <given-names>G</given-names>
        </name>
      </person-group>
      <source>Rhythms of the Brain</source>
    </element-citation>
  */
  class BookRef extends Reference {}
  BookRef.schema = {
    type: 'book-ref',
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    editors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="editor">
    translators: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="translator">
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <source>
    volume: substance.STRING, // <volume>
    edition: substance.STRING, // <editor>
    publisherLoc: substance.STRING, // <publisher-loc>
    publisherName: substance.STRING, // <publisher-name>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    pageCount: substance.STRING, // <page-count>
    series: substance.STRING, // <series>
    doi: substance.STRING, // <pub-id pub-id-type="doi">
    isbn: substance.STRING, // <pub-id pub-id-type="isbn">
    pmid: substance.STRING // <pub-id pub-id-type="pmid">
  };

  class Break extends substance.InlineNode {}
  Break.schema = {
    type: 'break'
  };

  /*
    <element-citation publication-type="chapter">
      <day>22</day>
      <fpage>180</fpage>
      <lpage>207</lpage>
      <month>08</month>
      <publisher-loc>Sunderland, MA</publisher-loc>
      <publisher-name>Sinauer Associates</publisher-name>
      <year>1989</year>
      <pub-id pub-id-type="isbn">978-0878936588</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Coyne</surname>
          <given-names>JA</given-names>
        </name>
      </person-group>
      <person-group person-group-type="editor">
        <name>
          <surname>Otte</surname>
          <given-names>D</given-names>
        </name>
      </person-group>
      <source>Speciation and its consequences</source>
      <chapter-title>Two rules of speciation</chapter-title>
    </element-citation>
  */
  class ChapterRef extends Reference {}
  ChapterRef.schema = {
    type: 'chapter-ref',
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <chapter-title>
    containerTitle: substance.STRING, // <source>
    volume: substance.STRING, // <volume>
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    editors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="editor">
    translators: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="translator">
    edition: substance.STRING, // <edition>
    publisherLoc: substance.STRING, // <publisher-loc>
    publisherName: substance.STRING, // <publisher-name>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    fpage: substance.STRING, // <fpage>
    lpage: substance.STRING, // <lpage>
    pageRange: substance.STRING, // <page-range>
    elocationId: substance.STRING, // <elocation-id>
    series: substance.STRING, // <series>
    doi: substance.STRING, // <pub-id pub-id-type="doi">
    isbn: substance.STRING, // <pub-id pub-id-type="isbn">
    pmid: substance.STRING // <pub-id pub-id-type="pmid">
  };

  /*
    <element-citation publication-type="confproc">
      <conf-name>Proceedings of the 17th Annual Meeting of International Society for Magnetic Resonance in Medicine</conf-name>
      <conf-loc>Hawaii, United States</conf-loc>
      <year>2009</year>
      <person-group person-group-type="author">
        <name>
          <surname>Leemans</surname>
          <given-names>A</given-names>
        </name>
      </person-group>
      <article-title>ExploreDTI: a graphical toolbox for processing, analyzing, and visualizing diffusion MR data</article-title>
    </element-citation>
  */
  class ConferencePaperRef extends Reference {}
  ConferencePaperRef.schema = {
    type: 'conference-paper-ref', // publication-type="confproc"
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <article-title>
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    confName: substance.STRING, // <conf-name>
    confLoc: substance.STRING, // <conf-loc>
    containerTitle: substance.STRING, // <source>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    fpage: substance.STRING, // <fpage>
    lpage: substance.STRING, // <lpage>
    pageRange: substance.STRING, // <page-range>
    elocationId: substance.STRING, // <elocation-id>
    doi: substance.STRING // <pub-id pub-id-type="doi">
  };

  class CustomMetadataField extends substance.DocumentNode {
    static getTemplate () {
      return {
        type: 'custom-metadata-field'
      }
    }

    isEmpty () {
      return this.length === 0
    }
  }
  CustomMetadataField.schema = {
    type: 'custom-metadata-field',
    name: substance.STRING,
    // ATTENTION: for now a field consist only of one plain-text value
    // user may use ',' to separate values
    // later on we might opt for a structural approach
    value: substance.STRING
  };

  /*
    <element-citation publication-type="data">
      <day>01</day>
      <month>06</month>
      <year>2016</year>
      <pub-id pub-id-type="accession">GSE69545</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Allison</surname>
          <given-names>KA</given-names>
        </name>
      </person-group>
      <source>NCBI Gene Expression Omnibus</source>
      <data-title>Affinity and Dose of TCR Engagement Yield Proportional Enhancer and Gene Activity in CD4+ T Cells</data-title>
    </element-citation>
  */
  class DataPublicationRef extends Reference {}
  DataPublicationRef.schema = {
    type: 'data-publication-ref', // publication-type="data"
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <data-title>
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    containerTitle: substance.STRING, // <source>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    accessionId: substance.STRING, // <pub-id pub-id-type="accession">
    arkId: substance.STRING, // // <pub-id pub-id-type="ark">
    archiveId: substance.STRING, // <pub-id pub-id-type="archive">
    doi: substance.STRING // <pub-id pub-id-type="doi">
  };

  class ExternalLink extends Annotation {}
  ExternalLink.schema = {
    type: 'external-link',
    href: substance.STRING
    // TODO: JATS also has ext-link-type
  };

  class Figure extends substance.DocumentNode {
    _initialize (...args) {
      super._initialize(...args);

      this.state = {
        currentPanelIndex: 0
      };
    }

    getCurrentPanelIndex () {
      let currentPanelIndex = 0;
      if (this.state) {
        currentPanelIndex = this.state.currentPanelIndex;
      }
      return currentPanelIndex
    }

    getPanels () {
      return this.resolve('panels')
    }

    // NOTE: we are using structure of active panel as template for new one,
    // currently we are replicating the structure of metadata fields
    getTemplateFromCurrentPanel () {
      const currentIndex = this.getCurrentPanelIndex();
      const firstPanel = this.getPanels()[currentIndex];
      return {
        metadata: firstPanel.resolve('metadata').map(metadataField => (
          { type: 'custom-metadata-field', name: metadataField.name, value: '' }
        ))
      }
    }
  }
  Figure.schema = {
    type: 'figure',
    panels: substance.CHILDREN('figure-panel')
  };

  class FigurePanel extends substance.DocumentNode {
    getContent () {
      const doc = this.getDocument();
      return doc.get(this.content)
    }

    static getTemplate () {
      return {
        type: 'figure-panel',
        content: {
          type: 'graphic'
        },
        legend: [{
          type: 'paragraph'
        }],
        permission: {
          type: 'permission'
        }
      }
    }
  }
  FigurePanel.schema = {
    type: 'figure-panel',
    content: substance.CHILD('graphic'),
    title: substance.TEXT(...RICH_TEXT_ANNOS, 'xref'),
    label: substance.STRING,
    legend: substance.CONTAINER({
      nodeTypes: ['paragraph', 'supplementary-file'],
      defaultTextType: 'paragraph'
    }),
    permission: substance.CHILD('permission'),
    metadata: substance.CHILDREN('custom-metadata-field')
  };

  class Footnote extends substance.DocumentNode {
    static getTemplate () {
      return {
        type: 'footnote',
        content: [
          { type: 'paragraph' }
        ]
      }
    }
  }
  Footnote.schema = {
    type: 'footnote',
    label: substance.PLAIN_TEXT,
    content: substance.CONTAINER('paragraph')
  };

  class Funder extends substance.DocumentNode {
    toString () {
      return this.institution
    }
  }
  Funder.schema = {
    type: 'funder',
    institution: substance.STRING,
    fundRefId: substance.STRING,
    awardId: substance.STRING
  };

  class Group extends substance.DocumentNode {
    toString () {
      return this.name
    }
  }
  Group.schema = {
    type: 'group',
    name: substance.STRING,
    email: substance.STRING,
    affiliations: substance.MANY('organisation'),
    funders: substance.MANY('funder'),
    equalContrib: substance.BOOLEAN,
    corresp: substance.BOOLEAN
  };

  class Graphic extends substance.DocumentNode {}
  Graphic.schema = {
    type: 'graphic',
    href: substance.STRING,
    mimeType: substance.STRING
  };

  class Heading extends substance.TextNode {}
  Heading.schema = {
    type: 'heading',
    level: { type: 'number', default: 1 },
    content: substance.TEXT(RICH_TEXT_ANNOS.concat(EXTENDED_FORMATTING).concat(LINKS_AND_XREFS).concat(INLINE_NODES).concat(['break']))
  };

  class InlineFormula extends substance.InlineNode {}
  InlineFormula.schema = {
    type: 'inline-formula',
    content: substance.STRING
  };

  class InlineGraphic extends substance.InlineNode {}
  InlineGraphic.schema = {
    type: 'inline-graphic',
    mimeType: substance.STRING,
    href: substance.STRING
  };

  class Italic extends Annotation {}
  Italic.schema = {
    type: 'italic'
  };

  /*
    <element-citation publication-type="journal">
      <day>06</day>
      <fpage>1141</fpage>
      <lpage>1144</lpage>
      <month>11</month>
      <volume>282</volume>
      <year>1998</year>
      <pub-id pub-id-type="doi">10.1126/science.282.5391.1141</pub-id>
      <pub-id pub-id-type="pmid">9804555</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Baukrowitz</surname>
          <given-names>T</given-names>
        </name>
      </person-group>
      <source>Science</source>
      <article-title>PIP<sub id="sub-1">2</sub> and PIP as determinants ...</article-title>
    </element-citation>
  */
  class JournalArticleRef extends Reference {}
  JournalArticleRef.schema = {
    type: 'journal-article-ref', // publication-type="journal"
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <article-title>
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    editors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="editor">
    containerTitle: substance.STRING, // <source>: label this 'Journal' or 'Publication' as in Zotero?
    volume: substance.STRING, // <volume>
    issue: substance.STRING, // <issue>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    fpage: substance.STRING, // <fpage>
    lpage: substance.STRING, // <lpage>
    pageRange: substance.STRING, // <page-range>
    elocationId: substance.STRING, // <elocation-id>
    doi: substance.STRING, // <pub-id pub-id-type="doi">
    pmid: substance.STRING // <pub-id pub-id-type="pmid">
  };

  class Keyword extends substance.DocumentNode {}
  Keyword.schema = {
    type: 'keyword',
    name: substance.TEXT(...RICH_TEXT_ANNOS),
    category: substance.STRING,
    language: substance.STRING
  };

  class List extends substance.ListMixin(substance.DocumentNode) {
    createListItem (text) {
      let item = this.getDocument().create({ type: 'list-item', content: text, level: 1 });
      return item
    }

    getItems () {
      return substance.documentHelpers.getNodesForIds(this.getDocument(), this.items)
    }

    getItemsPath () {
      return [this.id, 'items']
    }

    getItemAt (idx) {
      let doc = this.getDocument();
      return doc.get(this.items[idx])
    }

    getItemPosition (item) {
      return this.items.indexOf(item.id)
    }

    insertItemAt (pos, item) {
      substance.documentHelpers.insertAt(this.getDocument(), this.getItemsPath(), pos, item.id);
    }

    removeItemAt (pos) {
      substance.documentHelpers.removeAt(this.getDocument(), this.getItemsPath(), pos);
    }

    getLength () {
      return this.items.length
    }

    getListTypeString () {
      return this.listType
    }

    setListTypeString (listTypeStr) {
      this.listType = listTypeStr;
    }
  }

  List.schema = {
    type: 'list',
    items: substance.CHILDREN('list-item'),
    listType: substance.STRING
  };

  class ListItem extends substance.TextNodeMixin(substance.DocumentNode) {
    getLevel () {
      return this.level
    }

    setLevel (newLevel) {
      let doc = this.getDocument();
      doc.set([this.id, 'level'], newLevel);
    }

    getPath () {
      return [this.id, 'content']
    }

    static isListItem () {
      return true
    }
  }

  ListItem.schema = {
    type: 'list-item',
    level: { type: 'number', default: 1 },
    content: substance.TEXT(RICH_TEXT_ANNOS.concat(EXTENDED_FORMATTING).concat(LINKS_AND_XREFS).concat(INLINE_NODES))
  };

  /*
    <element-citation publication-type="magazine">
      <person-group person-group-type="author">
        <name>
          <surname>Craig</surname>
          <given-names>DJ</given-names>
        </name>
      </person-group>
      <year>2017</year>
      <article-title>A voice for women and girls</article-title>
      <source>Columbia Magazine</source>
      <volume>Fall 2017</volume>
      <fpage>36</fpage>
      <lpage>38</lpage>
    </element-citation>
  */
  class MagazineArticleRef extends Reference {}
  MagazineArticleRef.schema = {
    type: 'magazine-article-ref',
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <article-title>
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    containerTitle: substance.STRING, // <source>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <month>
    volume: substance.STRING, // <volume>
    fpage: substance.STRING, // <fpage>
    lpage: substance.STRING, // <lpage>
    pageRange: substance.STRING, // <page-range>
    doi: substance.STRING // <pub-id pub-id-type="doi">
  };

  class Metadata extends substance.DocumentNode {}
  Metadata.schema = {
    type: 'metadata',
    articleType: substance.STRING,
    authors: substance.CHILDREN('person'),
    editors: substance.CHILDREN('person'),
    groups: substance.CHILDREN('group'),
    organisations: substance.CHILDREN('organisation'),
    funders: substance.CHILDREN('funder'),
    // TODO: this might change in a similar way as we gonna approach Figure metadata, where there can be multiple fields with multiple values
    keywords: substance.CHILDREN('keyword'),
    subjects: substance.CHILDREN('subject'),
    volume: substance.STRING,
    issue: substance.STRING,
    issueTitle: substance.TEXT(...RICH_TEXT_ANNOS),
    fpage: substance.STRING,
    lpage: substance.STRING,
    pageRange: substance.STRING,
    elocationId: substance.STRING,
    acceptedDate: substance.STRING,
    publishedDate: substance.STRING,
    receivedDate: substance.STRING,
    revReceivedDate: substance.STRING,
    revRequestedDate: substance.STRING,
    permission: substance.CHILD('permission')
  };

  class Monoscript extends Annotation {}
  Monoscript.schema = {
    type: 'monospace'
  };

  /*
    <element-citation publication-type="newspaper">
      <day>27</day>
      <edition>International Edition</edition>
      <fpage>21</fpage>
      <month>4</month>
      <part-title>Film</part-title>
      <year>2018</year>
      <person-group person-group-type="author">
        <name>
          <surname>Rose</surname>
          <given-names>Steve</given-names>
        </name>
      </person-group>
      <source>The Guardian</source>
      <article-title>What if superheroes aren’t really the good guys?</article-title>
    </element-citation>
  */
  class NewspaperArticleRef extends Reference {}
  NewspaperArticleRef.schema = {
    type: 'newspaper-article-ref', // publication-type="newspaper"
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <article-title>
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    containerTitle: substance.STRING, // <source>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    volume: substance.STRING, // <volume>
    fpage: substance.STRING, // <fpage>
    lpage: substance.STRING, // <lpage>
    pageRange: substance.STRING, // <page-range>
    doi: substance.STRING, // <pub-id pub-id-type="doi">
    edition: substance.STRING, // <edition>
    partTitle: substance.STRING // <part-title>
  };

  class Organisation extends substance.DocumentNode {
    toString () {
      return this.render()
    }

    render (options = {}) {
      let { institution, division1, division2, division3 } = this;
      let result = institution ? [ institution ] : '???';
      // TODO: do we really want this? Because the divisions might
      // be necessary to really understand the displayed name
      if (!options.short && institution) {
        if (division1) {
          result.push(', ', division1);
        }
        if (division2) {
          result.push(', ', division2);
        }
        if (division3) {
          result.push(', ', division3);
        }
      }
      return result
    }
  }

  Organisation.schema = {
    type: 'organisation',
    institution: substance.STRING,
    division1: substance.STRING,
    division2: substance.STRING,
    division3: substance.STRING,
    // Consider switching to address-line1,2,3
    street: substance.STRING,
    addressComplements: substance.STRING,
    city: substance.STRING,
    state: substance.STRING,
    postalCode: substance.STRING,
    country: substance.STRING,
    phone: substance.STRING,
    fax: substance.STRING,
    email: substance.STRING,
    uri: substance.STRING
  };

  class Overline extends Annotation {}
  Overline.schema = {
    type: 'overline'
  };

  /*
    <element-citation publication-type="patent">
      <day>17</day>
      <month>03</month>
      <patent country="United States">US20100941530</patent>
      <year>2011</year>
      <person-group person-group-type="inventor">
        <name>
          <surname>Patterson</surname>
          <given-names>JB</given-names>
        </name>
      </person-group>
      <source>United States patent</source>
      <article-title>IRE-1alpha inhibitors</article-title>
    </element-citation>
  */
  class PatentRef extends Reference {}
  PatentRef.schema = {
    type: 'patent-ref', // publication-type="patent"
    inventors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="inventor">
    assignee: substance.STRING, // <collab collab-type="assignee"><named-content>
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <article-title>
    containerTitle: substance.STRING, // <source>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    patentNumber: substance.STRING, // <patent>US20100941530</patent>
    patentCountry: substance.STRING, // <patent country="United States"></patent>
    doi: substance.STRING // <pub-id pub-id-type="doi">
  };

  class Paragraph extends substance.TextNode {}
  Paragraph.schema = {
    type: 'paragraph',
    content: substance.TEXT(RICH_TEXT_ANNOS.concat(EXTENDED_FORMATTING).concat(LINKS_AND_XREFS).concat(INLINE_NODES))
  };

  class Permission extends substance.DocumentNode {
    isEmpty () {
      return !(this.copyrightStatement || this.copyrightYear || this.copyrightHolder || this.license || this.licenseText)
    }
  }
  Permission.schema = {
    type: 'permission',
    copyrightStatement: substance.STRING,
    copyrightYear: substance.STRING,
    copyrightHolder: substance.STRING,
    // URL to license description  used as a unique license identifier
    // FIXME: bad naming. Use url, or licenseUrl?
    license: substance.STRING,
    licenseText: substance.TEXT(RICH_TEXT_ANNOS)
  };

  class Person extends substance.DocumentNode {}
  Person.schema = {
    type: 'person',
    surname: substance.STRING,
    givenNames: substance.STRING,
    alias: substance.STRING,
    prefix: substance.STRING,
    suffix: substance.STRING,
    email: substance.STRING,
    orcid: substance.STRING,
    group: substance.ONE('group'),
    affiliations: substance.MANY('organisation'),
    funders: substance.MANY('funder'),
    bio: substance.CHILDREN('paragraph'),
    equalContrib: substance.BOOLEAN,
    corresp: substance.BOOLEAN,
    deceased: substance.BOOLEAN
  };

  class Preformat extends substance.TextNode {}
  Preformat.schema = {
    type: 'preformat',
    content: substance.STRING,
    preformatType: substance.STRING
  };

  /* Holds data for persons and instituions/groups in references */
  class RefContrib extends substance.DocumentNode {}
  RefContrib.schema = {
    type: 'ref-contrib',
    name: substance.STRING, // either family name or institution name
    givenNames: substance.STRING
  };

  /*
    <element-citation publication-type="report">
      <month>06</month>
      <publisher-loc>Monrovia, Liberia</publisher-loc>
      <publisher-name>NMCP, LISGIS, and ICF International</publisher-name>
      <year>2012</year>
      <person-group person-group-type="author">
        <collab>
          <named-content content-type="name">National Malaria Control Program - Ministry of Health and Social Welfare</named-content>
        </collab>
      </person-group>
      <person-group person-group-type="sponsor">
        <collab>
          <named-content content-type="name">United States Agency for International Development</named-content>
        </collab>
      </person-group>
      <source>Liberia Malaria Indicator Survey 2011</source>
    </element-citation>
  */
  class ReportRef extends Reference {}
  ReportRef.schema = {
    type: 'report-ref', // publication-type="report"
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    sponsors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="sponsor">
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <source>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    publisherName: substance.STRING, // <publisher-name>
    publisherLoc: substance.STRING, // <publisher-loc>
    series: substance.STRING, // <series>
    isbn: substance.STRING, // <pub-id pub-id-type="isbn">
    doi: substance.STRING // <pub-id pub-id-type="doi">
  };

  class SmallCaps extends Annotation {}
  SmallCaps.schema = {
    type: 'small-caps'
  };

  /*
    <element-citation publication-type="software">
      <day>19</day>
      <month>3</month>
      <publisher-name>Zenodo</publisher-name>
      <version>2.0.1</version>
      <year>2018</year>
      <pub-id pub-id-type="doi">10.5281/zenodo.1203712</pub-id>
      <person-group person-group-type="author">
        <name>
          <surname>Willner</surname>
          <given-names>Sven</given-names>
        </name>
        <name>
          <surname>Gieseke</surname>
          <given-names>Robert</given-names>
        </name>
      </person-group>
      <source>pyhector</source>
    </element-citation>
  */
  class SoftwareRef extends Reference {}
  SoftwareRef.schema = {
    type: 'software-ref', // publication-type="software"
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <source>
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    version: substance.STRING, // <version>
    publisherLoc: substance.STRING, // <publisher-loc>
    publisherName: substance.STRING, // <publisher-name>
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    doi: substance.STRING // <pub-id pub-id-type="doi">
  };

  class StrikeThrough extends Annotation {}
  StrikeThrough.schema = {
    type: 'strike-through'
  };

  class Subject extends substance.DocumentNode {}
  Subject.schema = {
    type: 'subject',
    name: substance.STRING,
    category: substance.STRING,
    language: substance.STRING
  };

  class Subscript extends Annotation {}
  Subscript.schema = {
    type: 'subscript'
  };

  class Superscript extends Annotation {}
  Superscript.schema = {
    type: 'superscript'
  };

  class SupplementaryFile extends substance.DocumentNode {
    static getTemplate () {
      return {
        type: 'supplementary-file',
        legend: [{ type: 'paragraph' }]
      }
    }
  }

  SupplementaryFile.schema = {
    type: 'supplementary-file',
    label: substance.STRING,
    mimetype: substance.STRING,
    href: substance.STRING,
    remote: substance.BOOLEAN,
    legend: substance.CONTAINER('paragraph')
  };

  class Table extends substance.DocumentNode {
    constructor (...args) {
      super(...args);

      this._matrix = null;
      this._rowIds = new Set();
      this._cellIds = new Set();
      this._sha = Math.random();

      this._enableCaching();
    }

    get (cellId) {
      if (!this._cellIds.has(cellId)) throw new Error('Cell is not part of this table.')
      return this.document.get(cellId)
    }

    getCellMatrix () {
      if (!this._matrix) {
        let spanningCells = [];
        let rows = this.getRows();
        let matrix = rows.map((row, rowIdx) => {
          let cells = row.getCells();
          for (let colIdx = 0; colIdx < cells.length; colIdx++) {
            let c = cells[colIdx];
            c.rowIdx = rowIdx;
            c.colIdx = colIdx;
            c.shadowed = false;
            if (c.colspan || c.rowspan) {
              spanningCells.push(c);
            }
          }
          return cells
        });
        spanningCells.forEach(c => {
          _shadowSpanned(matrix, c.rowIdx, c.colIdx, c.rowspan, c.colspan, c);
        });
        this._matrix = matrix;
      }
      return this._matrix
    }

    getRowCount () {
      return this.rows.length
    }

    getColumnCount () {
      if (this.rows.length === 0) return 0
      let doc = this.getDocument();
      let firstRow = doc.get(this.rows[0]);
      return firstRow.cells.length
    }

    getDimensions () {
      return [this.getRowCount(), this.getColumnCount()]
    }

    getRowAt (rowIdx) {
      let doc = this.getDocument();
      return doc.get(this.rows[rowIdx])
    }

    getCell (rowIdx, colIdx) {
      const matrix = this.getCellMatrix();
      let row = matrix[rowIdx];
      if (row) {
        return row[colIdx]
      }
    }

    getRows () {
      return substance.documentHelpers.getNodesForIds(this.getDocument(), this.rows)
    }

    _enableCaching () {
      // this hook is used to invalidate cached positions
      if (this.document) {
        this._rowIds = new Set(this.rows);
        let cellIds = this.getRows().reduce((arr, row) => {
          return arr.concat(row.cells)
        }, []);
        this._cellIds = new Set(cellIds);
        this.document.data.on('operation:applied', this._onOperationApplied, this);
      }
    }

    _onOperationApplied (op) {
      if (!op.path) return
      let nodeId = op.path[0];
      let hasChanged = false;
      // whenever a row is added or removed
      if (nodeId === this.id && op.path[1] === 'rows') {
        let update = op.getValueOp();
        if (update.isDelete()) {
          this._rowIds.delete(update.getValue());
        } else if (update.isInsert()) {
          let rowId = update.getValue();
          let row = this.document.get(rowId);
          row.cells.forEach(cellId => {
            this._cellIds.add(cellId);
          });
          this._rowIds.add(rowId);
        }
        hasChanged = true;
      // whenever a row is changed belonging to this table
      } else if (this._rowIds.has(nodeId) && op.path[1] === 'cells') {
        let update = op.getValueOp();
        if (update.isDelete()) {
          this._cellIds.delete(update.getValue());
        } else if (update.isInsert()) {
          this._cellIds.add(update.getValue());
        }
        hasChanged = true;
      // whenever rowspan/colspan of cell is changed, that belongs to this table
      } else if (this._cellIds.has(nodeId) && (op.path[1] === 'rowspan' || op.path[1] === 'colspan')) {
        hasChanged = true;
      }
      if (hasChanged) {
        this._matrix = null;
        // HACK: using a quasi-sha to indicate that this table has been
        // changed structurally
        this._sha = Math.random();
      }
    }

    _hasShaChanged (sha) {
      return (this._sha !== sha)
    }

    _getSha () {
      return this._sha
    }

    static getTemplate (options = {}) {
      let headerRowCount = options.headerRows || 1;
      let rowCount = options.rows || 3;
      let colCount = options.cols || 4;

      return {
        type: 'table',
        id: options.id,
        rows: Table.getRowsTemplate(headerRowCount, colCount, true)
          .concat(Table.getRowsTemplate(rowCount, colCount))
      }
    }

    static getRowsTemplate (rowCount, colCount, heading) {
      return Array(rowCount).fill().map(_ => {
        return {
          type: 'table-row',
          cells: Table.getCellsTemplate(colCount, heading)
        }
      })
    }

    static getCellsTemplate (colCount, heading) {
      return Array(colCount).fill().map(_ => {
        return {
          type: 'table-cell',
          heading
        }
      })
    }
  }

  Table.schema = {
    type: 'table',
    rows: substance.CHILDREN('table-row')
  };

  function _shadowSpanned (matrix, row, col, rowspan, colspan, masterCell) {
    if (!rowspan && !colspan) return
    for (let i = row; i <= row + rowspan - 1; i++) {
      for (let j = col; j <= col + colspan - 1; j++) {
        if (i === row && j === col) continue
        let cell = matrix[i][j];
        cell.shadowed = true;
        cell.masterCell = masterCell;
      }
    }
  }

  class TableCell extends substance.TextNode {
    constructor (...args) {
      super(...args);

      this.rowIdx = -1;
      this.colIdx = -1;
    }

    isShadowed () {
      return this.shadowed
    }

    getMasterCell () {
      return this.masterCell
    }
  }

  TableCell.schema = {
    type: 'table-cell',
    rowspan: { type: 'number', default: 1 },
    colspan: { type: 'number', default: 1 },
    heading: { type: 'boolean', default: false },
    content: substance.TEXT('bold', 'italic', 'superscript', 'subscript', 'monospace', 'external-link', 'xref', 'inline-formula', 'inline-graphic')
  };

  class TableFigure extends FigurePanel {
    // HACK: we need a place to store the tableFootnoteManager
    // in a controlled fashion
    getFootnoteManager () {
      return this._tableFootnoteManager
    }

    setFootnoteManager (footnoteManager) {
      this._tableFootnoteManager = footnoteManager;
    }

    hasFootnotes () {
      return this.footnotes && this.footnotes.length > 0
    }

    static getTemplate (options = {}) {
      return {
        type: 'table-figure',
        content: Table.getTemplate(options),
        legend: [{ type: 'paragraph' }],
        permission: { type: 'permission' }
      }
    }
  }
  TableFigure.schema = {
    type: 'table-figure',
    content: substance.CHILD('table'),
    footnotes: substance.CHILDREN('footnote')
  };

  class TableRow extends substance.DocumentNode {
    getCells () {
      return substance.documentHelpers.getNodesForIds(this.getDocument(), this.cells)
    }

    getCellAt (cellIdx) {
      let doc = this.getDocument();
      return doc.get(this.cells[cellIdx])
    }
  }
  TableRow.schema = {
    type: 'table-row',
    cells: substance.CHILDREN('table-cell')
  };

  /*
    <element-citation publication-type="thesis">
      <publisher-loc>Nijmegen, The Netherlands</publisher-loc>
      <publisher-name>Radboud University Nijmegen Medical Centre</publisher-name>
      <year>2006</year>
      <person-group person-group-type="author">
        <name>
          <surname>Schneider</surname>
          <given-names>P</given-names>
        </name>
      </person-group>
      <article-title>PhD thesis: Submicroscopic <italic id="italic-2">Plasmodium falciparum</italic> gametocytaemia and the contribution to malaria transmission</article-title>
    </element-citation>
  */
  class ThesisRef extends Reference {}
  ThesisRef.schema = {
    type: 'thesis-ref', // publication-type="thesis"
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <article-title>
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    publisherLoc: substance.STRING, // <publisher-loc>
    publisherName: substance.STRING, // <publisher-name>
    doi: substance.STRING // <pub-id pub-id-type="doi">
  };

  class Translation extends substance.DocumentNode {
    getPath () {
      return [this.id, 'content']
    }
  }
  Translation.schema = {
    type: 'translation',
    language: substance.STRING,
    source: { type: ['array', 'id'] }
  };

  class ArticleTitleTranslation extends Translation {}
  ArticleTitleTranslation.schema = {
    type: 'article-title-translation',
    content: substance.cloneDeep(Article.schema.getProperty('title').definition)
  };

  class ArticleAbstractTranslation extends Translation {}
  ArticleAbstractTranslation.schema = {
    type: 'article-abstract-translation',
    content: substance.cloneDeep(Abstract.schema.getProperty('content').definition)
  };

  class Underline extends Annotation {}
  Underline.schema = {
    type: 'underline'
  };

  class UnsupportedInlineNode extends substance.InlineNode {}
  UnsupportedInlineNode.schema = {
    type: 'unsupported-inline-node',
    data: 'string'
  };

  class UnsupportedNode extends substance.DocumentNode {}
  UnsupportedNode.schema = {
    type: 'unsupported-node',
    data: substance.STRING
  };

  /*
    <element-citation publication-type="webpage">
      <day>10</day>
      <month>05</month>
      <uri>http://www.michaeleisen.org/blog/?p=1894</uri>
      <date-in-citation iso-8601-date="1995-09-10">1995-09-10</date-in-citation>
      <year>2016</year>
      <person-group person-group-type="author">
        <name>
          <surname>Eisen</surname>
          <given-names>M</given-names>
        </name>
      </person-group>
      <source>it is NOT junk</source>
      <article-title>The Imprinter of All Maladies</article-title>
    </element-citation>
  */
  class WebpageRef extends Reference {}
  WebpageRef.schema = {
    type: 'webpage-ref', // publication-type="webpage"
    title: substance.TEXT(...RICH_TEXT_ANNOS), // <article-title>
    // E.g. website name, where the page appeared
    containerTitle: substance.STRING, // <source>
    authors: substance.CHILDREN('ref-contrib'), // <person-group person-group-type="author">
    year: substance.STRING, // <year>
    month: substance.STRING, // <month>
    day: substance.STRING, // <day>
    accessedDate: substance.STRING, // <date-in-citation iso-8601-date="1995-09-10">
    uri: substance.STRING // <uri>
  };

  class Xref extends substance.InlineNode {}
  Xref.schema = {
    type: 'xref',
    label: substance.STRING,
    refType: substance.STRING,
    refTargets: {
      type: ['array', 'id'],
      default: []
    }
  };

  var InternalArticleSchema = new substance.DocumentSchema({
    name: 'TextureInternalArticle',
    version: '0.1.0',
    DocumentClass: InternalArticleDocument,
    // ATTENTION: while we have found a solution for defaultTextType of a container
    // this is still necessary because there are more places where schema.getDefaultTextType()
    // is used
    // TODO: try to eliminate this
    defaultTextType: 'paragraph',
    nodes: [
      Abstract,
      Article,
      ArticleAbstractTranslation,
      ArticleRef,
      ArticleTitleTranslation,
      BlockFormula,
      BlockQuote,
      Body,
      Bold,
      BookRef,
      Break,
      ChapterRef,
      ConferencePaperRef,
      CustomMetadataField,
      DataPublicationRef,
      ExternalLink,
      Figure,
      FigurePanel,
      Footnote,
      Funder,
      Group,
      Graphic,
      Heading,
      InlineFormula,
      InlineGraphic,
      Italic,
      JournalArticleRef,
      Keyword,
      List,
      ListItem,
      MagazineArticleRef,
      Metadata,
      Monoscript,
      NewspaperArticleRef,
      Organisation,
      Overline,
      PatentRef,
      Paragraph,
      Permission,
      Person,
      Preformat,
      RefContrib,
      Reference,
      ReportRef,
      SmallCaps,
      SoftwareRef,
      StrikeThrough,
      Subject,
      Subscript,
      Superscript,
      SupplementaryFile,
      Table,
      TableCell,
      TableFigure,
      TableRow,
      ThesisRef,
      Underline,
      UnsupportedInlineNode,
      UnsupportedNode,
      WebpageRef,
      Xref
    ]
  })

  var UnsupportedInlineNodeConverter = {
    type: 'unsupported-inline-node',
    matchElement (el) {
      return false
    },
    import (el, node) {
      node.data = el.serialize();
    },
    export (node, el) {
      return substance.DefaultDOMElement.parseSnippet(node.data, 'xml')
    }
  }

  var UnsupportedNodeConverter = {
    type: 'unsupported-node',
    matchElement (el) {
      return false
    },
    import (el, node) {
      node.data = el.serialize();
    },
    export (node, el) {
      return substance.DefaultDOMElement.parseSnippet(node.data, 'xml')
    }
  }

  class BodyConverter {
    get type () { return 'body' }

    get tagName () { return 'body' }

    import (el, node, importer) {
      let children = el.getChildren();
      let flattened = [];
      for (let child of children) {
        if (child.tagName === 'sec') {
          flattened = flattened.concat(this._flattenSec(child, 1));
        } else {
          flattened.push(child);
        }
      }
      node.content = flattened.map(el => importer.convertElement(el).id);
    }

    _flattenSec (sec, level) {
      let result = [];

      let h = sec.createElement('heading');
      // Note: mapping the section id
      // TODO: what about other attributes?
      h.attr({
        id: sec.attr('id'),
        level
      });
      // ATTENTION: <sec-meta> is not supported
      if (findChild(sec, 'sec-meta')) {
        console.error('<sec-meta> is not supported by <heading> right now.');
      }
      // mapping sec > label to heading[label]
      // TODO: is this really the way we want to do it?
      let label = findChild(sec, 'label');
      if (label) {
        h.attr('label', label.textContent);
        label.remove();
      }
      // The title is essentially the h
      let title = findChild(sec, 'title');
      if (title) {
        h.append(title.childNodes);
        title.remove();
      }
      result.push(h);

      // process the remaining content recursively
      let children = sec.children;
      let L = children.length;
      for (let i = 0; i < L; i++) {
        const child = children[i];
        if (child.tagName === 'sec') {
          result = result.concat(this._flattenSec(child, level + 1));
        } else {
          result.push(child);
        }
      }

      return result
    }

    export (node, el, exporter) {
      let $$ = el.createElement.bind(el);
      const children = node.getNodes();
      let stack = [{ el }];
      for (let child of children) {
        if (child.type === 'heading') {
          let heading = child;
          let level = heading.level;
          while (stack.length >= level + 1) {
            stack.pop();
          }
          let sec = $$('sec').attr({ id: heading.id });
          let title = $$('title');
          title.append(exporter.annotatedText(heading.getPath()));
          sec.appendChild(title);
          substance.last(stack).el.appendChild(sec);
          stack.push({ el: sec });
        } else {
          substance.last(stack).el.appendChild(
            exporter.convertNode(child)
          );
        }
      }
    }

    static instance () {
      if (!this._instance) {
        this._instance = new BodyConverter();
      }
      return this._instance
    }
  }

  class BoldConverter {
    get type () { return 'bold' }

    get tagName () { return 'bold' }
  }

  function getLabel (node) {
    if (node._isModel) {
      node = node._node;
    }
    let label = node.label;
    if (node && node.state) {
      label = node.state.label || label;
    }
    return label
  }

  function getPos (node) {
    let pos;
    if (node && node.state) {
      pos = node.state.pos;
    }
    if (pos === undefined) {
      pos = Number.MAX_VALUE;
    }
    return pos
  }

  function findParentByType (node, type) {
    let parent = node.getParent();
    while (parent) {
      if (parent.isInstanceOf(type)) {
        return parent
      }
      parent = parent.getParent();
    }
  }

  function ifNodeOrRelatedHasChanged (node, change, cb) {
    let doc = node.getDocument();
    let id = node.id;
    let hasChanged = change.hasUpdated(id);
    if (!hasChanged) {
      let relationships = doc.getIndex('relationships');
      // TODO: this could probably be improved by only navigating updated nodes
      let ids = Object.keys(change.updated);
      for (let _id of ids) {
        let related = relationships.get(_id);
        if (related && related.has(id)) {
          hasChanged = true;
          break
        }
      }
    }
    if (hasChanged) cb();
  }

  // ATTENTION: ATM we only allow content-type 'math/tex'
  class BlockFormulaConverter {
    get type () { return 'block-formula' }

    get tagName () { return 'disp-formula' }

    import (el, node, importer) {
      let labelEl = findChild(el, 'label');
      let contentType = el.attr('content-type');
      if (contentType && contentType !== 'math/tex') {
        throw new Error('Only content-type="math/tex" is supported.')
      }
      let contentEl = this._getContent(el);
      if (labelEl) {
        node.label = labelEl.text();
      }
      if (contentEl) {
        node.content = substance.DefaultDOMElement.parseSnippet(contentEl.getInnerXML(), 'xml').getTextContent();
      }
    }

    _getContent (el) {
      return findChild(el, 'tex-math')
    }

    export (node, el, exporter) {
      let $$ = exporter.$$;

      // Note: ATM only math/tex is supported and thus hard-coded here
      el.attr('content-type', 'math/tex');

      let label = getLabel(node);
      if (label) {
        el.append($$('label').text(label));
      }
      if (node.content) {
        const texMath = $$('tex-math');
        texMath.append(texMath.createCDATASection(node.content));
        el.append(
          texMath
        );
      }
    }
  }

  /**
   * A converter for JATS `<disp-quote>`.
   * Our internal model deviates from the original one in that the the attribution is separated from
   * the quote content by using a dedicated text property 'attrib'
   */
  class BlockQuoteConverter {
    get type () { return 'block-quote' }

    get tagName () { return 'disp-quote' }

    import (el, node, importer) {
      let $$ = el.createElement.bind(el.getOwnerDocument());
      let pEls = findAllChildren(el, 'p');
      if (pEls.length === 0) {
        pEls.push($$('p'));
      }
      let attrib = findChild(el, 'attrib');
      if (attrib) {
        node.attrib = importer.annotatedText(attrib, [node.id, 'attrib']);
      }
      node.content = pEls.map(p => {
        return importer.convertElement(p).id
      });
    }

    export (node, el, exporter) {
      let $$ = exporter.$$;
      let content = node.resolve('content');
      el.append(
        content.map(p => {
          return exporter.convertNode(p)
        })
      );
      if (node.attrib) {
        el.append(
          $$('attrib').append(
            exporter.annotatedText([node.id, 'attrib'])
          )
        );
      }
    }
  }

  class BreakConverter {
    get type () { return 'break' }

    get tagName () { return 'break' }
  }

  class FigurePanelConverter {
    get type () { return 'figure-panel' }

    // ATTENTION: figure-panel is represented in JATS
    // instead there is the distinction between fig-group and fig
    // which are represented as Figure in Texture
    get tagName () { return 'fig' }

    import (el, node, importer) {
      let $$ = el.createElement.bind(el.getOwnerDocument());
      let labelEl = findChild(el, 'label');
      let contentEl = this._getContent(el);
      let permissionsEl = findChild(el, 'permissions');
      let captionEl = findChild(el, 'caption');
      let doc = importer.getDocument();
      // Preparations
      if (!captionEl) {
        captionEl = $$('caption');
      }
      let titleEl = findChild(captionEl, 'title');
      if (!titleEl) {
        titleEl = $$('title');
      }
      // drop everything than 'p' from caption
      retainChildren(captionEl, 'p');
      // there must be at least one paragraph
      if (!captionEl.find('p')) {
        captionEl.append($$('p'));
      }
      // EXPERIMENTAL: supporting <supplementary-material> in figure caption
      // in JATS this requires a HACK, wrapping <supplementary-material> into a <p>
      // this implementation is prototypal, i.e. has not been signed off commonly
      this._unwrapDisplayElements(captionEl);

      // Conversion
      if (labelEl) {
        node.label = labelEl.text();
      }
      node.title = importer.annotatedText(titleEl, [node.id, 'title']);
      // content is optional
      // TODO: really?
      if (contentEl) {
        node.content = importer.convertElement(contentEl).id;
      }
      // Note: we are transforming capton content to legend property
      node.legend = captionEl.children.map(child => importer.convertElement(child).id);
      if (permissionsEl) {
        node.permission = importer.convertElement(permissionsEl).id;
      } else {
        node.permission = doc.create({ type: 'permission' }).id;
      }

      // Custom Metadata Fields
      let kwdGroupEls = el.findAll('kwd-group');
      node.metadata = kwdGroupEls.map(kwdGroupEl => {
        let kwdEls = kwdGroupEl.findAll('kwd');
        let labelEl = kwdGroupEl.find('label');
        let name = labelEl ? labelEl.textContent : '';
        let value = kwdEls.map(kwdEl => kwdEl.textContent).join(', ');
        return doc.create({
          type: 'custom-metadata-field',
          name,
          value
        }).id
      });
    }

    _getContent (el) {
      return findChild(el, 'graphic')
    }

    export (node, el, exporter) {
      let $$ = exporter.$$;
      // ATTENTION: this helper retrieves the label from the state
      let label = getLabel(node);
      if (label) {
        el.append($$('label').text(label));
      }
      // Attention: <title> is part of the <caption>
      // Note: we are transforming the content of legend to <caption>
      if (node.title || node.legend) {
        let content = node.resolve('legend');
        let captionEl = $$('caption');
        if (content.length > 0) {
          captionEl.append(
            content.map(p => exporter.convertNode(p))
          );
        }
        if (node.title) {
          // Note: this would happen if title is set, but no caption
          if (!captionEl) captionEl = $$('caption');
          // ATTENTION: wrapping display elements into a <p>
          // Do this before injecting the title
          this._wrapDisplayElements(captionEl);
          captionEl.insertAt(0,
            $$('title').append(
              exporter.annotatedText([node.id, 'title'])
            )
          );
        }
        el.append(captionEl);
      }
      // Custom Metadata Fields
      if (node.metadata.length > 0) {
        let kwdGroupEls = node.resolve('metadata').map(field => {
          let kwdGroupEl = $$('kwd-group').append(
            $$('label').text(field.name)
          );
          let kwdEls = field.value.split(',').map(str => {
            return $$('kwd').text(str.trim())
          });
          kwdGroupEl.append(kwdEls);
          return kwdGroupEl
        });
        el.append(kwdGroupEls);
      }
      if (node.content) {
        el.append(
          exporter.convertNode(node.resolve('content'))
        );
      }
      let permission = node.resolve('permission');
      if (permission && !permission.isEmpty()) {
        el.append(
          exporter.convertNode(permission)
        );
      }
    }

    // EXPERIMENTAL see comment above
    _unwrapDisplayElements (el) {
      let children = el.getChildren();
      let L = children.length;
      for (let i = L - 1; i >= 0; i--) {
        let child = children[i];
        if (child.is('p[specific-use="display-element-wrapper"]')) {
          let children = child.getChildren();
          if (children.length === 1) {
            el.replaceChild(child, children[0]);
          } else {
            console.error('Expecting a single element wrapped in <p>');
          }
        }
      }
    }

    _wrapDisplayElements (el) {
      let children = el.getChildren();
      let L = children.length;
      for (let i = L - 1; i >= 0; i--) {
        let child = children[i];
        if (!child.is('p')) {
          let p = el.createElement('p').attr('specific-use', 'display-element-wrapper').append(child.clone(true));
          el.replaceChild(child, p);
        }
      }
    }
  }

  class FigureConverter {
    get type () { return 'figure' }

    // ATTENTION: this converter will create either a <fig> or a <fig-group>
    // element depending on the number of Figure panels
    get tagName () { return 'figure' }

    matchElement (el, importer) {
      if (el.is('fig') || el.is('fig-group')) {
        // Note: do not use this converter if we are already converting a figure
        let context = importer.state.getCurrentContext();
        // Note: no context is given if the importer is used stand-alone
        return !context || context.converter !== this
      } else {
        return false
      }
    }

    import (el, node, importer) {
      // single panel figure
      let panelIds = [];
      if (el.is('fig')) {
        // HACK: unfortunately the importer reserves the original id
        // but we would like to use it for the first panel
        let figPanelConverter = new FigurePanelConverter();
        let figPanelData = { type: 'figure-panel', id: node.id };
        figPanelConverter.import(el, figPanelData, importer);
        importer._createNode(figPanelData);
        return {
          type: 'figure',
          id: importer.nextId('fig'),
          panels: [figPanelData.id]
        }
      // multi-panel figure
      } else if (el.is('fig-group')) {
        panelIds = el.findAll('fig').map(child => importer.convertElement(child).id);
      }
      node.panels = panelIds;
    }

    export (node, el, exporter) {
      let doc = exporter.getDocument();
      if (node.panels.length === 1) {
        return exporter.convertNode(doc.get(node.panels[0]))
      } else {
        el.tagName = 'fig-group';
        el.attr('id', node.id);
        el.append(node.panels.map(id => exporter.convertNode(doc.get(id))));
        return el
      }
    }
  }

  // TODO: at some point we want to retain the label and determine if the label should be treated as custom
  // or be generated.
  class FootnoteConverter {
    get type () { return 'footnote' }

    get tagName () { return 'fn' }

    // NOTE: we don’t support custom labels at the moment, so we will ignore input from fn > label
    import (el, node, importer) {
      let pEls = findAllChildren(el, 'p');
      node.content = pEls.map(el => importer.convertElement(el).id);
    }

    export (node, el, exporter) {
      const $$ = exporter.$$;
      // We gonna need to find another way for node states. I.e. for labels we will have
      // a hybrid scenario where the labels are either edited manually, and thus we need to record ops,
      // or they are generated without persisting operations (e.g. think about undo/redo, or collab)
      // my suggestion would be to introduce volatile ops, they would be excluded from the DocumentChange, that is stored in the change history,
      // or used for collaborative editing.
      let label = getLabel(node);
      if (label) {
        el.append(
          $$('label').text(label)
        );
      }
      el.append(
        node.resolve('content').map(p => exporter.convertNode(p))
      );
    }
  }

  const MANUSCRIPT_MODE = 'manuscript';
  const PREVIEW_MODE = 'preview';
  const METADATA_MODE = 'metadata';

  // Reference Types
  const JOURNAL_ARTICLE_REF = 'journal-article-ref';
  const BOOK_REF = 'book-ref';
  const CHAPTER_REF = 'chapter-ref';
  const CONFERENCE_PAPER_REF = 'conference-paper-ref';
  const DATA_PUBLICATION_REF = 'data-publication-ref';
  const PATENT_REF = 'patent-ref';
  const ARTICLE_REF = 'article-ref';
  const NEWSPAPER_ARTICLE_REF = 'newspaper-article-ref';
  const MAGAZINE_ARTICLE_REF = 'magazine-article-ref';
  const REPORT_REF = 'report-ref';
  const SOFTWARE_REF = 'software-ref';
  const THESIS_REF = 'thesis-ref';
  const WEBPAGE_REF = 'webpage-ref';

  const JATS_BIBR_TYPES_TO_INTERNAL = {
    'journal': JOURNAL_ARTICLE_REF,
    'book': BOOK_REF,
    'chapter': CHAPTER_REF,
    'confproc': CONFERENCE_PAPER_REF,
    'data': DATA_PUBLICATION_REF,
    'patent': PATENT_REF,
    'article': ARTICLE_REF,
    'newspaper': NEWSPAPER_ARTICLE_REF,
    'magazine': MAGAZINE_ARTICLE_REF,
    'report': REPORT_REF,
    'software': SOFTWARE_REF,
    'thesis': THESIS_REF,
    'webpage': WEBPAGE_REF
  };

  const INTERNAL_BIBR_TYPES_TO_JATS = Object.keys(JATS_BIBR_TYPES_TO_INTERNAL).reduce((map, jatsType) => {
    let internalType = JATS_BIBR_TYPES_TO_INTERNAL[jatsType];
    map[internalType] = jatsType;
    return map
  }, {});

  const JATS_BIBR_TYPES = Object.keys(JATS_BIBR_TYPES_TO_INTERNAL);

  const INTERNAL_BIBR_TYPES = Object.keys(INTERNAL_BIBR_TYPES_TO_JATS);

  const LICENSES = [
    {
      id: 'http://creativecommons.org/licenses/by/4.0/',
      name: 'CC BY 4.0'
    },
    {
      id: 'https://creativecommons.org/licenses/by-sa/2.0/',
      name: 'CC BY-SA 2.0'
    }
  ];

  const CARD_MINIMUM_FIELDS = 3;

  // These are intended to be used for labels (lists, references, etc.)
  const LATIN_LETTERS_LOWER_CASE = 'abcdefghijklmnopqrstuvwxyz';
  const LATIN_LETTERS_UPPER_CASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const ROMAN_NUMBERS = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'XIII', 'XIV', 'XV', 'XVI', 'XVII', 'XVII', 'XIX', 'XX', 'XXI', 'XXII', 'XXIII', 'XXIV', 'XXV', 'XXVI'];
  const ARABIC_NUMBERS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26];
  const SYMBOLS = ((symbols, times) => {
    let res = [];
    for (let n = 1; n <= times; n++) {
      for (let s of symbols) {
        res.push(new Array(n).fill(s).join(''));
      }
    }
    return res
  })(['*', '†', '‡', '¶', '§', '‖', '#'], 4);

  class ElementCitationConverter {
    // Note: this will create different types according to the attributes in the JATS element
    get type () { return 'reference' }

    matchElement (el) {
      return el.is('ref')
    }

    import (el, node, importer) {
      const doc = importer.state.doc;
      let elementCitation = el.find('element-citation');
      if (!elementCitation) {
        throw new Error('<element-citation> is required')
      }
      _importElementCitation(elementCitation, node, doc, importer);
    }

    export (node, el, exporter) {
      el.tagName = 'ref';
      el.append(
        _exportElementCitation(node, exporter)
      );
      return el
    }
  }

  function _importElementCitation (el, node, doc, importer) {
    const type = el.attr('publication-type');
    node.type = JATS_BIBR_TYPES_TO_INTERNAL[type];

    Object.assign(node, {
      assignee: getText(el, 'collab[collab-type=assignee] > named-content'),
      confName: getText(el, 'conf-name'),
      confLoc: getText(el, 'conf-loc'),
      day: getText(el, 'day'),
      edition: getText(el, 'edition'),
      elocationId: getText(el, 'elocation-id'),
      fpage: getText(el, 'fpage'),
      issue: getText(el, 'issue'),
      lpage: getText(el, 'lpage'),
      month: getText(el, 'month'),
      pageCount: getText(el, 'page-count'),
      pageRange: getText(el, 'page-range'),
      partTitle: getText(el, 'part-title'),
      patentCountry: getAttr(el, 'patent', 'country'),
      patentNumber: getText(el, 'patent'),
      publisherLoc: getSeparatedText(el, 'publisher-loc'),
      publisherName: getSeparatedText(el, 'publisher-name'),
      series: getText(el, 'series'),
      uri: getText(el, 'uri'),
      version: getText(el, 'version'),
      volume: getText(el, 'volume'),
      year: getText(el, 'year'),
      accessedDate: getAttr(el, 'date-in-citation', 'iso-8601-date'),
      // identifiers
      accessionId: getText(el, 'pub-id[pub-id-type=accession]'),
      archiveId: getText(el, 'pub-id[pub-id-type=archive]'),
      arkId: getText(el, 'pub-id[pub-id-type=ark]'),
      isbn: getText(el, 'pub-id[pub-id-type=isbn]'),
      doi: getText(el, 'pub-id[pub-id-type=doi]'),
      pmid: getText(el, 'pub-id[pub-id-type=pmid]')
    });

    if (type === 'book' || type === 'report' || type === 'software') {
      node.title = getAnnotatedText(importer, el, 'source', [node.id, 'title']);
    } else {
      node.containerTitle = getText(el, 'source');
      if (type === 'chapter') {
        node.title = getAnnotatedText(importer, el, 'chapter-title', [node.id, 'title']);
      } else if (type === 'data') {
        node.title = getAnnotatedText(importer, el, 'data-title', [node.id, 'title']);
      } else {
        node.title = getAnnotatedText(importer, el, 'article-title', [node.id, 'title']);
      }
    }

    node.authors = _importPersonGroup(el, doc, 'author');
    node.editors = _importPersonGroup(el, doc, 'editor');
    node.inventors = _importPersonGroup(el, doc, 'inventor');
    node.sponsors = _importPersonGroup(el, doc, 'sponsor');
    node.translators = _importPersonGroup(el, doc, 'translator');
  }

  function getAnnotatedText (importer, rootEl, selector, path) {
    let el = rootEl.find(selector);
    if (el) {
      return importer.annotatedText(el, path)
    } else {
      return ''
    }
  }

  function _importPersonGroup (el, doc, type) {
    let groupEl = el.find(`person-group[person-group-type=${type}]`);
    if (groupEl) {
      return groupEl.children.reduce((ids, childEl) => {
        let refContrib = _importRefContrib(doc, childEl);
        if (refContrib) ids.push(refContrib.id);
        return ids
      }, [])
    } else {
      return []
    }
  }

  function _importRefContrib (doc, el) {
    let refContrib = {
      type: 'ref-contrib'
    };
    if (el.tagName === 'name') {
      refContrib.givenNames = getText(el, 'given-names');
      refContrib.name = getText(el, 'surname');
      // TODO: We may want to consider prefix postfix, and mix it into givenNames, or name properties
      // We don't want separate fields because this gets complex/annoying during editing
      // prefix: getText(el, 'prefix'),
      // suffix: getText(el, 'suffix'),
    } else if (el.tagName === 'collab') {
      refContrib.name = getText(el, 'named-content[content-type=name]');
    } else {
      console.warn(`${el.tagName} not supported inside <person-group>`);
      return null
    }
    return doc.create(refContrib)
  }

  function _exportElementCitation (node, exporter) {
    const $$ = exporter.$$;
    const doc = node.getDocument();
    const type = node.type;
    let el = $$('element-citation').attr('publication-type', INTERNAL_BIBR_TYPES_TO_JATS[type]);
    if (node.assignee) {
      el.append(
        $$('collab').attr('collab-type', 'assignee').append(
          $$('named-content').attr({ 'content-type': 'name' }).text(node.assignee)
        )
      );
    }
    el.append(_createTextElement($$, node.confName, 'conf-name'));
    el.append(_createTextElement($$, node.confLoc, 'conf-loc'));
    el.append(_createTextElement($$, node.day, 'day'));
    el.append(_createTextElement($$, node.edition, 'edition'));
    el.append(_createTextElement($$, node.elocationId, 'elocation-id'));
    el.append(_createTextElement($$, node.fpage, 'fpage'));
    el.append(_createTextElement($$, node.issue, 'issue'));
    el.append(_createTextElement($$, node.lpage, 'lpage'));
    el.append(_createTextElement($$, node.month, 'month'));
    el.append(_createTextElement($$, node.pageCount, 'page-count'));
    el.append(_createTextElement($$, node.pageRange, 'page-range'));
    el.append(_createTextElement($$, node.partTitle, 'part-title'));
    el.append(_createTextElement($$, node.patentNumber, 'patent', { 'country': node.patentCountry }));
    el.append(_createMultipleTextElements($$, node.publisherLoc, 'publisher-loc'));
    el.append(_createMultipleTextElements($$, node.publisherName, 'publisher-name'));
    el.append(_createTextElement($$, node.uri, 'uri'));
    el.append(_createTextElement($$, node.accessedDate, 'date-in-citation', { 'iso-8601-date': node.accessedDate }));
    el.append(_createTextElement($$, node.version, 'version'));
    el.append(_createTextElement($$, node.volume, 'volume'));
    el.append(_createTextElement($$, node.year, 'year'));
    // identifiers
    el.append(_createTextElement($$, node.accessionId, 'pub-id', { 'pub-id-type': 'accession' }));
    el.append(_createTextElement($$, node.arkId, 'pub-id', { 'pub-id-type': 'ark' }));
    el.append(_createTextElement($$, node.archiveId, 'pub-id', { 'pub-id-type': 'archive' }));
    el.append(_createTextElement($$, node.isbn, 'pub-id', { 'pub-id-type': 'isbn' }));
    el.append(_createTextElement($$, node.doi, 'pub-id', { 'pub-id-type': 'doi' }));
    el.append(_createTextElement($$, node.pmid, 'pub-id', { 'pub-id-type': 'pmid' }));
    // creators
    el.append(_exportPersonGroup($$, doc, node.authors, 'author'));
    el.append(_exportPersonGroup($$, doc, node.editors, 'editor'));
    el.append(_exportPersonGroup($$, doc, node.inventors, 'inventor'));
    el.append(_exportPersonGroup($$, doc, node.sponsors, 'sponsor'));

    if (type === BOOK_REF || type === REPORT_REF || type === SOFTWARE_REF) {
      el.append(_exportAnnotatedText(exporter, [node.id, 'title'], 'source'));
    } else {
      el.append(_createTextElement($$, node.containerTitle, 'source'));
      if (type === CHAPTER_REF) {
        el.append(
          _exportAnnotatedText(exporter, [node.id, 'title'], 'chapter-title')
        );
      } else if (type === DATA_PUBLICATION_REF) {
        el.append(
          _exportAnnotatedText(exporter, [node.id, 'title'], 'data-title')
        );
      } else {
        el.append(
          _exportAnnotatedText(exporter, [node.id, 'title'], 'article-title')
        );
      }
    }
    return el
  }

  function _exportPersonGroup ($$, doc, contribIds, personGroupType) {
    if (contribIds && contribIds.length > 0) {
      let el = $$('person-group').attr('person-group-type', personGroupType);
      contribIds.forEach(id => {
        let refContribNode = doc.get(id);
        el.append(
          _exportRefContrib($$, refContribNode)
        );
      });
      return el
    }
  }

  function _exportRefContrib ($$, refContrib) {
    let el;
    if (refContrib.givenNames) {
      el = $$('name');
      el.append(_createTextElement($$, refContrib.name, 'surname'));
      el.append(_createTextElement($$, refContrib.givenNames, 'given-names'));
    } else if (refContrib.name) {
      el = $$('collab');
      el.append(_createTextElement($$, refContrib.name, 'named-content', { 'content-type': 'name' }));
    } else {
      console.warn('No content found for refContrib node');
    }
    return el
  }

  function _createTextElement ($$, text, tagName, attrs) {
    if (text) {
      return $$(tagName).append(text).attr(attrs)
    }
  }

  function _exportAnnotatedText (exporter, path, tagName, attrs) {
    const $$ = exporter.$$;
    let text = exporter.getDocument().get(path);
    if (text) {
      return $$(tagName).attr(attrs).append(
        exporter.annotatedText(path)
      )
    }
  }

  function _createMultipleTextElements ($$, text, tagName, attrs) {
    if (text) {
      const textItems = text.split(';');
      return textItems.map(ti => {
        return $$(tagName).append(ti.trim()).attr(attrs)
      })
    }
  }

  class ExternalLinkConverter {
    get type () { return 'external-link' }
    get tagName () { return 'ext-link' }

    import (el, node) {
      let extLinkType = el.getAttribute('ext-link-type');
      if (extLinkType && extLinkType !== 'uri') {
        throw new Error('Only ext-link-type="uri" is supported.')
      }
      let href = el.getAttribute('xlink:href');
      if (href) {
        node.href = href;
      }
    }
    export (node, el) {
      // ATM only 'uri' is supported, and thus hard-coded here
      el.setAttribute('ext-link-type', 'uri');
      el.setAttribute('xlink:href', node.href);
    }
  }

  class GraphicConverter {
    get type () { return 'graphic' }

    get tagName () { return 'graphic' }

    import (el, node) {
      node.mimeType = [el.attr('mimetype'), el.attr('mime-subtype')].join('/');
      node.href = el.attr('xlink:href');
    }

    export (node, el) {
      let mimeData = node.mimeType.split('/');
      el.attr('mimetype', mimeData[0]);
      el.attr('mime-subtype', mimeData[1]);
      el.attr('xlink:href', node.href);
    }
  }

  class HeadingImporter {
    get type () { return 'heading' }
    get tagName () { return 'heading' }
    import (el, node, importer) {
      // Note: attributes are converted automatically
      node.level = parseInt(node.attributes.level, 10);
      node.content = importer.annotatedText(el, [node.id, 'content']);
    }
  }

  class InlineFormulaConverter extends BlockFormulaConverter {
    get type () { return 'inline-formula' }

    get tagName () { return 'inline-formula' }
  }

  class InlineGraphicConverter extends GraphicConverter {
    get type () { return 'inline-graphic' }

    get tagName () { return 'inline-graphic' }
  }

  class ItalicConverter {
    get type () { return 'italic' }

    get tagName () { return 'italic' }
  }

  class MonospaceConverter {
    get type () { return 'monospace' }

    get tagName () { return 'monospace' }
  }

  // TODO: is it possible to assimilate this implementation to '../html/ListConverter'?
  // obviously HTML lists are different w.r.t. to tagNames
  // but very similar to JATS w.r.t. the content
  class ListConverter {
    get type () { return 'list' }

    get tagName () { return 'list' }

    import (el, node, importer) {
      let doc = importer.getDocument();
      let visited = new Set();
      let items = [];
      let config = [];
      this._extractItems(el, config, items, 0, visited);
      // create items
      let itemIds = items.map(item => {
        let { el, level } = item;
        let li = doc.create({
          type: 'list-item',
          id: el.id,
          level: parseInt(level, 10)
        });
        let p = el.find('p');
        if (p) {
          li.content = importer.annotatedText(p, [li.id, 'content']);
          return li.id
        }
        return false
      }).filter(Boolean);
      // populate list
      node.id = el.id;
      node.listType = config.join(',');
      node.items = itemIds;
    }

    _extractItems (el, config, items, level, visited) {
      if (el.is('list-item')) items.push({ el, level });
      if (el.is('list')) {
        let listType = el.attr('list-type') || 'bullet';
        if (!config[level]) config[level] = listType;
        level++;
        visited.add(el);
      }
      el.getChildren().forEach(c => this._extractItems(c, config, items, level, visited));
    }

    // ATTENTION: this is pretty rudimentary still
    export (node, el, exporter) {
      const $$ = exporter.$$;
      let newList = substance.renderListNode(node, (arg) => {
        if (arg === 'ol') {
          return $$('list').attr('list-type', 'order')
        } else if (arg === 'ul') {
          return $$('list').attr('list-type', 'bullet')
        } else if (arg === 'li') {
          return $$('list-item')
        } else {
          let listItem = arg;
          return $$('list-item', { id: arg.id }).append(
            $$('p').append(
              exporter.annotatedText(listItem.getPath())
            )
          )
        }
      });
      newList.id = node.id;
      return newList
    }
  }

  class OverlineConverter {
    get type () { return 'overline' }

    get tagName () { return 'overline' }
  }

  /**
   * A converter for JATS `<p>`.
   */
  class ParagraphConverter {
    get type () { return 'paragraph' }

    get tagName () { return 'p' }

    import (el, node, importer) {
      node.content = importer.annotatedText(el, [node.id, 'content']);
    }

    export (node, el, exporter) {
      el.append(exporter.annotatedText([node.id, 'content']));
    }
  }

  class PermissionsConverter {
    get type () { return 'permission' }

    get tagName () { return 'permissions' }

    import (el, node, importer) {
      // Extract figure permissions
      let copyrightStatementEl = el.find('copyright-statement');
      if (copyrightStatementEl) {
        node.copyrightStatement = copyrightStatementEl.textContent;
      }
      let copyrightYearEl = el.find('copyright-year');
      if (copyrightYearEl) {
        node.copyrightYear = copyrightYearEl.textContent;
      }
      let copyrightHolderEl = el.find('copyright-holder');
      if (copyrightHolderEl) {
        node.copyrightHolder = copyrightHolderEl.textContent;
      }
      // TODO: it would be more natural and explicit to do el.find('ali:license-rec')
      let licenseRefEl = el.find('license_ref');
      if (licenseRefEl) {
        node.license = licenseRefEl.textContent;
      }
      let licenseP = el.find('license > license-p');
      if (licenseP) {
        node.licenseText = importer.annotatedText(licenseP, [node.id, 'licenseText']);
      }
    }

    export (node, el, exporter) {
      let $$ = exporter.$$;
      if (node.copyrightStatement) {
        el.append($$('copyright-statement').append(node.copyrightStatement));
      }
      if (node.copyrightYear) {
        el.append($$('copyright-year').append(node.copyrightYear));
      }
      if (node.copyrightHolder) {
        el.append($$('copyright-holder').append(node.copyrightHolder));
      }
      if (node.license || node.licenseText) {
        let licenseEl = $$('license');
        if (node.license) {
          licenseEl.append(
            $$('ali:license_ref').append(node.license)
          );
        }
        if (node.licenseText) {
          licenseEl.append(
            $$('license-p').append(
              exporter.annotatedText([node.id, 'licenseText'])
            )
          );
        }
        el.append(licenseEl);
      }
    }
  }

  class PreformatConverter {
    get type () { return 'preformat' }

    get tagName () { return 'preformat' }

    import (el, node, importer) {
      let xml = el.getInnerXML();
      node.preformatType = el.getAttribute('preformat-type') || 'code';
      // ATTENTION: trimming the content to avoid extra TEXTNODES
      xml = xml.trim();
      let snippet = substance.DefaultDOMElement.parseSnippet(xml, 'xml');
      // NOTE: trying to find the math source robustly
      // often the content is wrapped with CDATA but is also allowed without
      let content = snippet.getTextContent();
      node.content = content || '';
    }

    export (node, el, exporter) {
      if (node.preformatType) {
        el.setAttribute('preformat-type', node.preformatType);
      }

      if (node.content) {
        // ATTENTION: on export we always create CDATA for sake of simplicity
        // otherwise we woul need to detect if the content contained certain characters (such as '<>')
        el.append(el.createCDATASection(node.content));
      }
    }
  }

  class SmallCapsConverter {
    get type () { return 'small-caps' }

    get tagName () { return 'sc' }
  }

  class StrikeThroughConverter {
    get type () { return 'strike-through' }

    get tagName () { return 'strike' }
  }

  class SubscriptConverter {
    get type () { return 'subscript' }

    get tagName () { return 'sub' }
  }

  class SuperscriptConverter {
    get type () { return 'superscript' }

    get tagName () { return 'sup' }
  }

  class SupplementaryFileConverter {
    get type () { return 'supplementary-file' }

    get tagName () { return 'supplementary-material' }

    import (el, node, importer) {
      let $$ = el.createElement.bind(el.getOwnerDocument());
      let labelEl = findChild(el, 'label');
      let captionEl = findChild(el, 'caption');
      // create a new caption element
      if (!captionEl) {
        captionEl = $$('caption');
      }
      // there must be at least one paragraph
      if (!captionEl.find('p')) {
        captionEl.append($$('p'));
      }
      // drop everything than 'p' from caption
      // TODO: we need contextual RNG restriction for captions
      // otherwise we do not know the exact content of a caption
      retainChildren(captionEl, 'p');
      if (captionEl.getChildCount() === 0) {
        captionEl.append($$('p'));
      }
      if (labelEl) {
        node.label = labelEl.text();
      }
      node.href = el.getAttribute('xlink:href');
      node.remote = _isRemoteFile(node.href);
      let mimetype = el.getAttribute('mimetype');
      let mimeSubtype = el.getAttribute('mime-subtype');
      if (mimetype || mimeSubtype) {
        node.mimetype = [mimetype, mimeSubtype].filter(Boolean).join('/');
      }
      node.legend = captionEl.children.map(child => importer.convertElement(child).id);
    }

    export (node, el, exporter) {
      let $$ = exporter.$$;
      if (node.mimetype) {
        let mimeData = node.mimetype.split('/');
        if (mimeData[0]) {
          el.attr({
            'mimetype': mimeData[0]
          });
        }
        if (mimeData[1]) {
          el.attr({
            'mime-subtype': mimeData[1]
          });
        }
      }
      el.attr({
        'xlink:href': node.href
      });
      let label = getLabel(node);
      if (label) {
        el.append($$('label').text(label));
      }
      if (node.legend && node.legend.length > 0) {
        el.append(
          $$('caption').append(
            node.resolve('legend').map(p => {
              return exporter.convertNode(p)
            })
          )
        );
      }
    }
  }

  function _isRemoteFile (href) {
    return Boolean(/^\w+:\/\//.exec(href))
  }

  class TableConverter {
    get tagName () { return 'table' }

    get type () { return 'table' }

    import (el, node, importer) {
      const doc = importer.state.doc;
      const $$ = (type, props = {}) => doc.create(Object.assign(props, { type }));
      let rows = el.findAll('tr');
      let newRows = rows.map(tr => {
        return {
          id: tr.id,
          children: []
        }
      });
      // ATTENTION: this code is not 'idiomatic' as it does not delegate to converters for children elements
      // and instead creates document nodes on the fly
      for (let i = 0; i < rows.length; i++) {
        let tr = rows[i];
        let newRow = newRows[i];
        let children = tr.getChildren();
        for (let j = 0, k = 0; j < children.length; j++, k++) {
          // skipping spanned cells which is necessary
          // because HTML tables have a sparse representation w.r.t. span
          while (newRow.children[k]) k++;
          let c = children[j];
          let attributes = {};
          if (c.is('th')) attributes.heading = true;
          let rowspan = c.attr('rowspan');
          if (rowspan) {
            rowspan = Math.max(1, parseInt(rowspan, 10));
            if (rowspan > 1) {
              attributes.rowspan = rowspan;
            }
          }
          let colspan = c.attr('colspan');
          if (colspan) {
            colspan = Math.max(1, parseInt(colspan, 10));
            if (colspan > 1) {
              attributes.colspan = colspan;
            }
          }
          // flag all spanned cells so that we can skip them
          _fillSpanned($$, newRows, i, k, rowspan, colspan);
          let cell = $$('table-cell', {
            id: c.id,
            heading: attributes['heading'],
            rowspan: attributes['rowspan'],
            colspan: attributes['colspan'],
            content: importer.annotatedText(c, [c.id, 'content'])
          });
          newRows[i].children[k] = cell;
        }
      }
      node.rows = newRows.map(data => {
        let row = $$('table-row', {
          id: data.id,
          cells: data.children.map(cell => cell.id)
        });
        return row.id
      });
    }

    export (table, el, exporter) {
      const $$ = exporter.$$;
      let htmlTable = $$('table').attr('id', table.id);
      let tbody = $$('tbody');
      let rows = table.resolve('rows');
      let matrix = table.getCellMatrix();
      for (let i = 0; i < rows.length; i++) {
        let row = rows[i];
        let cells = matrix[i];
        let tr = $$('tr').attr('id', row.id);
        for (let j = 0; j < cells.length; j++) {
          let cell = cells[j];
          if (cell.shadowed) continue
          let el = $$(cell.heading ? 'th' : 'td');
          let attributes = { id: cell.id };
          let rowspan = cell.rowspan;
          if (rowspan) {
            if (rowspan > 1) {
              attributes.rowspan = String(rowspan);
            }
          }
          let colspan = cell.colspan;
          if (colspan) {
            if (colspan > 1) {
              attributes.colspan = String(colspan);
            }
          }
          el.attr(attributes);
          el.append(exporter.annotatedText(cell.getPath()));
          tr.append(el);
        }
        tbody.append(tr);
      }
      htmlTable.append(tbody);
      return htmlTable
    }
  }

  function _fillSpanned ($$, newRows, row, col, rowspan, colspan) {
    if (!rowspan && !colspan) return
    if (!rowspan) rowspan = 1;
    if (!colspan) colspan = 1;
    for (let i = row; i < row + rowspan; i++) {
      for (let j = col; j < col + colspan; j++) {
        if (i === row && j === col) continue
        newRows[i].children[j] = $$('table-cell');
      }
    }
  }

  class TableFigureConverter extends FigurePanelConverter {
    get type () { return 'table-figure' }

    get tagName () { return 'table-wrap' }

    import (el, node, importer) {
      super.import(el, node, importer);

      const $$ = el.createElement.bind(el.getOwnerDocument());
      // table-wrap-foot is optional
      const tableWrapFoot = findChild(el, 'table-wrap-foot');
      if (tableWrapFoot) {
        // fn-group is optional
        const fnGroup = findChild(tableWrapFoot, 'fn-group');
        if (fnGroup) {
          let fnEls = fnGroup.findAll('fn');
          node.footnotes = fnEls.map(fnEl => {
            // there must be at least one paragraph
            if (!fnEl.find('p')) {
              fnEl.append($$('p'));
            }
            return importer.convertElement(fnEl).id
          });
        }
      }
    }

    export (node, el, exporter) {
      const $$ = exporter.$$;
      // TODO: if we decide to store attrib and permissions inside the table-wrap-foot
      // then we should not call super here, because <fig> does not have a footer
      el = super.export(node, el, exporter) || el;

      if (node.hasFootnotes()) {
        // export in the same order as displayed
        let footnotes = node.getFootnoteManager().getSortedCitables();
        let tableWrapFoot = $$('table-wrap-foot').append(
          $$('fn-group').append(
            footnotes.map(fn => exporter.convertNode(fn))
          )
        );
        el.append(tableWrapFoot);
      }
    }

    _getContent (el) {
      return findChild(el, 'table')
    }
  }

  class UnderlineConverter {
    get type () { return 'underline' }

    get tagName () { return 'underline' }
  }

  class XrefConverter {
    get type () { return 'xref' }

    get tagName () { return 'xref' }

    import (el, node) {
      node.refType = el.attr('ref-type');
      node.refTargets = (el.attr('rid') || '').split(/\s/);
    }

    export (node, el, exporter) {
      el.attr('ref-type', node.refType);
      el.attr('rid', node.refTargets.join(' '));
      let label = getLabel(node);
      if (label) {
        el.text(label);
      }
    }
  }

  var converters = [
    new BodyConverter(),
    new BoldConverter(),
    new BlockFormulaConverter(),
    new BlockQuoteConverter(),
    new BreakConverter(),
    new ExternalLinkConverter(),
    new FigureConverter(),
    new FigurePanelConverter(),
    new FootnoteConverter(),
    new GraphicConverter(),
    new HeadingImporter(),
    new ElementCitationConverter(),
    new InlineFormulaConverter(),
    new InlineGraphicConverter(),
    new ItalicConverter(),
    new MonospaceConverter(),
    new ListConverter(),
    new OverlineConverter(),
    new ParagraphConverter(),
    new PermissionsConverter(),
    new PreformatConverter(),
    new SmallCapsConverter(),
    new StrikeThroughConverter(),
    new SubscriptConverter(),
    new SuperscriptConverter(),
    new SupplementaryFileConverter(),
    new TableConverter(),
    new TableFigureConverter(),
    new UnderlineConverter(),
    UnsupportedNodeConverter,
    UnsupportedInlineNodeConverter,
    new XrefConverter()
  ]

  function createJatsImporter (doc) {
    // Note: we are applying a hybrid approach, i.e. we create XML importers for the JATS schema
    // but only for those elements which are supported by our internal article schema.
    let jatsSchema = TextureArticleSchema.xmlSchema;
    // HeadingImporter is only used for import, because BodyConverter does an on-the-fly DOM transformation
    // before calling element converters. Thus, in the export direction headings are already transformed into <sec> elements
    let jatsImporter = new _HybridJATSImporter({
      schema: InternalArticleSchema,
      xmlSchema: jatsSchema,
      idAttribute: 'id',
      converters
    });
    // ATTENTION: this looks hacky, but we know what we are doing (hopefully)
    jatsImporter.state.doc = doc;
    return jatsImporter
  }

  class _HybridJATSImporter extends substance.XMLDocumentImporter {
    annotatedText (el, path, options = {}) {
      const state = this.state;
      let context = substance.last(state.contexts);
      // In contrast to the core implementation we want to allow that this is method is used to convert properties
      // with annotated text, outside of a recursive import call
      if (!context) {
        state.pushContext(el.tagName);
      }
      let text = super.annotatedText(el, path, options);
      if (!context) {
        context = state.popContext();
        context.annos.forEach(nodeData => state.doc.create(nodeData));
      }
      return text
    }

    _getConverterForElement (el, mode) {
      let converter = super._getConverterForElement(el, mode);
      if (!converter) {
        if (mode === 'inline') {
          return UnsupportedInlineNodeConverter
        } else {
          return UnsupportedNodeConverter
        }
      }
      return converter
    }

    _createNode (nodeData) {
      let doc = this.state.doc;
      let node = doc.get(nodeData.id);
      if (node) {
        throw new Error('Node already exists')
      }
      return doc.create(nodeData)
    }

    nextId (prefix) {
      // ATTENTION: we gonna use '_' as a prefix for automatically created ids
      // TODO: also do this for nodes created via Document
      let doc = this.state.doc;
      let id = this.state.uuid('_' + prefix);
      while (doc.get(id)) {
        id = this.state.uuid('_' + prefix);
      }
      return id
    }
  }

  /*
    TextureJATs Reference: (Please keep this up-to-date)
    article:
      (
        front,
        body?,
        back?,
      )
    front:
      (
        journal-meta?,    // not supported yet
        article-meta,     // -> metadata and others
        // TODO: define a strict schema here ( why multiple ones? )
        (def-list|list|ack|bio|fn-group|glossary|notes)*
      )
    article-meta:
      (
        article-id*,      // not supported yet
        article-categories?,  //   -> metadata
        title-group?,     // this is not optional internally, at least it contains the main title
        contrib-group*,   // -> mapped to authors, editors, and contributors
        aff*,             // -> affiliations
        author-notes?,    // not supported yet
        pub-date*,        // -> metadata
        volume?,          // -> metadata
        issue?,           // -> metadata
        issue-title?,           // -> metadata
        isbn?,            // -> metadata
        (((fpage,lpage?)?,page-range?)|elocation-id)?,  // -> metadata
        history?,         // -> metadata
        permissions?,     // -> metadata
        self-uri*,        // not supported yet
        (related-article,related-object)*, // not supported yet
        abstract?,        // -> content.abstract
        trans-abstract*,  // -> translations
        kwd-group*,       // -> keywords
        funding-group*,   // not supported yet
        conference*,      // not supported yet
        counts?,          // not supported yet
        custom-meta-group?  // not supported yet
      )
    back:
      (
        label?,   // not supported
        title*, // not supported
        (ack|app-group|bio|fn-group|glossary|ref-list|notes|sec)* // not supported
      )

    TODO:
      Allow only one place for '<ack>', '<bio>', '<fn-group>', '<glossary>', '<notes>'
  */

  function jats2internal (jats, options) {
    let doc = InternalArticleDocument.createEmptyArticle(InternalArticleSchema);
    // this is used to for parts of the DOM where we use JATS in the internal model
    let jatsImporter = createJatsImporter(doc);

    // metadata
    _populateOrganisations(doc, jats);
    _populateAuthors(doc, jats, jatsImporter);
    _populateEditors(doc, jats, jatsImporter);
    _populateFunders(doc, jats);
    _populateArticleInfo(doc, jats, jatsImporter);
    _populateKeywords(doc, jats, jatsImporter);
    _populateSubjects(doc, jats);

    // content
    _populateTitle(doc, jats, jatsImporter);
    _populateSubTitle(doc, jats, jatsImporter);
    _populateAbstract(doc, jats, jatsImporter);
    _populateBody(doc, jats, jatsImporter);
    _populateFootnotes(doc, jats, jatsImporter);
    _populateReferences(doc, jats, jatsImporter);

    return doc
  }

  function _populateOrganisations (doc, jats) {
    const affEls = jats.findAll('article > front > article-meta > aff');
    let orgIds = affEls.map(el => {
      let org = {
        id: el.id,
        type: 'organisation',
        institution: getText(el, 'institution[content-type=orgname]'),
        division1: getText(el, 'institution[content-type=orgdiv1]'),
        division2: getText(el, 'institution[content-type=orgdiv2]'),
        division3: getText(el, 'institution[content-type=orgdiv3]'),
        street: getText(el, 'addr-line[content-type=street-address]'),
        addressComplements: getText(el, 'addr-line[content-type=complements]'),
        city: getText(el, 'city'),
        state: getText(el, 'state'),
        postalCode: getText(el, 'postal-code'),
        country: getText(el, 'country'),
        phone: getText(el, 'phone'),
        fax: getText(el, 'fax'),
        email: getText(el, 'email'),
        uri: getText(el, 'uri[content-type=link]')
      };
      return doc.create(org).id
    });
    doc.set(['metadata', 'organisations'], orgIds);
  }

  function _populateAuthors (doc, jats, importer) {
    let authorEls = jats.findAll(`contrib-group[content-type=author] > contrib`);
    _populateContribs(doc, jats, importer, ['metadata', 'authors'], authorEls);
  }

  function _populateEditors (doc, jats, importer) {
    let editorEls = jats.findAll(`contrib-group[content-type=editor] > contrib`);
    _populateContribs(doc, jats, importer, ['metadata', 'editors'], editorEls);
  }

  function _populateContribs (doc, jats, importer, contribsPath, contribEls, groupId) {
    for (let contribEl of contribEls) {
      if (contribEl.attr('contrib-type') === 'group') {
        // ATTENTION: groups are defined 'inplace'
        // the members of the group are appended to the list of persons
        let group = {
          id: contribEl.id,
          type: 'group',
          name: getText(contribEl, 'named-content[content-type=name]'),
          email: getText(contribEl, 'email'),
          affiliations: _getAffiliationIds(contribEl, true),
          equalContrib: contribEl.getAttribute('equal-contrib') === 'yes',
          corresp: contribEl.getAttribute('corresp') === 'yes',
          funders: _getAwardIds(contribEl)
        };
        substance.documentHelpers.append(doc, ['metadata', 'groups'], doc.create(group).id);

        let memberEls = contribEl.findAll('contrib');
        _populateContribs(doc, jats, importer, contribsPath, memberEls, group.id);
      } else {
        let contrib = doc.create({
          id: contribEl.id,
          type: 'person',
          givenNames: getText(contribEl, 'given-names'),
          surname: getText(contribEl, 'surname'),
          email: getText(contribEl, 'email'),
          alias: getText(contribEl, 'string-name[content-type=alias]'),
          prefix: getText(contribEl, 'prefix'),
          suffix: getText(contribEl, 'suffix'),
          affiliations: _getAffiliationIds(contribEl),
          funders: _getAwardIds(contribEl),
          bio: _getBioContent(contribEl, importer),
          equalContrib: contribEl.getAttribute('equal-contrib') === 'yes',
          corresp: contribEl.getAttribute('corresp') === 'yes',
          deceased: contribEl.getAttribute('deceased') === 'yes',
          group: groupId
        });
        substance.documentHelpers.append(doc, contribsPath, contrib.id);
      }
    }
  }

  // ATTENTION: bio is not a specific node anymore, just a collection of paragraphs
  function _getBioContent (el, importer) {
    let $$ = el.createElement.bind(el.getOwnerDocument());
    let bioEl = findChild(el, 'bio');

    // If there is no bio element we should provide it
    if (!bioEl) {
      bioEl = $$('bio');
    }

    // TODO: this code looks similar to what we have in abstract or and caption
    // drop everything other than 'p' from bio
    retainChildren(bioEl, 'p');
    // there must be at least one paragraph
    if (!bioEl.find('p')) {
      bioEl.append($$('p'));
    }

    return bioEl.children.map(child => importer.convertElement(child).id)
  }

  function _getAffiliationIds (el, isGroup) {
    // let dom = el.ownerDocument
    let xrefs = el.findAll('xref[ref-type=aff]');
    // NOTE: for groups we need to extract only affiliations of group, without members
    if (isGroup) {
      xrefs = el.findAll('collab > xref[ref-type=aff]');
    }
    let affs = xrefs.map(xref => xref.attr('rid'));
    return affs
  }

  function _getAwardIds (el) {
    let xrefs = el.findAll('xref[ref-type=award]');
    let awardIds = xrefs.map(xref => xref.attr('rid'));
    return awardIds
  }

  function _populateFunders (doc, jats) {
    const awardEls = jats.findAll('article > front > article-meta > funding-group > award-group');
    let funderIds = awardEls.map(el => {
      let funder = {
        id: el.id,
        type: 'funder',
        institution: getText(el, 'institution'),
        fundRefId: getText(el, 'institution-id'),
        awardId: getText(el, 'award-id')
      };
      return doc.create(funder).id
    });
    doc.set(['metadata', 'funders'], funderIds);
  }

  // TODO: use doc API for manipulation, not a bare object
  function _populateArticleInfo (doc, jats, jatsImporter) {
    let articleEl = jats.find('article');
    let articleMetaEl = articleEl.find('front > article-meta');
    let metadata = doc.get('metadata');
    Object.assign(metadata, {
      articleType: articleEl.getAttribute('article-type') || '',
      elocationId: getText(articleMetaEl, 'elocation-id'),
      fpage: getText(articleMetaEl, 'fpage'),
      lpage: getText(articleMetaEl, 'lpage'),
      issue: getText(articleMetaEl, 'issue'),
      volume: getText(articleMetaEl, 'volume'),
      pageRange: getText(articleMetaEl, 'page-range')
    });
    let issueTitleEl = findChild(articleMetaEl, 'issue-title');
    if (issueTitleEl) {
      metadata['issueTitle'] = jatsImporter.annotatedText(issueTitleEl, ['metadata', 'issueTtle']);
    }
    // Import permission if present
    const permissionsEl = articleMetaEl.find('permissions');
    // An empty permission is already there, but will be replaced if <permission> element is there
    if (permissionsEl) {
      doc.delete(metadata.permission);
      let permission = jatsImporter.convertElement(permissionsEl);
      // ATTENTION: so that the document model is correct we need to use
      // the Document API  to set the permission id
      metadata.permission = permission.id;
    }

    const articleDateEls = articleMetaEl.findAll('history > date, pub-date');
    if (articleDateEls.length > 0) {
      let dates = {};
      articleDateEls.forEach(dateEl => {
        const date = _extractDate(dateEl);
        dates[date.type] = date.value;
      });
      Object.assign(metadata, dates);
    }
  }

  const DATE_TYPES_MAP = {
    'pub': 'publishedDate',
    'accepted': 'acceptedDate',
    'received': 'receivedDate',
    'rev-recd': 'revReceivedDate',
    'rev-request': 'revRequestedDate'
  };

  function _extractDate (el) {
    const dateType = el.getAttribute('date-type');
    const value = el.getAttribute('iso-8601-date');
    const entityProp = DATE_TYPES_MAP[dateType];
    return {
      value: value,
      type: entityProp
    }
  }

  function _populateKeywords (doc, jats, jatsImporter) {
    let kwdEls = jats.findAll('article > front > article-meta > kwd-group > kwd');
    let kwdIds = kwdEls.map(kwdEl => {
      const kwd = doc.create({
        type: 'keyword',
        category: kwdEl.getAttribute('content-type'),
        language: kwdEl.getParent().getAttribute('xml:lang')
      });
      kwd.name = jatsImporter.annotatedText(kwdEl, [kwd.id, 'name']);
      return kwd.id
    });
    doc.get('metadata').keywords = kwdIds;
  }

  function _populateSubjects (doc, jats) {
    // TODO: IMO we need to consolidate this. The original meaning of <subj-group> seems to be
    // to be able to define an ontology, also hierarchically
    // This implementation assumes that subjects are flat.
    // To support translations, multiple subj-groups can be provided with different xml:lang
    let subjGroups = jats.findAll('article > front > article-meta > article-categories > subj-group');
    // TODO: get this from the article element
    const DEFAULT_LANG = 'en';
    for (let subjGroup of subjGroups) {
      let language = subjGroup.attr('xml:lang') || DEFAULT_LANG;
      let subjectEls = subjGroup.findAll('subject');
      for (let subjectEl of subjectEls) {
        let subject = doc.create({
          type: 'subject',
          name: subjectEl.textContent,
          category: subjectEl.getAttribute('content-type'),
          language
        });
        substance.documentHelpers.append(doc, ['metadata', 'subjects'], subject.id);
      }
    }
  }

  function _populateTitle (doc, jats, jatsImporter) {
    let article = doc.get('article');
    let titleEl = jats.find('article > front > article-meta > title-group > article-title');
    if (titleEl) {
      article.title = jatsImporter.annotatedText(titleEl, ['article', 'title']);
    }
    // translations
    let transTitleEls = jats.findAll('article > front > article-meta > title-group > trans-title-group > trans-title');
    for (let transTitleEl of transTitleEls) {
      let group = transTitleEl.parentNode;
      let language = group.attr('xml:lang');
      let translation = doc.create({
        type: 'article-title-translation',
        id: transTitleEl.id,
        source: ['article', 'title'],
        language
      });
      translation.content = jatsImporter.annotatedText(transTitleEl, translation.getPath());
      substance.documentHelpers.append(doc, ['article', 'translations'], translation.id);
    }
  }

  function _populateSubTitle (doc, jats, jatsImporter) {
    let article = doc.get('article');
    let subTitleEl = jats.find('article > front > article-meta > title-group > subtitle');
    if (subTitleEl) {
      article.subTitle = jatsImporter.annotatedText(subTitleEl, ['article', 'subTitle']);
    }
  }

  function _populateAbstract (doc, jats, jatsImporter) {
    let $$ = jats.createElement.bind(jats);
    let abstract = doc.get('abstract');
    // ATTENTION: JATS can have multiple abstracts
    // ATM we only take the first, loosing the others
    let abstractEls = jats.findAll('article > front > article-meta > abstract');
    if (abstractEls.length > 0) {
      let abstractEl = abstractEls[0];
      if (abstractEls.length > 1) {
        console.error('FIXME: Texture only supports one <abstract>.');
      }
      // if the abstract is empty, add an empty paragraph
      if (abstractEl.getChildCount() === 0) {
        abstractEl.append($$('p'));
      }
      abstract.content = abstractEl.children.map(el => {
        return jatsImporter.convertElement(el).id
      });
    }
    // translations
    let transAbstractEls = jats.findAll('article > front > article-meta > trans-abstract');
    for (let transAbstractEl of transAbstractEls) {
      let language = transAbstractEl.attr('xml:lang');
      let translation = doc.create({
        type: 'article-abstract-translation',
        id: transAbstractEl.id,
        source: [abstract.id, 'content'],
        language,
        content: transAbstractEl.getChildren().map(child => {
          return jatsImporter.convertElement(child).id
        })
      });
      substance.documentHelpers.append(doc, ['article', 'translations'], translation.id);
    }
  }

  function _populateBody (doc, jats, jatsImporter) {
    let $$ = jats.createElement.bind(jats);
    // ATTENTION: JATS can have multiple abstracts
    // ATM we only take the first, loosing the others
    let bodyEl = jats.find('article > body');
    if (bodyEl) {
      // add an empty paragraph if the body is empty
      if (bodyEl.getChildCount() === 0) {
        bodyEl.append($$('p'));
      }
      let body = doc.get('body');
      // ATTENTION: because there is already a body node in the document, *the* body, with id 'body'
      // we must change the id of the body element so that it does not collide with the internal one
      bodyEl.id = substance.uuid();
      let tmp = jatsImporter.convertElement(bodyEl);
      let ids = tmp.content.slice();
      tmp.content = [];
      body.content = ids;
      doc.delete(tmp);
    }
  }

  function _populateFootnotes (doc, jats, jatsImporter) {
    let $$ = jats.createElement.bind(jats);
    let fnEls = jats.findAll('article > back > fn-group > fn');
    let article = doc.get('article');
    article.footnotes = fnEls.map(fnEl => {
      // there must be at least one paragraph
      if (!fnEl.find('p')) {
        fnEl.append($$('p'));
      }
      return jatsImporter.convertElement(fnEl).id
    });
  }

  function _populateReferences (doc, jats, jatsImporter) {
    // TODO: make sure that we only allow this place for references via restricting the TextureJATS schema
    let refListEl = jats.find('article > back > ref-list');
    if (refListEl) {
      let article = doc.get('article');
      let refEls = refListEl.findAll('ref');
      article.references = refEls.map(refEl => jatsImporter.convertElement(refEl).id);
    }
  }

  const EMPTY_JATS = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving DTD v1.0 20120330//EN" "JATS-journalarchiving.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ali="http://www.niso.org/schemas/ali/1.0">
  <front>
    <article-meta>
      <title-group>
        <article-title></article-title>
      </title-group>
      <abstract>
      </abstract>
    </article-meta>
  </front>
  <body>
  </body>
  <back>
  </back>
</article>`;

  function createEmptyJATS () {
    return substance.DefaultDOMElement.parseXML(EMPTY_JATS)
  }

  /**
   * A factory the creates an exporter instance that can be used to convert a full document to JATS
   * but also for converting single nodes.
   *
   * @param {DOMElement} jatsDom
   * @param {InternalArticleDocument} doc
   */
  function createJatsExporter (jatsDom, doc) {
    // ATTENTION: in this case it is different to the importer
    // not the first matching converter is used, but the last one which is
    // registered for a specific nody type, i.e. a later converter overrides a previous one
    let exporter = new Internal2JATSExporter({
      converters,
      elementFactory: {
        createElement: jatsDom.createElement.bind(jatsDom)
      }
    });
    exporter.state.doc = doc;
    return exporter
  }

  class Internal2JATSExporter extends substance.XMLExporter {
    getNodeConverter (node) {
      let type = node.type;
      if (node.isInstanceOf('reference')) {
        type = 'reference';
      }
      return this.converters.get(type)
    }

    // TODO: try to improve the core implementation to allow disabling of defaultBlockConverter
    convertNode (node) {
      if (substance.isString(node)) {
        // Assuming this.state.doc has been set by convertDocument
        node = this.state.doc.get(node);
      } else {
        this.state.doc = node.getDocument();
      }
      var converter = this.getNodeConverter(node);
      // special treatment for annotations, i.e. if someone calls
      // `exporter.convertNode(anno)`
      if (node.isPropertyAnnotation() && (!converter || !converter.export)) {
        return this._convertPropertyAnnotation(node)
      }
      if (!converter) {
        throw new Error(`No converter found for node type '${node.type}'`)
      }
      var el;
      if (converter.tagName) {
        el = this.$$(converter.tagName);
      } else {
        el = this.$$('div');
      }
      el.attr(this.config.idAttribute, node.id);
      if (converter.export) {
        el = converter.export(node, el, this) || el;
      }
      return el
    }
  }

  /*
    Output will have the following form:

    article:
      (
        front,
        body?,
        back?,
      )
    front:
      (
        journal-meta?,    // not supported yet
        article-meta,
        def-list?         // not supported yet
      )
    article-meta:
      (
        article-id*,      // not supported yet
        article-categories?,  // derived from subjects
        title-group?,
        contrib-group*,
        aff*,
        author-notes?,    // not supported yet
        pub-date*,
        volume?,
        issue?,
        isbn?,
        (((fpage,lpage?)?,page-range?)|elocation-id)?,
        history?,
        permissions?,     // not supported yet
        self-uri*,        // not supported yet
        related-article*, // not supported yet
        related-object*,  // not supported yet
        abstract?,
        trans-abstract*,
        kwd-group*,
        funding-group*,   // derived from awards
        conference*,      // not supported yet
        counts?,          // not supported yet
        custom-meta-group?  // not supported yet
      )
    back:
      (
        ack*, // not supported yet
        bio*, // not supported yet
        fn-group?,
        glossary?,  // not supported yet
        ref-list?,
        notes*, // not supported yet
        sec*  // do we want to support this at all?
      )

    TODO:
      Allow only one place for '<ack>', '<bio>', '<fn-group>', '<glossary>', '<notes>'
  */

  function internal2jats (doc) { // eslint-disable-line
    let jats = createEmptyJATS();
    jats.$$ = jats.createElement.bind(jats);

    // we use this exporter for JATS compliant parts of our intneral document
    let jatsExporter = createJatsExporter(jats, doc);

    // metadata
    _populateMeta(jats, doc, jatsExporter);
    _populateBody$1(jats, doc, jatsExporter);
    _populateBack(jats, doc, jatsExporter);

    return jats
  }

  function _populateMeta (jats, doc, jatsExporter) {
    // TODO: journal-meta would go here, but is not supported yet

    // @article-type
    let articleEl = jats.find('article');
    let metadata = doc.get('metadata');
    if (metadata.articleType) {
      articleEl.attr('article-type', metadata.articleType);
    }

    _populateArticleMeta(jats, doc, jatsExporter);

    // TODO: def-list would go here, but is not supported yet
  }

  function _populateArticleMeta (jats, doc, jatsExporter) {
    const $$ = jats.$$;
    let articleMeta = jats.createElement('article-meta');
    let metadata = doc.get('metadata');
    let permission = doc.get(metadata.permission);

    // article-id*
    // TODO not supported yet

    // article-categories?
    articleMeta.append(_exportSubjects(jats, doc));

    // title-group?
    articleMeta.append(_exportTitleGroup(jats, doc, jatsExporter))

    // contrib-group*
    ;[
      ['author', ['metadata', 'authors']],
      ['editor', ['metadata', 'editors']]
    ].forEach(([type, collectionPath]) => {
      articleMeta.append(
        _exportContribGroup(jats, doc, jatsExporter, collectionPath, type)
      );
    });

    // aff*
    articleMeta.append(_exportAffiliations(jats, doc));

    // author-notes? // not supported yet

    // pub-date*,
    articleMeta.append(
      _exportDate($$, metadata, 'publishedDate', 'pub', 'pub-date')
    );

    // volume?,
    if (metadata.volume) {
      articleMeta.append($$('volume').append(metadata.volume));
    }

    // issue?,
    if (metadata.issue) {
      articleMeta.append($$('issue').append(metadata.issue));
    }

    // issue-title?,
    if (metadata.issueTitle) {
      articleMeta.append(
        $$('issue-title').append(
          jatsExporter.annotatedText(['metadata', 'issueTitle'])
        )
      );
    }

    // isbn?, // not supported yet

    // (((fpage,lpage?)?,page-range?)|elocation-id)?,
    if (metadata.elocationId) {
      articleMeta.append(
        $$('elocation-id').append(metadata.elocationId)
      );
    } else if (metadata.fpage && metadata.lpage) {
      // NOTE: last argument is used to resolve insert position, as we don't have means
      // yet to ask for insert position of multiple elements
      let pageRange = metadata.pageRange || metadata.fpage + '-' + metadata.lpage;
      articleMeta.append(
        $$('fpage').append(metadata.fpage),
        $$('lpage').append(metadata.lpage),
        $$('page-range').append(pageRange)
      );
    }

    // history?,
    const historyEl = $$('history');
    historyEl.append(_exportDate($$, metadata, 'acceptedDate', 'accepted'));
    historyEl.append(_exportDate($$, metadata, 'receivedDate', 'received'));
    historyEl.append(_exportDate($$, metadata, 'revReceivedDate', 'rev-recd'));
    historyEl.append(_exportDate($$, metadata, 'revRequestedDate', 'rev-request'));
    // do not export <history> tag if there is no dates inside
    if (historyEl.getChildCount() > 0) {
      articleMeta.append(historyEl);
    }

    // permissions?,
    if (permission && !permission.isEmpty()) {
      articleMeta.append(
        jatsExporter.convertNode(permission)
      );
    }

    // self-uri*,        // not supported yet

    // related-article*, // not supported yet

    // related-object*,  // not supported yet

    // abstract?,
    articleMeta.append(
      _exportAbstract(jats, doc, jatsExporter)
    );

    // trans-abstract*, // not yet supported

    // kwd-group*,
    articleMeta.append(
      _exportKeywords(jats, doc, jatsExporter)
    );

    // funding-group*,
    articleMeta.append(
      _exportFunders(jats, doc)
    );

    // conference*,      // not supported yet

    // counts?,          // not supported yet

    // custom-meta-group?  // not supported yet

    // replace the <article-meta> element
    let front = jats.find('article > front');
    let oldArticleMeta = front.find('article-meta');
    front.replaceChild(oldArticleMeta, articleMeta);
  }

  function _exportSubjects (jats, doc) {
    // NOTE: subjects are used to populate <article-categories>
    // - subjects are organized flat, not hierarchically
    // - `subject.category` is mapped to subject[content-type]
    // - subjects are grouped into <subj-groups> using their language property
    // group subjects by language
    // TODO: this should come from the article node
    let $$ = jats.$$;
    let subjects = doc.resolve(['metadata', 'subjects']);
    let byLang = subjects.reduce((byLang, subject) => {
      let lang = subject.language;
      if (!byLang[lang]) {
        byLang[lang] = [];
      }
      byLang[lang].push(subject);
      return byLang
    }, {});
    let articleCategories = $$('article-categories');
    substance.forEach(byLang, (subjects, lang) => {
      let groupEl = $$('subj-group').attr('xml:lang', lang);
      groupEl.append(
        subjects.map(subject => {
          return $$('subject').attr({ 'content-type': subject.category }).text(subject.name)
        })
      );
      articleCategories.append(groupEl);
    });
    // only return if there have been converted subjects
    if (articleCategories.getChildCount() > 0) {
      return articleCategories
    }
  }

  function _exportTitleGroup (jats, doc, jatsExporter) {
    let $$ = jats.$$;
    // ATTENTION: ATM only title and subtitle is supported
    // JATS supports more titles beyond this (e.g. for special purposes)
    const TITLE_PATH = ['article', 'title'];
    const SUBTITLE_PATH = ['article', 'subTitle'];
    let titleGroupEl = $$('title-group');
    let articleTitle = $$('article-title');
    _exportAnnotatedText$1(jatsExporter, TITLE_PATH, articleTitle);
    titleGroupEl.append(articleTitle);

    // Export subtitle if it's not empty
    if (doc.get(SUBTITLE_PATH)) {
      let articleSubTitle = $$('subtitle');
      _exportAnnotatedText$1(jatsExporter, SUBTITLE_PATH, articleSubTitle);
      titleGroupEl.append(articleSubTitle);
    }

    // translations
    doc.resolve(['article', 'translations']).filter(translation => {
      return substance.isArrayEqual(translation.source, TITLE_PATH)
    }).forEach(translation => {
      titleGroupEl.append(
        $$('trans-title-group').attr({ 'xml:lang': translation.language }).append(
          $$('trans-title').attr({ id: translation.id }).append(
            jatsExporter.annotatedText(translation.getPath())
          )
        )
      );
    });

    return titleGroupEl
  }

  function _exportContribGroup (jats, doc, exporter, collectionPath, type) {
    // FIXME: this should not happen if we have general support for 'person-groups'
    // ATM, we only support authors, and editors.
    let $$ = jats.$$;
    let contribs = doc.resolve(collectionPath);
    let contribGroupEl = $$('contrib-group').attr('content-type', type);
    let groupedContribs = _groupContribs(contribs);
    for (let [groupId, persons] of groupedContribs) {
      // append persons without a group first
      if (groupId === 'NOGROUP') {
        persons.forEach(person => {
          contribGroupEl.append(_exportPerson($$, exporter, person));
        });
      // persons within a group are nested into an extra <contrib> layer
      } else {
        let group = doc.get(groupId);
        contribGroupEl.append(_exportGroup($$, exporter, group, persons));
      }
    }
    if (contribGroupEl.getChildCount() > 0) {
      return contribGroupEl
    }
  }

  /*
    Uses group association of person nodes to create groups

    [p1,p2g1,p3g2,p4g1] => {p1: p1, g1: [p2,p4], g2: [p3] }
  */
  function _groupContribs (contribs) {
    let groups = new Map();
    groups.set('NOGROUP', []);
    for (let contrib of contribs) {
      let groupId = contrib.group;
      if (groupId) {
        if (!groups.has(groupId)) {
          groups.set(groupId, []);
        }
        groups.get(groupId).push(contrib);
      } else {
        groups.get('NOGROUP').push(contrib);
      }
    }
    return groups
  }

  function _exportPerson ($$, exporter, node) {
    let el = $$('contrib').attr({
      'id': node.id,
      'contrib-type': 'person',
      'equal-contrib': node.equalContrib ? 'yes' : 'no',
      'corresp': node.corresp ? 'yes' : 'no',
      'deceased': node.deceased ? 'yes' : 'no'
    });
    el.append(
      $$('name').append(
        _createTextElement$1($$, node.surname, 'surname'),
        _createTextElement$1($$, node.givenNames, 'given-names'),
        _createTextElement$1($$, node.prefix, 'prefix'),
        _createTextElement$1($$, node.suffix, 'suffix')
      ),
      _createTextElement$1($$, node.email, 'email'),
      _createTextElement$1($$, node.alias, 'string-name', { 'content-type': 'alias' }),
      _createBioElement($$, exporter, node)
    );
    node.affiliations.forEach(organisationId => {
      el.append(
        $$('xref').attr('ref-type', 'aff').attr('rid', organisationId)
      );
    });
    node.funders.forEach(funderId => {
      el.append(
        $$('xref').attr('ref-type', 'award').attr('rid', funderId)
      );
    });
    return el
  }

  function _createBioElement ($$, exporter, node) {
    let content = node.resolve('bio');
    if (content.length > 0) {
      // NOTE: we don't want to export empty containers
      // e.g. if there is only one empty paragraph we are not exporting anything
      let first = content[0];
      if (content.length === 1 && first.isText() && first.isEmpty()) {
        return
      }
      let bioEl = $$('bio').append(
        content.map(p => exporter.convertNode(p))
      );
      return bioEl
    }
  }

  function _exportGroup ($$, exporter, node, groupMembers) {
    /*
      <contrib id="${node.id}" contrib-type="group" equal-contrib="yes|no" corresp="yes|no">
        <collab>
          <named-content content-type="name">${node.name}</named-content>
          <email>${node.email}</email>
          <$ for (let affId of node.affiliations) {$>
            <xref ref-type="aff" rid=${affId} />
          <$ } $>
          <$ for (let awardId of node.awards) {$>
            <xref ref-type="award" rid=${awardId} />
          <$ } $>
          <contrib-group contrib-type="group-member">
            <$ for (let person of groupMembers) {$>
              <Person node=${person} />
            <$ } $>
          </contrib-group>
          </collab>
      </contrib>
    */
    let contribEl = $$('contrib').attr({
      'id': node.id,
      'contrib-type': 'group',
      'equal-contrib': node.equalContrib ? 'yes' : 'no',
      'corresp': node.corresp ? 'yes' : 'no'
    });
    let collab = $$('collab');
    collab.append(
      $$('named-content').attr('content-type', 'name').append(node.name),
      $$('email').append(node.email)
    );
    // Adds affiliations to group
    node.affiliations.forEach(organisationId => {
      collab.append(
        $$('xref').attr('ref-type', 'aff').attr('rid', organisationId)
      );
    });
    // Add funders to group
    node.funders.forEach(funderId => {
      collab.append(
        $$('xref').attr('ref-type', 'award').attr('rid', funderId)
      );
    });
    // Add group members
    // <contrib-group contrib-type="group-member">
    let contribGroup = $$('contrib-group').attr('contrib-type', 'group-member');
    groupMembers.forEach(person => {
      let contribEl = _exportPerson($$, exporter, person);
      contribGroup.append(contribEl);
    });
    collab.append(contribGroup);
    contribEl.append(collab);
    return contribEl
  }

  function _exportAffiliations (jats, doc) {
    let $$ = jats.$$;
    let organisations = doc.resolve(['metadata', 'organisations']);
    let orgEls = organisations.map(node => {
      let el = $$('aff').attr('id', node.id);
      el.append(_createTextElement$1($$, node.institution, 'institution', { 'content-type': 'orgname' }));
      el.append(_createTextElement$1($$, node.division1, 'institution', { 'content-type': 'orgdiv1' }));
      el.append(_createTextElement$1($$, node.division2, 'institution', { 'content-type': 'orgdiv2' }));
      el.append(_createTextElement$1($$, node.division3, 'institution', { 'content-type': 'orgdiv3' }));
      el.append(_createTextElement$1($$, node.street, 'addr-line', { 'content-type': 'street-address' }));
      el.append(_createTextElement$1($$, node.addressComplements, 'addr-line', { 'content-type': 'complements' }));
      el.append(_createTextElement$1($$, node.city, 'city'));
      el.append(_createTextElement$1($$, node.state, 'state'));
      el.append(_createTextElement$1($$, node.postalCode, 'postal-code'));
      el.append(_createTextElement$1($$, node.country, 'country'));
      el.append(_createTextElement$1($$, node.phone, 'phone'));
      el.append(_createTextElement$1($$, node.fax, 'fax'));
      el.append(_createTextElement$1($$, node.email, 'email'));
      el.append(_createTextElement$1($$, node.uri, 'uri', { 'content-type': 'link' }));
      return el
    });
    return orgEls
  }

  function _exportDate ($$, node, prop, dateType, tag) {
    const date = node[prop];
    // Do not export a date without value
    if (!date) return

    const tagName = tag || 'date';
    const el = $$(tagName).attr('date-type', dateType)
      .attr('iso-8601-date', date);

    const year = date.split('-')[0];
    const month = date.split('-')[1];
    const day = date.split('-')[2];
    if (_isDateValid(date)) {
      el.append(
        $$('day').append(day),
        $$('month').append(month),
        $$('year').append(year)
      );
    } else if (_isYearMonthDateValid(date)) {
      el.append(
        $$('month').append(month),
        $$('year').append(year)
      );
    } else if (_isYearDateValid(date)) {
      el.append(
        $$('year').append(year)
      );
    }
    return el
  }

  function _isDateValid (str) {
    const regexp = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])$/;
    if (!regexp.test(str)) return false
    return true
  }

  function _isYearMonthDateValid (str) {
    const regexp = /^[0-9]{4}-(0[1-9]|1[0-2])$/;
    if (!regexp.test(str)) return false
    return true
  }

  function _isYearDateValid (str) {
    const regexp = /^[0-9]{4}$/;
    if (!regexp.test(str)) return false
    return true
  }

  function _createTextElement$1 ($$, text, tagName, attrs) {
    if (text) {
      let el = $$(tagName).append(text);
      substance.forEach(attrs, (value, key) => {
        el.attr(key, value);
      });
      return el
    }
  }

  /**
   * @param {DOMElement} jats the JATS DOM to export into
   * @param {Document} doc the document to convert from
   * @param {XMLExporter} jatsExporter an exporter instance used to export nested nodes
   */
  function _exportAbstract (jats, doc, jatsExporter) {
    const $$ = jats.$$;
    let abstract = doc.get('abstract');
    let els = [];

    // <abstract>
    let abstractEl = $$('abstract');
    // the abstract element itself is required
    // but we skip empty content
    if (!_isContainerEmpty(abstract, 'content')) {
      abstract.resolve('content').forEach(p => {
        abstractEl.append(jatsExporter.convertNode(p));
      });
    }
    els.push(abstractEl);

    // translations
    doc.resolve(['article', 'translations']).filter(translation => {
      return substance.isArrayEqual(translation.source, [abstract.id, 'content'])
    }).forEach(translation => {
      if (!_isContainerEmpty(translation, 'content')) {
        let transAbstractEl = $$('trans-abstract').attr({
          id: translation.id,
          'xml:lang': translation.language
        }).append(
          translation.resolve('content').map(child => jatsExporter.convertNode(child))
        );
        els.push(transAbstractEl);
      }
    });

    return els
  }

  function _exportKeywords (jats, doc, jatsExporter) {
    const $$ = jats.$$;
    // TODO: keywords should be translatables
    const keywords = doc.resolve(['metadata', 'keywords']);
    let byLang = keywords.reduce((byLang, keyword) => {
      let lang = keyword.language;
      if (!byLang[lang]) {
        byLang[lang] = [];
      }
      byLang[lang].push(keyword);
      return byLang
    }, {});
    let keywordGroups = [];
    substance.forEach(byLang, (keywords, lang) => {
      let groupEl = $$('kwd-group').attr('xml:lang', lang);
      groupEl.append(
        keywords.map(keyword => {
          return $$('kwd').attr({ 'content-type': keyword.category }).append(
            jatsExporter.annotatedText([keyword.id, 'name'])
          )
        })
      );
      keywordGroups.push(groupEl);
    });
    return keywordGroups
  }

  function _exportFunders (jats, doc) {
    const $$ = jats.$$;
    let funders = doc.resolve(['metadata', 'funders']);
    if (funders.length > 0) {
      let fundingGroupEl = $$('funding-group');
      funders.forEach(funder => {
        let el = $$('award-group').attr('id', funder.id);
        let institutionWrapEl = $$('institution-wrap');
        institutionWrapEl.append(_createTextElement$1($$, funder.fundRefId, 'institution-id', { 'institution-id-type': 'FundRef' }));
        institutionWrapEl.append(_createTextElement$1($$, funder.institution, 'institution'));
        el.append(
          $$('funding-source').append(institutionWrapEl),
          _createTextElement$1($$, funder.awardId, 'award-id')
        );
        fundingGroupEl.append(el);
      });
      return fundingGroupEl
    }
  }

  function _populateBody$1 (jats, doc, jatsExporter) {
    let body = doc.get('body');
    if (!_isContainerEmpty(body, 'content')) {
      let bodyEl = jatsExporter.convertNode(body);
      let oldBody = jats.find('article > body');
      oldBody.parentNode.replaceChild(oldBody, bodyEl);
    }
  }

  function _populateBack (jats, doc, jatsExporter) {
    let $$ = jats.$$;
    let backEl = jats.find('article > back');
    /*
      back:
      (
        fn-group?,
        ref-list?,
      )
    */
    let footnotes = doc.resolve(['article', 'footnotes']);
    if (footnotes.length > 0) {
      backEl.append(
        $$('fn-group').append(
          footnotes.map(footnote => {
            return jatsExporter.convertNode(footnote)
          })
        )
      );
    }

    let references = doc.resolve(['article', 'references']);
    if (references.length > 0) {
      backEl.append(
        $$('ref-list').append(
          references.map(ref => {
            return jatsExporter.convertNode(ref)
          })
        )
      );
    }
  }

  function _exportAnnotatedText$1 (jatsExporter, path, el) {
    el.append(jatsExporter.annotatedText(path));
  }

  function _isContainerEmpty (node, propertyName) {
    let ids = node[propertyName];
    if (ids.length === 0) return true
    if (ids.length > 1) return false
    let doc = node.getDocument();
    let first = doc.get(ids[0]);
    return first && first.isText() && !first.getText()
  }

  function validateXML (xmlSchema, dom, options = {}) {
    let root = dom.find(xmlSchema.getStartElement());
    let allowNotImplemented = true;
    if (options.hasOwnProperty('allowNotImplemented')) {
      allowNotImplemented = Boolean(options.allowNotImplemented);
    }
    if (!root) {
      return {
        errors: [{
          msg: 'Start element is missing.',
          el: dom
        }]
      }
    } else {
      return validateElement(xmlSchema, root, { allowNotImplemented })
    }
  }

  function validateElement (xmlSchema, el, options) {
    const allowNotImplemented = options.allowNotImplemented;
    let errors = [];
    let valid = true;
    let q = [el];
    while (q.length > 0) {
      let next = q.shift();
      let elementSchema = xmlSchema.getElementSchema(next.tagName);
      if (!elementSchema) continue
      if (!allowNotImplemented && elementSchema.type === 'not-implemented') {
        errors.push({
          msg: `<${next.tagName}> is not implemented yet.`,
          el: next.parentNode
        });
        valid = false;
      }
      let res = xmlSchema.validateElement(next);
      if (!res.ok) {
        errors = errors.concat(res.errors);
        valid = false;
      }
      if (next.isElementNode()) {
        q = q.concat(next.getChildren());
      }
    }
    return {
      errors: errors,
      ok: valid
    }
  }

  class JATSImporter extends substance.EventEmitter {
    import (xml, options = {}) {
      let state = {
        dom: null,
        errors: {
          'parse': [],
          'validate-jats': [],
          'jats2restrictedJats': [],
          'validate-texture-article': [],
          'jats2internal': []
        },
        hasErrored: false
      };

      if (substance.isString(xml)) {
        try {
          state.dom = substance.DefaultDOMElement.parseXML(xml);
        } catch (err) {
          console.error('Could not parse XML:', err);
          this._error(state, 'parse', {
            msg: String(err)
          });
          return
        }
      } else if (xml._isDOMElement) {
        state.dom = xml;
      }

      if (!this._validate(JATS, state)) return state

      // JATS -> restricted JATS (= TextureArticleSchema)
      if (!this._transform('jats2restrictedJats', state)) return state

      if (!this._validate(TextureArticleSchema, state, options)) return state

      // restrictedJATS -> InternalArticle
      if (!this._transform('jats2internal', state)) return state

      return state
    }

    _validate (schema, state, options) {
      const name = schema.getName();
      const channel = `validate-${name}`;
      let res = validateXML(schema, state.dom, options);
      if (!res.ok) {
        res.errors.forEach((err) => {
          this._error(state, channel, err);
        });
        return false
      }
      return true
    }

    _transform (mode, state) {
      const api = this._createAPI(state, mode);
      let dom = state.dom;
      switch (mode) {
        case 'jats2restrictedJats':
          jats2restrictedJats(dom, api);
          break
        case 'jats2internal':
          state.doc = jats2internal(dom, api);
          break
        default:
          //
      }
      return true
    }

    _createAPI (state, channel) {
      const self = this;
      let api = {
        error (data) {
          self._error(state, channel, data);
        }
      };
      return api
    }

    _error (state, channel, err) {
      state.hasErrored = true;
      state.errors[channel].push(err);
    }
  }

  class JATSExporter {
    /*
      Takes a InternalArticle document as a DOM and transforms it into a JATS document,
      following TextureArticle guidelines.
    */
    export (doc) {
      let jats = internal2jats(doc);
      let res = substance.validateXMLSchema(TextureArticleSchema, jats);
      if (!res.ok) {
        res.errors.forEach((err) => {
          console.error(err.msg, err.el);
        });
      }
      return {
        jats,
        ok: res.ok,
        errors: res.errors
      }
    }
  }

  const IMPL = Symbol('__AppStateImpl__');

  class AbstractAppState {
    constructor (...args) {
      this[IMPL] = new AppStateImpl();

      this._initialize(...args);
      this._reset();
    }

    _initialize () {
      // nothing to initialize on this level
    }

    dispose () {}

    isDirty (name) {
      return this._getImpl().isDirty(name)
    }

    get (name) {
      return this._getImpl().get(name)
    }

    set (name, value, propagateImmediately) {
      const impl = this._getImpl();
      let oldVal = impl.get(name);
      let hasChanged;
      if (substance.isObject(value)) {
        hasChanged = true;
      } else {
        hasChanged = oldVal !== value;
      }
      if (hasChanged) {
        impl.set(name, value);
        impl.setDirty(name);
        if (propagateImmediately) {
          this.propagateUpdates();
        }
      }
    }

    getUpdate (name) {
      return this._getImpl().getUpdate(name)
    }

    addObserver (deps, handler, observer, options = {}) { // eslint-disable-line no-unused-vars
      throw new Error('This method is abstract.')
    }

    removeObserver (observer) { // eslint-disable-line no-unused-vars
      throw new Error('This method is abstract.')
    }

    off (observer) {
      this.removeObserver(observer);
    }

    propagateUpdates () {
      throw new Error('This method is abstract.')
    }

    _getImpl () {
      return this[IMPL]
    }

    _addProperty (name, initialValue) {
      const impl = this._getImpl();
      if (impl.has(name)) {
        throw new Error(`State variable '${name}' is already declared.`)
      }
      impl.set(name, initialValue);
      Object.defineProperty(this, name, {
        configurable: false,
        enumerable: false,
        get: () => { return this.get(name) },
        set: (value) => { this.set(name, value); }
      });
    }

    // TODO: we should not need this on the long run
    // for now we use it to allow some hackz
    _setDirty (name) {
      this._getImpl().setDirty(name);
    }

    _setUpdate (name, update) {
      const impl = this._getImpl();
      impl.setUpdate(name, update);
      impl.setDirty(name);
    }

    _reset () {
      this._getImpl().reset();
    }
  }

  class AppStateImpl {
    constructor () {
      this.id = substance.uuid();
      this.values = new Map();
      this.dirty = {};
      this.updates = {};
    }

    get (name) {
      return this.values.get(name)
    }

    set (name, newValue) {
      this.values.set(name, newValue);
    }

    has (name) {
      return this.values.has(name)
    }

    setDirty (name) {
      this.dirty[name] = true;
    }

    isDirty (name) {
      return Boolean(this.dirty[name])
    }

    getUpdate (name) {
      return this.updates[name]
    }

    setUpdate (name, update) {
      this.updates[name] = update;
    }

    reset () {
      this.dirty = {};
      this.updates = {};
    }
  }

  const ANY = '@any';
  const STAGES = ['update', 'pre-render', 'render', 'post-render', 'position', 'finalize'];
  const DEFAULT_STAGE = 'update';
  const STAGE_IDX = STAGES.reduce((m, s, idx) => {
    m[s] = idx;
    return m
  }, {});

  class AppState extends AbstractAppState {
    _initialize (initialState) {
      super._initialize();

      const impl = this._getImpl();
      impl.slots = new Map();
      impl.schedule = null;
      impl.isFlowing = false;

      const names = Object.keys(initialState);
      names.forEach(name => {
        const initialValue = initialState[name];
        this._addProperty(name, initialValue);
      });
    }

    addObserver (deps, handler, observer, options = {}) {
      if (substance.isNil(handler)) throw new Error('Provided handler function is nil')
      if (!substance.isFunction(handler)) throw new Error('Provided handler is not a function')
      handler = handler.bind(observer);

      const impl = this._getImpl();
      const ID = impl.id;
      if (!options.stage) options.stage = DEFAULT_STAGE;
      const stage = options.stage;
      const slotId = this._getSlotId(stage, deps.slice());
      let slot = impl.slots.get(slotId);
      if (!slot) {
        slot = this._createSlot(slotId, stage, deps);
        impl.slots.set(slotId, slot);
      }
      if (!observer[ID]) observer[ID] = new Map();
      slot.addObserver(observer, {
        stage,
        deps,
        handler,
        options
      });
    }

    removeObserver (observer) {
      const impl = this._getImpl();
      const ID = impl.id;
      let entries = observer[ID] || [];
      entries.forEach(e => {
        e.slot.removeObserver(observer);
      });
      delete observer[ID];
    }

    propagateUpdates () {
      const impl = this._getImpl();
      if (impl.isFlowing) throw new Error('Already updating.')
      impl.isFlowing = true;
      try {
        const schedule = this._getSchedule();
        for (let slot of schedule) {
          if (slot.needsUpdate()) {
            slot.notifyObservers();
          }
        }
        this._reset();
      } finally {
        impl.isFlowing = false;
      }
    }

    _getSlotId (stage, deps) {
      deps.sort();
      return `@${stage}:${deps.join(',')}`
    }

    _createSlot (id, stage, deps) {
      const impl = this._getImpl();
      impl.schedule = null;
      return new Slot(this, id, stage, deps)
    }

    // order slots by stage
    _getSchedule () {
      const impl = this._getImpl();
      let schedule = impl.schedule;
      if (!schedule) {
        schedule = [];
        impl.slots.forEach(s => schedule.push(s));
        schedule.sort((a, b) => STAGE_IDX[a.stage] - STAGE_IDX[b.stage]);
        impl.schedule = schedule;
      }
      return schedule
    }

    _isUpdating () {
      return this._getImpl().isFlowing
    }

    _reset () {
      super._reset();
      this._setDirty(ANY);
    }
  }

  class Slot {
    constructor (appState, id, stage, deps) {
      this._id = appState._getImpl().id;
      this.id = id;
      this.appState = appState;
      this.stage = stage;
      this.deps = deps;

      this.observers = new Set();
    }

    addObserver (observer, spec) {
      observer[this._id].set(this.id, {
        slot: this,
        spec
      });
      this.observers.add(observer);
    }

    removeObserver (observer) {
      this._deleteEntry(observer);
      this.observers.delete(observer);
    }

    needsUpdate () {
      const state = this.appState;
      for (let dep of this.deps) {
        if (state.isDirty(dep)) return true
      }
      return false
    }

    notifyObservers () {
      let observers = this._getObservers();
      for (let o of observers) {
        let entry = this._getEntryForObserver(o);
        // observer might have been disposed in the meantime
        if (!entry) continue
        this._notifyObserver(entry);
      }
    }

    _getObservers () {
      return this.observers
    }

    _getEntryForObserver (observer) {
      let map = observer[this._id];
      if (map) {
        return map.get(this.id)
      }
    }

    _deleteEntry (observer) {
      let map = observer[this._id];
      if (map) {
        map.delete(this.id);
      }
    }

    _notifyObserver (entry) {
      entry.spec.handler();
    }
  }

  function createComponentContext (config) {
    return {
      componentRegistry: config.getComponentRegistry(),
      toolRegistry: config.getToolRegistry(),
      labelProvider: config.getLabelProvider(),
      iconProvider: config.getIconProvider()
    }
  }

  function createEditorContext (config, editorSession, editor) {
    return Object.assign(createComponentContext(config), {
      config,
      editor,
      editorSession: editorSession,
      appState: editorSession.editorState,
      surfaceManager: editorSession.surfaceManager,
      markersManager: editorSession.markersManager,
      globalEventHandler: editorSession.globalEventHandler,
      keyboardManager: editorSession.keyboardManager,
      findAndReplaceManager: editorSession.findAndReplaceManager,
      // TODO: I'd like to move towards 'config', instead of configurator
      // because it is a configurator only during configuration
      // In the app we want to have a configuration.
      // FIXME: Substance.Surface assumes to find context.configurator
      configurator: config
    })
  }

  // kind of an index that is used to dispatch updates
  class DocumentObserver {
    constructor (doc) {
      this.doc = doc;
      this.dirty = new Set();

      this.init();
    }

    init () {
      const doc = this.doc;
      this.dirty.clear();
      if (!doc.getIndex('relationships')) {
        doc.addIndex('relationships', new RelationshipIndex());
      }
      doc.on('document:changed', this._onDocumentChanged, this);
    }

    dispose () {
      this.doc.off(this);
    }

    // called by EditorState when updates have been propagated
    reset () {
      this.dirty = new Set();
    }

    setDirty (path) {
      this.dirty.add(substance.getKeyForPath(path));
    }

    // TODO: this is built on top of the current implementation of
    // DocumentChange. We could try to consolidate and have just
    // one place where this information is derived
    _onDocumentChanged (change) {
      let dirty = this.dirty;
      Object.keys(change.updated).forEach(id => {
        dirty.add(id);
      });
    }
  }

  const ONE = Symbol('ONE');
  const MANY = Symbol('MANY');

  class RelationshipIndex extends substance.NodeIndex {
    constructor () {
      super();
      // a mapping from type to relational properties
      this._relationsByType = {};
      // the inverse index
      this._byTarget = new ValuesById();
    }

    get (targetId) {
      return this._byTarget.get(targetId)
    }

    select (node) { // eslint-disable-line no-unused-vars
      return true
    }

    clear () {
      this._byTarget.clear();
    }

    create (node) { // eslint-disable-line no-unused-vars
      let relations = this._getRelations(node);
      if (!relations) return
      for (let [name, type] of relations) {
        const val = node[name];
        if (!val) continue
        if (type === ONE) {
          this._add(val, node.id);
        } else {
          val.forEach(targetId => this._add(targetId, node.id));
        }
      }
    }

    delete (node) {
      let relations = this._getRelations(node);
      if (!relations) return
      for (let [name, type] of relations) {
        const val = node[name];
        if (!val) continue
        if (type === ONE) {
          this._remove(val, node.id);
        } else {
          val.forEach(targetId => this._remove(targetId, node.id));
        }
      }
    }

    update (node, path, newValue, oldValue) {
      let relations = this._getRelations(node);
      if (!relations) return
      let type = relations.get(path[1]);
      if (!type) return
      if (type === ONE) {
        this._remove(oldValue, node.id);
        this._add(newValue, node.id);
      } else {
        oldValue.forEach(targetId => this._remove(targetId, node.id));
        newValue.forEach(targetId => this._add(targetId, node.id));
      }
    }

    _getRelations (node) {
      let relations = this._relationsByType[node.type];
      if (relations === undefined) {
        relations = getRelations(node);
        if (relations.size === 0) relations = false;
        this._relationsByType[node.type] = relations;
      }
      return relations
    }

    _add (targetId, sourceId) {
      this._byTarget.add(targetId, sourceId);
    }

    _remove (targetId, sourceId) {
      this._byTarget.remove(targetId, sourceId);
    }
  }

  function getRelations (node) {
    let relations = new Map();
    let nodeSchema = node.getSchema();
    for (let property of nodeSchema) {
      if (property.isReference()) {
        const name = property.name;
        const type = property.isArray() ? MANY : ONE;
        relations.set(name, type);
      }
    }
    return relations
  }

  class ValuesById {
    constructor () {
      this._index = new Map();
    }
    get (key) {
      return this._index.get(key)
    }
    add (key, val) {
      let vals = this._index.get(key);
      if (!vals) {
        vals = new Set();
        this._index.set(key, vals);
      }
      vals.add(val);
    }
    remove (key, val) {
      let vals = this._index.get(key);
      if (vals) {
        vals.delete(val);
        if (vals.size === 0) {
          this._index.delete(key);
        }
      }
    }
    clear () {
      this._index = new Map();
    }
  }

  class SelectionStateReducer {
    constructor (appState) {
      this.appState = appState;
      appState.addObserver(['document', 'selection'], this.update, this, { stage: 'update' });
    }

    update () {
      const appState = this.appState;
      let doc = appState.get('document');
      let sel = appState.get('selection');
      let newState = this.deriveState(doc, sel);
      appState.set('selectionState', newState);
    }

    deriveState (doc, sel) {
      let state = this.createState(sel);
      this.deriveContext(state, doc, sel);
      this.deriveContainerSelectionState(state, doc, sel);
      this.deriveAnnoState(state, doc, sel);
      if (doc.getIndex('markers')) {
        this.deriveMarkerState(state, doc, sel);
      }
      return state
    }

    deriveContext (state, doc, sel) {
      if (!sel || sel.isNull()) return
      if (sel.isPropertySelection() || sel.isNodeSelection() || sel.isCustomSelection()) {
        let nodeId = sel.getNodeId();
        let node = doc.get(nodeId);
        if (node) {
          state.xpath = node.getXpath().toArray();
          state.node = node;
        }
      }
    }

    deriveContainerSelectionState (state, doc, sel) {
      let containerPath = sel.containerPath;
      if (containerPath) {
        state.containerPath = containerPath;
        let nodeIds = doc.get(containerPath);
        let startId = sel.start.getNodeId();
        let endId = sel.end.getNodeId();
        let startNode = substance.documentHelpers.getContainerRoot(doc, containerPath, startId);
        // FIXME: it happened that we have set the containerPath incorrectly
        // e.g. body.content for a selection in abstract
        if (!startNode) {
          console.error('FIXME: invalid ContainerSelection');
          return
        }
        let startPos = startNode.getPosition();
        if (startPos > 0) {
          state.previousNode = substance.documentHelpers.getPreviousNode(doc, containerPath, startPos);
        }
        state.isFirst = substance.selectionHelpers.isFirst(doc, containerPath, sel.start);
        let endPos;
        if (endId === startId) {
          endPos = startPos;
        } else {
          let endNode = substance.documentHelpers.getContainerRoot(doc, containerPath, endId);
          endPos = endNode.getPosition();
        }
        if (endPos < nodeIds.length - 1) {
          state.nextNode = substance.documentHelpers.getNextNode(doc, containerPath, endPos);
        }
        state.isLast = substance.selectionHelpers.isLast(doc, containerPath, sel.end);
      }
    }

    deriveAnnoState (state, doc, sel) {
      // create a mapping by type for the currently selected annotations
      // create a mapping by type for the currently selected annotations
      let annosByType = {};
      function _add (anno) {
        if (!annosByType[anno.type]) {
          annosByType[anno.type] = [];
        }
        annosByType[anno.type].push(anno);
      }
      const propAnnos = substance.documentHelpers.getPropertyAnnotationsForSelection(doc, sel);
      propAnnos.forEach(_add);
      if (propAnnos.length === 1 && propAnnos[0].isInlineNode()) {
        state.isInlineNodeSelection = propAnnos[0].getSelection().equals(sel);
      }
      const containerPath = sel.containerPath;
      if (containerPath) {
        const containerAnnos = substance.documentHelpers.getContainerAnnotationsForSelection(doc, sel, containerPath);
        containerAnnos.forEach(_add);
      }
      state.annosByType = annosByType;
    }

    deriveMarkerState (state, doc, sel) {
      let markers = substance.documentHelpers.getMarkersForSelection(doc, sel);
      state.markers = markers;
    }

    createState (sel) {
      return new SelectionState(sel)
    }
  }

  class SelectionState {
    constructor (sel) {
      this.selection = sel || substance.Selection.null;

      Object.assign(this, {
        // all annotations under the current selection
        annosByType: null,
        // markers under the current selection
        markers: null,
        // flags for inline nodes
        isInlineNodeSelection: false,
        // container information (only for ContainerSelection)
        containerPath: null,
        previousNode: null,
        nextNode: null,
        // if the previous node is one char away
        isFirst: false,
        // if the next node is one char away
        isLast: false,
        // current context
        xpath: []
      });
    }
  }

  const ANY$1 = '@any';
  const NOP = new substance.DocumentChange({
    ops: [],
    info: { action: 'nop' }
  });

  class EditorState extends AppState {
    _initialize (initialState) {
      super._initialize(initialState);

      if (!initialState.document) {
        throw new Error("'document' is required")
      }
      let doc = initialState.document;
      let impl = this._getImpl();
      // EXPERIMENTAL:
      // one observer for all slots that watches for document changes and marks paths as dirty
      // this is also used to broadcast other node based changes such as node state updates
      let documentObserver = new DocumentObserver(doc);
      impl.documentObserver = documentObserver;

      let selectionStateReducer = new SelectionStateReducer(this);
      selectionStateReducer.update();
      impl._selectionStateReducer = selectionStateReducer;
    }

    // Call this to revitalise a previously disposed editor state
    init () {
      this._getImpl().documentObserver.init();
    }

    dispose () {
      super.dispose();

      this._getImpl().documentObserver.dispose();
    }

    getUpdate (name) {
      let update = super.getUpdate(name);
      // HACK: sometimes we fake a document change to trigger document observers
      // In this case, there might be no actual update (change and info)
      // and we provide a NOP change and empty info
      if (!update && name === 'document') {
        let change = NOP;
        change._extractInformation();
        update = { change, info: change.info };
      }
      return update
    }

    _createSlot (id, stage, deps) {
      const impl = this._getImpl();
      impl.schedule = null;
      if (deps.indexOf('document') !== -1) {
        return new DocumentSlot(this, id, stage, deps, impl.documentObserver)
      } else {
        return new Slot$1(this, id, stage, deps)
      }
    }

    _reset () {
      super._reset();
      this._getImpl().documentObserver.reset();
    }

    _getDocumentObserver () {
      return this._getImpl().documentObserver
    }
  }

  class Slot$1 {
    constructor (editorState, id, stage, deps) {
      this._id = editorState._getImpl().id;
      this.id = id;
      this.editorState = editorState;
      this.stage = stage;
      this.deps = deps;

      this.observers = new Set();
    }

    addObserver (observer, spec) {
      observer[this._id].set(this.id, {
        slot: this,
        spec
      });
      this.observers.add(observer);
    }

    removeObserver (observer) {
      this._deleteEntry(observer);
      this.observers.delete(observer);
    }

    needsUpdate () {
      const state = this.editorState;
      for (let dep of this.deps) {
        if (state.isDirty(dep)) return true
      }
      return false
    }

    notifyObservers () {
      let observers = this._getObservers();
      for (let o of observers) {
        let entry = this._getEntryForObserver(o);
        // observer might have been disposed in the meantime
        if (!entry) continue
        this._notifyObserver(entry);
      }
    }

    _getObservers () {
      return this.observers
    }

    _getEntryForObserver (observer) {
      let entries = observer[this._id];
      if (entries) {
        return entries.get(this.id)
      }
    }

    _deleteEntry (observer) {
      let entries = observer[this._id];
      if (entries) {
        entries.delete(this.id);
      }
    }

    _getDocumentChange () {
      let { change, info } = this._updates['document'];
      change.info = info;
      return change
    }

    _notifyObserver (entry) {
      const state = this.editorState;
      let spec = entry.spec;
      // TODO: we want to drop this auto-arguments completely
      // after having switched to a pure AppState based implementation
      // i.e. without using observers via EditorSession
      if (spec.deps.length === 1) {
        let name = spec.deps[0];
        switch (name) {
          case 'document': {
            let update = state.getUpdate('document') || {};
            spec.handler(update.change, update.info);
            break
          }
          default:
            spec.handler(state.get(name));
        }
      } else {
        spec.handler();
      }
    }
  }

  class DocumentSlot extends Slot$1 {
    constructor (editorState, id, stage, deps, documentObserver) {
      super(editorState, id, stage, deps);

      this.documentObserver = documentObserver;
      this.byPath = { '@any': new Set() };
    }

    addObserver (observer, spec) {
      super.addObserver(observer, spec);

      const index = this.byPath;
      let docSpec = spec.options.document;
      if (docSpec && docSpec.path) {
        let key = substance.getKeyForPath(docSpec.path);
        let records = index[key];
        if (!records) {
          records = index[key] = new Set();
        }
        records.add(observer);
      } else {
        index[ANY$1].add(observer);
      }
    }

    removeObserver (observer) {
      const entries = observer[this._id];
      if (entries) {
        const entry = entries.get(this.id);
        const index = this.byPath;
        super.removeObserver(observer);
        let docSpec = entry.spec.options.document;
        if (docSpec && docSpec.path) {
          let key = substance.getKeyForPath(docSpec.path);
          let records = index[key];
          records.delete(observer);
        } else {
          index[ANY$1].delete(observer);
        }
      }
    }

    _getObservers () {
      const state = this.editorState;
      if (!state.isDirty('document')) return this.observers

      // notify all observers that are affected by the change
      const index = this.byPath;
      let { change } = state.getUpdate('document');

      if (!change) {
        console.error('FIXME: expected to find a document change as update for document');
        return index[ANY$1]
      }

      let updated = this.documentObserver.dirty;
      let sets = [];
      // observers without a path spec are registered with path=undefined
      sets.push(index[ANY$1]);
      updated.forEach(id => {
        let set = index[id];
        if (set) sets.push(set);
      });
      let observers = new Set();
      sets.forEach(s => {
        s.forEach(o => observers.add(o));
      });
      return observers
    }
  }

  const DEBUG = false;

  class SurfaceManager {
    constructor (editorState) {
      this.editorState = editorState;
      this.surfaces = new Map();

      editorState.addObserver(['selection', 'document'], this._onSelectionOrDocumentChange, this, { stage: 'post-render' });
      editorState.addObserver(['selection', 'document'], this._scrollSelectionIntoView, this, { stage: 'finalize' });
    }

    dispose () {
      this.editorState.off(this);
    }

    getSurface (name) {
      if (name) {
        return this.surfaces.get(name)
      }
    }

    getFocusedSurface () {
      console.error("DEPRECATED: use 'context.editorState.focusedSurface instead");
      return this.editorState.focusedSurface
    }

    registerSurface (surface) {
      const id = surface.getId();
      if (DEBUG) console.log(`Registering surface ${id}.`, surface.__id__);
      if (this.surfaces.has(id)) {
        throw new Error(`A surface with id ${id} has already been registered.`)
      }
      this.surfaces.set(id, surface);
    }

    unregisterSurface (surface) {
      let id = surface.getId();
      if (DEBUG) console.log(`Unregistering surface ${id}.`, surface.__id__);
      let registeredSurface = this.surfaces.get(id);
      if (registeredSurface === surface) {
        this.surfaces.delete(id);
      }
    }

    // TODO: would be good to have an index of surfaces by path
    _getSurfaceForProperty (path) {
      // first try the canonical one
      let canonicalId = substance.getKeyForPath(path);
      if (this.surfaces.has(canonicalId)) {
        return this.surfaces.get(canonicalId)
      }
      for (let surface of this.surfaces.values()) {
        let surfacePath = (
          surface.getContainerPath ? surface.getContainerPath() : (
            surface.getPath ? surface.getPath() : null
          )
        );
        if (surfacePath && substance.isArrayEqual(path, surfacePath)) {
          return surface
        }
      }
    }

    _onSelectionOrDocumentChange () {
      // console.log('SurfaceManager._onSelectionChange()')

      // Reducing state.focusedSurface (only if selection has changed)
      if (this.editorState.isDirty('selection')) {
        const selection = this.editorState.selection;
        // update state.focusedSurface
        this._reduceFocusedSurface(selection);
        // HACK: removing DOM selection *and* blurring when having a CustomSelection
        // otherwise we will receive events on the wrong surface
        // instead of bubbling up to GlobalEventManager
        if (selection && selection.isCustomSelection() && substance.platform.inBrowser) {
          window.getSelection().removeAllRanges();
          window.document.activeElement.blur();
        }
      }

      // TODO: this still needs to be improved. The DOM selection can be affected by other updates than document changes
      this._recoverDOMSelection();
    }

    _reduceFocusedSurface (sel) {
      const editorState = this.editorState;
      let surface = null;
      if (sel && sel.surfaceId) {
        surface = this.surfaces.get(sel.surfaceId);
      }
      editorState.focusedSurface = surface;
    }

    /*
      At the end of the update flow, make sure the surface is focused
      and displays the right DOM selection
    */
    _recoverDOMSelection () {
      // console.log('SurfaceManager._recoverDOMSelection()')
      const editorState = this.editorState;
      // do not rerender the selection if the editorSession has
      // been blurred, e.g., while some component, such as Find-And-Replace
      // dialog has the focus
      if (editorState.isBlurred) return
      let focusedSurface = editorState.focusedSurface;
      // console.log('focusedSurface', focusedSurface)
      if (focusedSurface && !focusedSurface.isDisabled()) {
        // console.log('Rendering selection on surface', focusedSurface.getId(), this.editorState.selection.toString())
        focusedSurface._focus();
        focusedSurface.rerenderDOMSelection();
      }
    }

    _scrollSelectionIntoView () {
      const editorState = this.editorState;
      let focusedSurface = editorState.focusedSurface;
      if (focusedSurface && !focusedSurface.isDisabled()) {
        focusedSurface.send('scrollSelectionIntoView');
      }
    }
  }

  class MarkersManager extends substance.EventEmitter {
    constructor (editorState) {
      super();

      this._editorState = editorState;
      this._markers = new MarkersIndex();

      editorState.addObserver(['document'], this._onDocumentChange, this, { stage: 'update' });
    }

    dispose () {
      this._editorState.removeObserver(this);
    }

    addMarker (marker) {
      let path = marker.getPath();
      this._markers.add(path, marker);
      this._setDirty(path);
    }

    removeMarker (marker) {
      let path = marker.getPath();
      this._markers.remove(path, marker);
      this._setDirty(path);
    }

    clearMarkers (path, filter) {
      this._markers.clearMarkers(path, filter);
      this._setDirty(path);
    }

    getMarkers (path) {
      return this._markers.get(path)
    }

    _getDocumentObserver () {
      return this._editorState._getDocumentObserver()
    }

    _setDirty (path) {
      this._editorState._setDirty('document');
      this._getDocumentObserver().setDirty(path);
    }

    // updating markers to reflect changes on the text they are bound to
    _onDocumentChange (change) {
      for (let op of change.ops) {
        if (op.type === 'update' && op.diff._isTextOperation) {
          let markers = this._markers.get(op.path);
          if (!markers || markers.length === 0) continue
          let diff = op.diff;
          switch (diff.type) {
            case 'insert':
              markers.forEach(m => this._transformInsert(m, diff));
              break
            case 'delete':
              markers.forEach(m => this._transformDelete(m, diff));
              break
            default:
            //
          }
        }
      }
    }

    _transformInsert (marker, op) {
      const pos = op.pos;
      const length = op.str.length;
      if (length === 0) return
      // console.log('Transforming marker after insert')
      let start = marker.start.offset;
      let end = marker.end.offset;
      let newStart = start;
      let newEnd = end;
      if (pos >= end) return
      if (pos <= start) {
        newStart += length;
        newEnd += length;
        marker.start.offset = newStart;
        marker.end.offset = newEnd;
        return
      }
      if (pos < end) {
        newEnd += length;
        marker.end.offset = newEnd;
        // NOTE: right now, any change inside a marker
        // removes the marker, as opposed to changes before
        // which shift the marker
        this._remove(marker);
      }
    }

    _transformDelete (marker, op) {
      const pos1 = op.pos;
      const length = op.str.length;
      const pos2 = pos1 + length;
      if (pos1 === pos2) return
      var start = marker.start.offset;
      var end = marker.end.offset;
      var newStart = start;
      var newEnd = end;
      if (pos2 <= start) {
        newStart -= length;
        newEnd -= length;
        marker.start.offset = newStart;
        marker.end.offset = newEnd;
      } else if (pos1 >= end) ; else {
        if (pos1 <= start) {
          newStart = start - Math.min(pos2 - pos1, start - pos1);
        }
        if (pos1 <= end) {
          newEnd = end - Math.min(pos2 - pos1, end - pos1);
        }
        // TODO: we should do something special when the change occurred inside the marker
        if (start !== end && newStart === newEnd) {
          this._remove(marker);
          return
        }
        if (start !== newStart) {
          marker.start.offset = newStart;
        }
        if (end !== newEnd) {
          marker.end.offset = newEnd;
        }
        this._remove(marker);
      }
    }

    _remove (marker) {
      this.removeMarker(marker);
    }
  }

  // TODO: move getKeyForPath() into substance land, and change ArrayTree implementation to use it
  class MarkersIndex {
    add (path, val) {
      let key = substance.getKeyForPath(path);
      if (!this[key]) {
        this[key] = [];
      }
      this[key].push(val);
    }
    remove (path, val) {
      let key = substance.getKeyForPath(path);
      if (this[key]) {
        substance.deleteFromArray(this[key], val);
      }
    }
    get (path) {
      let key = substance.getKeyForPath(path);
      return this[key] || []
    }
    clearMarkers (path, filter) {
      let key = substance.getKeyForPath(path);
      let arr = this[key];
      if (arr) {
        for (let i = arr.length - 1; i >= 0; i--) {
          if (filter(arr[i])) {
            arr.splice(i, 1);
          }
        }
      }
    }
  }

  class GlobalEventHandler extends substance.AbstractGlobalEventHandler {
    constructor (editorState) {
      super();

      this.editorState = editorState;
    }

    getSelection () {
      return this.editorState.selection
    }
  }

  class KeyboardManager extends substance.AbstractKeyboardManager {
    constructor (bindings, commandCallback, contextProvider) {
      super();

      this.contextProvider = contextProvider;
      this.bindings = {};

      bindings.forEach(({ key, spec }) => {
        if (!spec.command) throw new Error("'spec.command' is required")
        let hook = () => {
          return commandCallback(spec.command)
        };
        const type = spec.type || 'keydown';
        if (type !== 'textinput') {
          key = substance.parseKeyEvent(substance.parseKeyCombo(key));
        }
        // initializing on-the-fly
        if (!this.bindings[type]) { this.bindings[type] = {}; }
        if (!this.bindings[type][key]) { this.bindings[type][key] = []; }
        this.bindings[type][key].push(hook);
      });
    }

    _getBindings (type, key) {
      let bindingsByType = this.bindings[type];
      if (bindingsByType) {
        return bindingsByType[key]
      }
    }

    _getContext () {
      return this.contextProvider.context
    }
  }

  class CommandManager {
    constructor (appState, deps, commands, contextProvider) {
      this.appState = appState;
      this.commands = commands;
      this.contextProvider = contextProvider;

      appState.addObserver(deps, this.reduce, this, { stage: 'update' });
    }

    dispose () {
      this.appState.off(this);
    }

    reduce () {
      const appState = this.appState;
      const commandStates = this._getCommandStates();
      appState.set('commandStates', commandStates);
    }

    _getCommandStates () {
      const context = this.contextProvider.context;
      const params = new substance.HandlerParams(context);
      return this.commands.reduce((m, command) => {
        m[command.getName()] = command.getCommandState(params, context);
        return m
      }, {})
    }

    executeCommand (commandName, params = {}) {
      const appState = this.appState;
      const cmdState = appState.commandStates[commandName];
      if (!cmdState || cmdState.disabled) {
        return false
      } else {
        const cmd = this.commands.get(commandName);
        const context = this.contextProvider.context;
        params = Object.assign(new substance.HandlerParams(context), params);
        params.commandState = cmdState;
        cmd.execute(params, context);
        return true
      }
    }
  }

  const DISABLED = Object.freeze({
    disabled: true
  });

  /*
    Experimental CommandManager that makes use of the XML schema
    to inhibit commands which are not allowed at the current position.
  */
  class SchemaDrivenCommandManager extends CommandManager {
    constructor (...args) {
      super(...args);

      this._initialize();
    }

    _initialize () {
      // EXPERIMENTAL: categorizing commands to be able to disable commands according to schema rules
      const annotationCommands = [];
      const insertCommands = [];
      const switchTypeCommands = [];
      const otherCommands = [];
      this.commands.forEach(command => {
        if (command.isAnnotationCommand()) {
          annotationCommands.push(command);
        } else if (command.isInsertCommand()) {
          insertCommands.push(command);
        } else if (command.isSwitchTypeCommand()) {
          switchTypeCommands.push(command);
        } else {
          otherCommands.push(command);
        }
      });
      this._annotationCommands = annotationCommands;
      this._insertCommands = insertCommands;
      this._switchTypeCommands = switchTypeCommands;
      this._otherCommands = otherCommands;

      this._allDisabled = _disabled(Array.from(this.commands.values()));
    }

    _getCommandStates () {
      const context = this.contextProvider.context;
      const appState = context.appState;
      const params = new substance.HandlerParams(context);
      const doc = appState.document;
      const sel = appState.selection;
      const selectionState = appState.selectionState;
      const isBlurred = appState.isBlurred;
      const noSelection = !sel || sel.isNull() || !sel.isAttached();

      const commandStates = Object.assign({}, this._allDisabled);
      // all editing commands are disabled if
      // - this editorSession is blurred,
      // - or the selection is null,
      // - or the selection is inside a custom editor
      if (!isBlurred && !noSelection && !sel.isCustomSelection()) {
        const path = sel.start.path;
        const node = doc.get(path[0]);

        // TODO: is this really necessary. It rather seems to be
        // a workaround for other errors, i.e., the selection pointing
        // to a non existing node
        // If really needed we should document why, and in which case.
        if (!node) {
          throw new Error('FIXME: explain when this happens')
        }

        const nodeProp = _getNodeProp(node, path);
        const isInsideText = nodeProp ? nodeProp.isText() : false;

        // annotations can only be applied on PropertySelections inside
        // text, and not on an inline-node
        if (isInsideText && sel.isPropertySelection() && !selectionState.isInlineNodeSelection) {
          let targetTypes = nodeProp.targetTypes || [];
          Object.assign(commandStates, _disabledIfDisallowedTargetType(this._annotationCommands, targetTypes, params, context));
        }

        // for InsertCommands the selection must be inside a ContainerEditor
        let containerPath = selectionState.containerPath;
        if (containerPath) {
          let containerProp = doc.getProperty(containerPath);
          if (containerProp) {
            let targetTypes = containerProp.targetTypes || [];
            Object.assign(commandStates, _disabledIfDisallowedTargetType(this._insertCommands, targetTypes, params, context));
            Object.assign(commandStates, _disabledIfDisallowedTargetType(this._switchTypeCommands, targetTypes, params, context));
          }
        }
      }

      // other commands must check their own preconditions
      Object.assign(commandStates, _getCommandStates(this._otherCommands, params, context));

      return commandStates
    }
  }

  function _getNodeProp (node, path) {
    if (path.length === 2) {
      let propName = substance.last(path);
      let prop = node.getSchema().getProperty(propName);
      if (!prop) console.error('Could not find property for path', path, node);
      return prop
    }
  }

  function _disabled (commands) {
    return commands.reduce((m, c) => {
      m[c.getName()] = DISABLED;
      return m
    }, {})
  }

  function _disabledIfDisallowedTargetType (commands, targetTypes, params, context) {
    return commands.reduce((m, cmd) => {
      const type = cmd.getType();
      const name = cmd.getName();
      if (targetTypes.indexOf(type) > -1) {
        m[name] = cmd.getCommandState(params, context);
      } else {
        m[name] = DISABLED;
      }
      return m
    }, {})
  }

  function _getCommandStates (commands, params, context) {
    return commands.reduce((m, command) => {
      m[command.getName()] = command.getCommandState(params, context);
      return m
    }, {})
  }

  const UPDATE_DELAY = 200;

  class FindAndReplaceManager {
    constructor (editorSession, appState, editor) {
      this._editorSession = editorSession;
      this._doc = editorSession.getDocument();
      this._appState = appState;
      this._editor = editor;
      this._dirty = new Set();

      // Note: this is debounced to avoid slow down while typing by running searches too eagerly
      // Only for testing search updates are done synchronously
      this._updateSearchDebounced = substance.debounce(this._updateSearch.bind(this, true), UPDATE_DELAY);

      // during update stage we watch for changes on properties with matches
      // to keep the internal state up2date
      appState.addObserver(['document'], this._onUpdate, this, { stage: 'update' });
      // HACK: without this we see strange errors. As a temporary fix leave it here
      // but should try tor find the source of the problem ASAP
      appState.addObserver(['document'], this._onRender, this, { stage: 'render' });
    }

    openDialog (enableReplace) {
      enableReplace = Boolean(enableReplace);
      let state = this._getState();
      if (state.enabled) {
        // update state if 'showReplace' has changed
        if (state.showReplace !== enableReplace) {
          state.showReplace = Boolean(enableReplace);
          this._updateState(state);
        }
      } else {
        state.enabled = true;
        state.showReplace = Boolean(enableReplace);
        // resetting dirty flags as we do a full search initially
        this._dirty = new Set();
        this._performSearch();
      }
      this._propgateUpdates();
    }

    closeDialog () {
      let state = this._getState();
      if (!state.enabled) return
      state.enabled = false;
      this._clearHighlights();
      // Note: recovering the selection here
      this._updateState(state, 'recoverSelection');
      this._propgateUpdates();
    }

    next () {
      this._next();
      this._propgateUpdates();
    }

    previous () {
      let state = this._getState();
      this._nav('back');
      this._updateState(state);
      this._propgateUpdates();
    }

    setSearchPattern (pattern) {
      let state = this._getState();
      if (state.pattern !== pattern) {
        state.pattern = pattern;
        this._performSearch();
        this._propgateUpdates();
      }
    }

    setReplacePattern (replacePattern) {
      let state = this._getState();
      if (state.replacePattern !== replacePattern) {
        state.replacePattern = replacePattern;
        this._updateState(state);
        this._propgateUpdates();
      }
    }

    replaceNext () {
      let state = this._getState();
      // ATTENTION: special handling after manual changes, while search dialog is open
      // in this case we do a forced 'next()' when using 'replaceNext()'
      if (state._forceNav) {
        state._forceNav = false;
        this._next();
        return
      }
      if (state.replacePattern) {
        let hasReplaced = false;
        if (state.cursor >= 0) {
          let m = this._getMatchAt(state.cursor);
          if (m) {
            this._editorSession.transaction(tx => {
              this._replace(tx, m, state);
            }, { action: 'replace' });
            // ATTENTION: we are not changing the search result on changes with action type: 'replace'
            // Instead we are doing it here manually:
            // updating the result for the current text property
            // and propagating changes so that so that text properties are updated
            this._updateSearchForProperty(substance.getKeyForPath(m.path));
            this._appState.propagateUpdates();
            // set the cursor back and scroll to the next
            state.cursor--;
            this._nav('forward');
            this._updateState(state);
            hasReplaced = true;
          }
        }
        if (!hasReplaced) {
          // otherwise seek to the next match position first
          this._next();
        }
        this._propgateUpdates();
      }
    }

    replaceAll () {
      let state = this._getState();
      if (!state.matches) return
      let allMatches = [];
      state.matches.forEach(_matches => {
        allMatches = allMatches.concat(_matches);
      });
      this._editorSession.transaction(tx => {
        for (let idx = allMatches.length - 1; idx >= 0; idx--) {
          this._replace(tx, allMatches[idx], state);
        }
      }, { action: 'replace-all' });
      state.matches = new Map();
      state.count = 0;
      state.cursor = -1;
      this._updateState(state);
      this._propgateUpdates();
    }

    toggleCaseSensitivity () {
      this._toggleOption('caseSensitive');
      this._propgateUpdates();
    }

    toggleRegexSearch () {
      this._toggleOption('regexSearch');
      this._propgateUpdates();
    }

    toggleFullWordSearch () {
      this._toggleOption('fullWord');
      this._propgateUpdates();
    }

    _getMarkersManager () {
      return this._editorSession.markersManager
    }

    _getState () {
      return this._appState.get('findAndReplace') || FindAndReplaceManager.defaultState()
    }

    _toggleOption (optionName) {
      let state = this._getState();
      state[optionName] = !state[optionName];
      this._performSearch();
    }

    _performSearch () {
      let state = this._getState();
      if (state.pattern) {
        this._searchAndHighlight();
      } else {
        this._clear();
      }
      state.cursor = -1;
      this._updateState(state);
      // ATTENTION: scrolling to the first match (if available)
      // this needs to be done after rolling out the state update
      // so that the markers have been rendered already
      if (state.count > 0) {
        this._next();
      }
    }

    _next () {
      let state = this._getState();
      this._nav('forward');
      this._updateState(state);
    }

    _updateState (state, recoverSelection) {
      const appState = this._appState;
      // HACK: touching appState.selection because we want that the applications recovers the selection
      if (recoverSelection) {
        appState._setDirty('selection');
      }
      // console.log('Updating appState.findAndReplace', state)
      appState.set('findAndReplace', state);
    }

    _propgateUpdates () {
      let appState = this._appState;
      // TODO: we need to figure out if this is a problem
      // only in tests this is called synchronously
      // leading to extra updates e.g. when the content is changed while
      // the FNR dialog is open
      if (!appState._isUpdating()) {
        this._appState.propagateUpdates();
      }
    }

    _searchAndHighlight () {
      // re-start the search
      this._clearHighlights();
      this._search();
      this._addHighlights();
      this._propgateUpdates();
    }

    _search () {
      let state = this._getState();
      let matches = new Map();
      let count = 0;
      let pattern = state.pattern;
      let opts = state;
      if (pattern) {
        let tps = this._getTextProperties();
        for (let tp of tps) {
          // console.log('... searching for matches in ', tp.getPath())
          let _matches = this._searchInProperty(tp, pattern, opts);
          // if (_matches.length > 0) console.log('found %s matches', _matches.length)
          count += _matches.length;
          if (_matches.length > 0) {
            matches.set(substance.getKeyForPath(tp.getPath()), _matches);
          }
        }
      }
      state.matches = matches;
      state.count = count;
    }

    _updateSearch (propagate) {
      let state = this._getState();
      if (!state.enabled || !state.pattern || this._dirty.size === 0) return

      for (let key of this._dirty) {
        // ATTENTION: this updates state.count
        this._updateSearchForProperty(key);
      }
      // HACK: need to make sure that the selection is recovered here
      this._updateState(state, 'recoverSelection');
      this._dirty = new Set();
      if (propagate) {
        this._propgateUpdates();
      }
    }

    _updateSearchForProperty (key) {
      let markersManager = this._getMarkersManager();
      let state = this._getState();
      let matches = state.matches;
      let count = state.count;
      let _matches = matches.get(key);
      if (_matches) {
        count -= _matches.length;
      }
      let path = key.split('.');
      markersManager.clearMarkers(path, m => m.type === 'find-marker');
      let tp = this._getTextProperty(key);
      if (tp) {
        _matches = this._searchInProperty(tp, state.pattern, state);
        count += _matches.length;
        matches.set(key, _matches);
        this._addHighlightsForProperty(path, _matches);
      } else {
        matches.delete(key);
      }
      state.count = count;
    }

    _searchInProperty (tp, pattern, opts) {
      let path = tp.getPath();
      return _findInText(tp.getText(), pattern, opts).map(m => {
        // add an id so that we can find it later, e.g. for scroll-to
        m.id = substance.uuid();
        m.path = path;
        m.textProperty = tp;
        return m
      })
    }

    /*
      In case of a regexp search the replacement string allows for the following patterns
      - "$$": Inserts a "$".
      - "$&": Inserts the matched substring.
      - "$`": Inserts the portion of the string that precedes the matched substring.
      - "$'": Inserts the portion of the string that follows the matched substring.
      - "$n": Where n is a positive integer less than 100, inserts the nth parenthesized submatch string, provided the first argument was a RegExp object. Note that this is 1-indexed.
    */
    _replace (tx, m, options) {
      tx.setSelection({
        type: 'property',
        path: m.path,
        startOffset: m.start,
        endOffset: m.end
      });
      let newText;
      // TODO: we should allow to use regex in replace string too
      // for that we would take the string from the match
      // and apply native String replace to g
      if (options.regexSearch) {
        let text = substance.documentHelpers.getTextForSelection(tx, tx.selection);
        let findRe = new RegExp(options.pattern);
        newText = text.replace(findRe, options.replacePattern);
      } else {
        newText = options.replacePattern;
      }
      tx.insertText(newText);
    }

    _clear () {
      let state = this._getState();
      this._clearHighlights();
      state.matches = new Map();
      state.count = 0;
    }

    _clearHighlights () {
      const markersManager = this._getMarkersManager();
      const state = this._getState();
      if (state.matches) {
        state.matches.forEach((_, key) => {
          let path = key.split('.');
          markersManager.clearMarkers(path, m => m.type === 'find-marker');
        });
      }
    }

    _addHighlights () {
      const state = this._getState();
      if (state.matches) {
        state.matches.forEach((matches, key) => {
          let path = key.split('.');
          this._addHighlightsForProperty(path, matches);
        });
      }
    }

    // TODO: don't know yet how we want to update Markers incrementally
    _addHighlightsForProperty (path, matches) {
      let markersManager = this._getMarkersManager();
      matches.forEach(m => {
        markersManager.addMarker(new substance.Marker(this._doc, {
          type: 'find-marker',
          id: m.id,
          start: {
            path,
            offset: m.start
          },
          end: {
            path,
            offset: m.end
          }
        }));
      });
    }

    _getTextProperties () {
      // EXPERIMENTAL: we need to retrieve all *editable* text properties in the correct order
      // which is not possible just from the model (without further knowledge)
      // However, doing it via DOM search is probably rather slow
      return this._editor.getContentPanel().findAll('.sc-text-property')
    }

    _getTextProperty (id) {
      // EXPERIMENTAL: same as _getTextProperties()
      return this._editor.getContentPanel().find(`.sc-text-property[data-path="${id}"]`)
    }

    _nav (direction) {
      let state = this._getState();
      let [cursor, match] = this._getNext(direction);
      if (match) {
        state.cursor = cursor;
        this._scrollToMatch(match);
      }
    }

    _getNext (direction) {
      // TODO: support a selection relative navigation
      // as a first iteration we will do this independently from the selection
      let state = this._getState();
      let idx;
      if (direction === 'forward') {
        idx = Math.min(state.count - 1, state.cursor + 1);
      } else {
        idx = Math.max(0, state.cursor - 1);
      }
      return [ idx, this._getMatchAt(idx) ]
    }

    _getMatchAt (idx) {
      // Note: because we are storing matching grouped by properties
      // this is a but nasty
      let state = this._getState();
      if (state.matches) {
        for (let [, matches] of state.matches) {
          if (idx >= matches.length) {
            idx -= matches.length;
          } else {
            return matches[idx]
          }
        }
      }
    }

    _scrollToMatch (match) {
      let state = this._getState();
      // HACKIDHACK: instead of relying on rerendering, we toggle the hightlight here
      // which is also much faster, and still pretty safe, because we throw markers on every change
      if (state.marker) state.marker.el.removeClass('sm-active');
      let tp = match.textProperty;
      let marker = tp.find(`.sm-find-marker[data-id="${match.id}"]`);
      // FIXME: when doing replace it seems that we are not good yet with navigating through the matches
      // this guard should not be necessary if everything is working
      if (marker) {
        marker.el.addClass('sm-active');
        state.marker = marker;
        tp.send('scrollElementIntoView', marker.el);
      }
    }

    _onUpdate (change) {
      // skip changes caused by replaceNext() and replaceAll()
      if (
        change.info.action === 'replace' ||
        change.info.action === 'replace-all' ||
        change.info.action === 'nop'
      ) return
      for (let op of change.ops) {
        if (op.isUpdate() && op.diff._isTextOperation) {
          this._dirty.add(substance.getKeyForPath(op.path));
        }
      }
      let state = this._getState();
      if (!state.enabled) return

      // HACK: this is a bit hacky but should work. When the user has changed the text we leave a mark in the state
      // so that we can force a 'next()' when 'replaceNext()' is called
      state._forceNav = true;
      // Note: when running tests updating the search result synchronously
      if (substance.platform.test) {
        this._updateSearch();
      } else {
        // otherwise this is done debounced
        this._updateSearchDebounced();
      }
    }

    _onRender (change) {
      // HACK: There seems to be a problem with registering observers in the appState
      // without registering this hook we see strange errors at other places
      // Probably related to a bug in the observer registration/deregistration
      // during propagation of AppState changes
    }

    static defaultState () {
      return {
        enabled: false,
        pattern: '',
        showReplace: false,
        replacePattern: '',
        caseSensitive: false,
        fullWord: false,
        regexSearch: false,
        matches: null,
        count: 0,
        cursor: 0
      }
    }
  }

  function _createRegExForPattern (pattern) {
    return pattern.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&') // eslint-disable-line no-useless-escape
  }

  function _findInText (text, pattern, opts = {}) {
    if (!opts.regexSearch) {
      pattern = _createRegExForPattern(pattern);
    }
    if (opts.fullWord) {
      pattern = '\\b' + pattern + '\\b';
    }
    let matches = [];
    try {
      let matcher = new RegExp(pattern, opts.caseSensitive ? 'g' : 'gi');
      let match;
      while ((match = matcher.exec(text))) {
        matches.push({
          start: match.index,
          end: matcher.lastIndex
        });
      }
    } catch (err) {}
    return matches
  }

  class EditorSession extends substance.AbstractEditorSession {
    /**
     * @param {string} id a unique name for this editor session
     * @param {DocumentSession} documentSession
     * @param {Configurator} config
     * @param {object} contextProvider an object with getContext()
     * @param {object|EditorState} editorState a plain object with intial values or an EditorState instance for reuse
     */
    constructor (id, documentSession, config, editor, editorState = {}) {
      super(id, documentSession, editorState.history);

      const doc = documentSession.getDocument();

      this._config = config;
      this._editor = editor;

      // FIXME: it a little confusing how the history injection is done here
      // On the one hand, AbstractEditorSession initializes a history if not given
      // On the other, we want to reuse the history, so we put it into the created
      // editorState, so somebody can pick it up and reuse it
      // Alternatively, like we do it in ArticlePanel, the whole editorState is injected
      // with a history already initialized
      if (substance.isPlainObject(editorState)) {
        editorState.history = this._history;
        editorState = this.constructor.createEditorState(documentSession, editorState);
      } else {
        // revitalising the given editorState because it has probably been disposed
        // TODO: we should think about a general approach to hibernate an EditorSession
        // re-using the editorState is a first step towards this.
        editorState.init();
      }
      let surfaceManager = new SurfaceManager(editorState);
      let markersManager = new MarkersManager(editorState);
      let globalEventHandler = new GlobalEventHandler(editorState);
      let keyboardManager = new KeyboardManager(config.getKeyboardShortcuts(), (commandName, params) => {
        return this.executeCommand(commandName, params)
      }, editor);
      let commandManager = new SchemaDrivenCommandManager(editorState,
        // update commands when document or selection have changed
        ['document', 'selection'],
        config.getCommands(),
        editor
      );
      let findAndReplaceManager = new FindAndReplaceManager(this, editorState, editor);

      this.editorState = editorState;
      this.surfaceManager = surfaceManager;
      this.markersManager = markersManager;
      this.globalEventHandler = globalEventHandler;
      this.keyboardManager = keyboardManager;
      this.commandManager = commandManager;
      this.findAndReplaceManager = findAndReplaceManager;

      // EXPERIMENTAL: hook that records changes triggered via node state updates
      doc.on('document:changed', this._onDocumentChange, this);
      // EXPERIMENTAL: registering a 'reducer' that resets overlayId whenever the selection changes
      editorState.addObserver(['selection'], this._resetOverlayId, this, { stage: 'update' });
    }

    initialize () {
      // TODO: is this the right place?
      // initial reduce step
      this.commandManager.reduce();
    }

    dispose () {
      this.getDocument().off(this);
      this.editorState.off(this);
      this.editorState.dispose();
    }

    static createEditorState (documentSession, initialState = {}) {
      let doc = documentSession.getDocument();
      return new EditorState(Object.assign({
        document: doc,
        history: new substance.ChangeHistoryView(documentSession),
        selection: substance.Selection.nullSelection,
        selectionState: {},
        focusedSurface: null,
        commandStates: {},
        hasUnsavedChanges: false,
        isBlurred: false,
        overlayId: null,
        findAndReplace: FindAndReplaceManager.defaultState()
      }, initialState))
    }

    // createSelection (...args) {
    //   return this._document.createSelection(...args)
    // }

    executeCommand (commandName, params) {
      return this.commandManager.executeCommand(commandName, params)
    }

    getCommandStates () {
      return this.editorState.commandStates
    }

    getConfigurator () {
      return this._config
    }

    getContext () {
      return this.contextProvider.context
    }

    getFocusedSurface () {
      return this.editorState.focusedSurface
    }

    getSelectionState () {
      return this.editorState.selectionState
    }

    getSurface (surfaceId) {
      return this.surfaceManager.getSurface(surfaceId)
    }

    hasUnsavedChanges () {
      return Boolean(this.editorState.hasUnsavedChanges)
    }

    isBlurred () {
      return Boolean(this.editorState.isBlurred)
    }

    setSelection (sel) {
      super.setSelection(sel);
      const editorState = this.editorState;
      if (editorState.isBlurred) {
        editorState.isBlurred = false;
      }
      editorState.propagateUpdates();
    }

    transaction (...args) {
      super.transaction(...args);
      this.editorState.propagateUpdates();
    }

    _getSelection () {
      return this.editorState.selection
    }

    _setSelection (sel) {
      this.editorState.selection = sel;
      return sel
    }

    undo () {
      super.undo();
      this.editorState.propagateUpdates();
    }

    updateNodeStates (tuples, options = {}) {
      super.updateNodeStates(tuples, options);

      if (options.propagate) {
        this.editorState.propagateUpdates();
      }
    }

    redo () {
      super.redo();
      this.editorState.propagateUpdates();
    }

    _onDocumentChange (change, info) {
      const editorState = this.editorState;
      // ATTENTION: ATM we are using a DocumentChange to implement node states
      // Now it happens, that something that reacts on document changes (particularly a CitationManager)
      // updates the node state during a flow.
      // HACK: In that case we 'merge' the state update into the already propagated document change
      if (editorState.isDirty('document') && info.action === 'node-state-update') {
        let propagatedChange = editorState.getUpdate('document').change;
        Object.assign(propagatedChange.updated, change.updated);
      } else {
        this.editorState._setUpdate('document', { change, info });
        this.editorState.hasUnsavedChanges = true;
      }
    }

    _resetOverlayId () {
      const overlayId = this.editorState.overlayId;
      // overlayId === getKeyForPath(path) => if selection is value &&
      // Overlays of value components (ManyRelationshipComponent, SingleRelationship)
      // need to remain open if the selection is a value selection
      let sel = this.getSelection();
      if (sel && sel.customType === 'value') {
        let valueId = substance.getKeyForPath(sel.data.path);
        if (overlayId !== valueId) {
          this.editorState.set('overlayId', valueId);
        }
      } else {
        this.editorState.set('overlayId', null);
      }
    }
  }

  class AnnotationComponent extends substance.AnnotationComponent {
    getClassNames () {
      return `sc-annotation sm-${this.props.node.type}`
    }
  }

  const ENABLED = Object.freeze({ disabled: false });

  class FindAndReplaceCommand extends substance.Command {
    getCommandState (params, context) {
      switch (this.config.action) {
        case 'open-find':
        case 'open-replace': {
          return ENABLED
        }
        // TODO: do we need this anymore. ATM we do not have a global command
        // enabled, e.g. for a global keyboardshortcut drive way of navigating
        // search results. ATM this works only if the FindAndReplaceDialog has focus
        // case 'find-next':
        // case 'find-previous': {
        //   let fnrState = context.appState.findAndReplace
        //   if (fnrState && fnrState.count > 0) {
        //     return ENABLED
        //   } else {
        //     return Command.DISABLED
        //   }
        // }
      }
    }

    execute (params, context) {
      let fnr = context.findAndReplaceManager;
      switch (this.config.action) {
        case 'open-find': {
          fnr.openDialog();
          break
        }
        case 'open-replace': {
          fnr.openDialog('replace');
          break
        }
        // TODO: see above
        // case 'find-next': {
        //   fnr.next()
        //   break
        // }
        // case 'find-previous': {
        //   fnr.previous()
        //   break
        // }
      }
    }
  }

  const UPDATE_DELAY$1 = 300;

  class FindAndReplaceDialog extends substance.Component {
    constructor (...args) {
      super(...args);

      // debounce updates when patterns change, but not during tests
      if (!substance.platform.test) {
        this._updatePattern = substance.debounce(this._updatePattern.bind(this), UPDATE_DELAY$1);
        this._updateReplacePattern = substance.debounce(this._updateReplacePattern.bind(this), UPDATE_DELAY$1);
      }
    }

    didMount () {
      this.context.appState.addObserver(['findAndReplace'], this._onUpdate, this, { stage: 'render' });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    render ($$) {
      let state = this._getState();
      let el = $$('div').addClass('sc-find-and-replace-dialog');
      el.append(
        this._renderHeader($$),
        this._renderFindSection($$),
        this._renderReplaceSection($$)
      );
      if (!state.enabled) {
        el.addClass('sm-hidden');
      }
      el.on('keydown', this._onKeydown);
      return el
    }

    _renderTitle ($$) {
      const state = this._getState();
      let title = state.showReplace ? this.getLabel(`find-replace-title-${this.props.viewName}`) : this.getLabel(`find-title-${this.props.viewName}`);
      let options = [];
      if (state.caseSensitive) options.push('case-sensitive-title');
      if (state.fullWord) options.push('whole-word-title');
      if (state.regexSearch) options.push('regex-title');
      if (options.length > 0) title += ' (' + options.map(o => this.getLabel(o)).join(', ') + ')';
      return $$('div').addClass('se-title').append(title)
    }

    _renderHeader ($$) {
      const state = this._getState();
      const Button = this.getComponent('button');
      return $$('div').addClass('se-header').append(
        this._renderTitle($$),
        $$('div').addClass('se-group sm-options').append(
          $$(Button, {
            tooltip: this.getLabel('find-case-sensitive'),
            active: state.caseSensitive,
            theme: this.props.theme
          }).addClass('sm-case-sensitive').append('Aa')
            .on('click', this._toggleCaseSensitivity),
          $$(Button, {
            tooltip: this.getLabel('find-whole-word'),
            active: state.fullWord,
            theme: this.props.theme
          }).addClass('sm-whole-word').append('Abc|')
            .on('click', this._toggleFullWordSearch),
          $$(Button, {
            tooltip: this.getLabel('find-regex'),
            active: state.regexSearch,
            theme: this.props.theme
          }).addClass('sm-regex-search').append('.*')
            .on('click', this._toggleRegexSearch),
          $$(Button, {
            tooltip: this.getLabel('close'),
            theme: this.props.theme
          }).addClass('sm-close')
            .append(
              this.context.iconProvider.renderIcon($$, 'close')
            )
            .on('click', this._close)
        )
      )
    }

    _renderFindSection ($$) {
      const state = this._getState();
      const Button = this.getComponent('button');
      return $$('div').addClass('se-section').addClass('sm-find').append(
        $$('div').addClass('se-group sm-input').append(
          this._renderPatternInput($$),
          this._renderStatus($$)
        ),
        $$('div').addClass('se-group sm-actions').append(
          $$(Button, {
            tooltip: this.getLabel('find-next'),
            theme: this.props.theme,
            disabled: state.count < 1
          }).addClass('sm-next')
            .append(this.getLabel('next'))
            .on('click', this._findNext),
          $$(Button, {
            tooltip: this.getLabel('find-previous'),
            theme: this.props.theme,
            disabled: state.count < 1
          }).addClass('sm-previous')
            .append(this.getLabel('previous'))
            .on('click', this._findPrevious)
        )
      )
    }

    _renderReplaceSection ($$) {
      let state = this._getState();
      if (state.showReplace) {
        const Button = this.getComponent('button');
        return $$('div').addClass('se-section').addClass('sm-replace').append(
          $$('div').addClass('se-group sm-input').append(
            this._renderReplacePatternInput($$)
          ),
          $$('div').addClass('se-group sm-actions').append(
            $$(Button, {
              tooltip: this.getLabel('replace'),
              theme: this.props.theme,
              disabled: state.count < 1
            }).addClass('sm-replace')
              .append(this.getLabel('replace'))
              .on('click', this._replaceNext),
            $$(Button, {
              tooltip: this.getLabel('replace-all'),
              theme: this.props.theme,
              disabled: state.count < 1
            }).addClass('sm-replace-all')
              .append(this.getLabel('replace-all'))
              .on('click', this._replaceAll)
          )
        )
      }
    }

    _renderPatternInput ($$) {
      let state = this._getState();
      return $$('input').ref('pattern').addClass('sm-find')
        .attr({
          type: 'text',
          placeholder: this.getLabel('find'),
          'tabindex': 500
        })
        .val(state.pattern)
        .on('keydown', this._onPatternKeydown)
        .on('input', this._updatePattern)
        .on('focus', this._onFocus)
    }

    _renderReplacePatternInput ($$) {
      let state = this._getState();
      return $$('input').ref('replacePattern').addClass('sm-replace')
        .attr({
          type: 'text',
          placeholder: this.getLabel('replace'),
          'tabindex': 500
        })
        .val(state.replacePattern)
        .on('keydown', this._onReplacePatternKeydown)
        .on('input', this._updateReplacePattern)
    }

    _renderStatus ($$) {
      let state = this._getState();
      let el = $$('span').addClass('se-status');
      if (state.count > 0) {
        let current = state.cursor === -1 ? '?' : String(state.cursor + 1);
        el.append(`${current} of ${state.count}`);
      } else if (state.pattern) {
        el.append(this.getLabel('no-result'));
      }
      return el
    }

    _grabFocus () {
      let state = this._getState();
      let input = state.showReplace ? this.refs.replacePattern : this.refs.pattern;
      input.el.focus();
    }

    _getState () {
      return this.context.appState.get('findAndReplace')
    }

    _getManager () {
      return this.context.findAndReplaceManager
    }

    _close () {
      this._getManager().closeDialog();
    }

    _findNext () {
      this._getManager().next();
    }

    _findPrevious () {
      this._getManager().previous();
    }

    _replaceNext () {
      this._getManager().replaceNext();
    }

    _replaceAll () {
      this._getManager().replaceAll();
    }

    _updatePattern () {
      // console.log('FindAndReplaceDialog._updatePattern()', this.refs.pattern.val())
      this._getManager().setSearchPattern(this.refs.pattern.val());
    }

    _updateReplacePattern () {
      this._getManager().setReplacePattern(this.refs.replacePattern.val());
    }

    _toggleCaseSensitivity () {
      this._getManager().toggleCaseSensitivity();
    }

    _toggleFullWordSearch () {
      this._getManager().toggleFullWordSearch();
    }

    _toggleRegexSearch () {
      this._getManager().toggleRegexSearch();
    }

    _onUpdate () {
      // if this dialog is made visible, auto-focus the respective pattern input field
      // TODO: maybe we should let the app control this
      let wasHidden = this.el.hasClass('sm-hidden');
      this.rerender();
      let isHidden = this.el.hasClass('sm-hidden');
      if (wasHidden && !isHidden) {
        this._grabFocus();
      }
    }

    _onKeydown (e) {
      if (e.keyCode === substance.keys.ESCAPE) {
        e.stopPropagation();
        e.preventDefault();
        this._close();
      }
    }

    _onFocus (e) {
      e.stopPropagation();
      this.context.appState.set('isBlurred', true);
    }

    _onPatternKeydown (e) {
      e.stopPropagation();
      if (e.keyCode === substance.keys.ENTER) {
        e.preventDefault();
        this._findNext();
      }
    }

    _onReplacePatternKeydown (e) {
      e.stopPropagation();
      if (e.keyCode === substance.keys.ENTER) {
        e.preventDefault();
        this._replaceNext();
      }
    }
  }

  var FindAndReplacePackage = {
    name: 'find-and-replace',
    configure: function (config, userConfig) {
      config.addComponent('find-and-replace-dialog', FindAndReplaceDialog);
      config.addComponent('find-marker', AnnotationComponent);

      config.addCommand('open-find', FindAndReplaceCommand, {
        commandGroup: 'find-and-replace',
        action: 'open-find'
      });
      config.addCommand('open-replace', FindAndReplaceCommand, {
        commandGroup: 'find-and-replace',
        action: 'open-replace'
      });
      config.addKeyboardShortcut('CommandOrControl+F', { command: 'open-find' });
      // there are different conventions for opening replace
      if (substance.platform.isMac) {
        config.addKeyboardShortcut('CommandOrControl+Alt+F', { command: 'open-replace' });
      } else {
        config.addKeyboardShortcut('CommandOrControl+H', { command: 'open-replace' });
      }
      config.addLabel('find-and-replace-title', {
        en: 'Find and replace'
      });
      config.addLabel('find', {
        en: 'Find'
      });
      config.addLabel('find-next', {
        en: 'Next match'
      });
      config.addLabel('find-previous', {
        en: 'Previous match'
      });
      config.addLabel('find-case-sensitive', {
        en: 'Match Case'
      });
      config.addLabel('find-whole-word', {
        en: 'Match Whole Word'
      });
      config.addLabel('find-regex', {
        en: 'Use Regular Expression'
      });
      config.addLabel('replace', {
        en: 'Replace'
      });
      config.addLabel('replace-all', {
        en: 'Replace All'
      });
      config.addLabel('next', {
        en: 'Next'
      });
      config.addLabel('previous', {
        en: 'Previous'
      });
      config.addLabel('find-title-manuscript', {
        en: 'Find in Article'
      });
      config.addLabel('find-title-metadata', {
        en: 'Find in Metadata'
      });
      config.addLabel('no-result', {
        en: 'No results'
      });
      config.addLabel('find-replace-title-manuscript', {
        en: 'Find and replace in article'
      });
      config.addLabel('find-replace-title-metadata', {
        en: 'Find and replace in metadata'
      });
      config.addLabel('case-sensitive-title', {
        en: 'Case Sensitive'
      });
      config.addLabel('whole-word-title', {
        en: 'Whole Word'
      });
      config.addLabel('regex-title', {
        en: 'Regex'
      });
      config.addIcon('close', { 'fontawesome': 'fa-close' });
    }
  }

  // NOTE: copied this from substance as IMO we should have basic commands within this kit
  class SwitchTextTypeCommand extends substance.Command {
    constructor (config) {
      super(config);
      if (!config.spec) {
        throw new Error("'config.spec' is mandatory")
      }
      if (!config.spec.type) {
        throw new Error("'config.spec.type' is mandatory")
      }
    }

    getType () {
      return this.config.spec.type
    }

    getCommandState (params) {
      const editorSession = params.editorSession;
      const doc = editorSession.getDocument();
      const sel = params.selection;
      const isBlurred = editorSession.isBlurred();
      let commandState = {
        disabled: false
      };
      if (sel.isPropertySelection() && !isBlurred) {
        let path = sel.getPath();
        let node = doc.get(path[0]);
        if (node && node.isText()) {
          commandState.active = substance.isMatch(node, this.config.spec);
          // When cursor is at beginning of a text block we signal
          // that we want the tool to appear contextually (e.g. in an overlay)
          commandState.showInContext = sel.start.offset === 0 && sel.end.offset === 0;
        } else {
          commandState.disabled = true;
        }
      } else {
        // TODO: Allow Container Selections too, to switch multiple paragraphs
        commandState.disabled = true;
      }
      return commandState
    }

    /**
      Perform a switchTextType transformation based on the current selection
    */
    execute (params) {
      const editorSession = params.editorSession;
      editorSession.transaction((tx) => {
        return tx.switchTextType(this.config.spec)
      });
    }

    isSwitchTypeCommand () {
      return true
    }
  }

  // This is only used for Value models
  function addModelObserver (model, fn, comp, options = {}) {
    let stage = options.stage || 'render';
    if (model._isValue) {
      let path = model.getPath();
      comp.context.appState.addObserver(['document'], fn, comp, {
        stage,
        document: { path }
      });
    }
  }

  /* istanbul ignore file */

  function throwMethodIsAbstract () {
    throw new Error('This method is abstract.')
  }

  class ValueModel {
    constructor (api, path) {
      this._api = api;
      this._path = path;
    }

    get id () {
      return substance.getKeyForPath(this._path)
    }

    get type () {
      throwMethodIsAbstract();
    }

    getPath () {
      return this._path
    }

    // EXPERIMENTAL: a third kind of path, which is [<type>, <prop-name>]
    _getPropertySelector () {
      if (!this._selector) {
        let doc = this._api.getDocument();
        let node = doc.get(this._path[0]);
        this._selector = [node.type].concat(this._path.slice(1));
      }
      return this._selector
    }

    hasTargetType (name) {
      return false
    }

    getValue () {
      return this._api.getDocument().get(this._path)
    }

    setValue (val) {
      this._api.getEditorSession().transaction(tx => {
        tx.set(this._path, val);
      });
    }

    getSchema () {
      return this._api.getDocument().getProperty(this._path)
    }

    isEmpty () {
      return substance.isNil(this.getValue())
    }

    _resolveId (id) {
      return this._api.getDocument().get(id)
    }

    get _value () { return this.getValue() }

    get _isValue () { return true }
  }

  class BooleanModel extends ValueModel {
    get type () { return 'boolean' }

    // Note: Nil is interpreted as false, and false is thus also interpreted as isEmpty()
    isEmpty () {
      return !this.getValue()
    }
  }

  class ChildModel extends ValueModel {
    constructor (api, path, targetTypes) {
      super(api, path);

      this._targetTypes = new Set(targetTypes);
    }

    get type () { return 'child' }

    getChild () {
      return this._resolveId(this.getValue())
    }

    hasTargetType (type) {
      return this._targetTypes.has(type)
    }

    isEmpty () {
      // FIXME: formerly we have delegated to a child model (but, when is a node / composite model empty?)
      let child = this.getChild();
      return !child
    }
  }

  function isCollectionEmpty (api, path) {
    let doc = api.getDocument();
    let ids = doc.get(path);
    if (ids.length === 0) return true
    // otherwise considered only empty if container has only one empty child node
    if (ids > 1) return false
    let first = doc.get(ids[0]);
    // being robust against invalid ids
    if (first && first.isEmpty) {
      return first.isEmpty()
    }
  }

  class CollectionModel extends ValueModel {
    constructor (api, path, targetTypes) {
      super(api, path);

      this._targetTypes = new Set(targetTypes);
    }

    get type () { return 'collection' }

    get isCollection () {
      return true
    }

    getItems () {
      const doc = this._api.getDocument();
      return substance.documentHelpers.getNodesForIds(doc, this.getValue())
    }

    addItem (item) {
      this._api._appendChild(this._path, item);
    }

    get length () { return this.getValue().length }

    // TODO: this is not used ATM
    // we should either remove both addItem() and removeItem()
    // or use it consistently
    // removeItem (item) {
    //   this._api._removeChild(this._path, item)
    // }

    getValue () {
      return super.getValue() || []
    }

    isEmpty () {
      return isCollectionEmpty(this._api, this._path)
    }

    hasTargetType (type) {
      return this._targetTypes.has(type)
    }
  }

  // TODO: this does not seem to be the right approach
  // We have taken this too far, i.e. trying to generate an editor
  // for reference properties without ownership (aka relationships)
  class _RelationshipModel extends ValueModel {
    constructor (api, path, targetTypes) {
      super(api, path);

      this._targetTypes = new Set(targetTypes);
    }

    hasTargetType (type) {
      return this._targetTypes.has(type)
    }

    getAvailableOptions () {
      return this._api._getAvailableOptions(this)
    }
  }

  class ManyRelationshipModel extends _RelationshipModel {
    get type () { return 'many-relationship' }

    getValue () {
      return super.getValue() || []
    }

    isEmpty () {
      return this.getValue().length === 0
    }

    toggleTarget (target) {
      this._api._toggleRelationship(this._path, target.id);
    }
  }

  class NumberModel extends ValueModel {
    get type () { return 'number' }
  }

  class ObjectModel extends ValueModel {
    get type () { return 'object' }
  }

  class SingleRelationshipModel extends _RelationshipModel {
    get type () { return 'single-relationship' }

    toggleTarget (target) {
      let currentTargetId = this.getValue();
      let newTargetId;
      if (currentTargetId === target.id) {
        newTargetId = undefined;
      } else {
        newTargetId = target.id;
      }
      this._api.getEditorSession().transaction(tx => {
        let path = this._path;
        tx.set(path, newTargetId);
        tx.setSelection(this._api._createValueSelection(path));
      });
    }
  }

  class StringModel extends ValueModel {
    get type () { return 'string' }

    isEmpty () {
      let value = this.getValue();
      return substance.isNil(value) || value.length === 0
    }
  }

  class TextModel extends StringModel {
    get type () { return 'text' }
  }

  function createValueModel (api, path, property) {
    let doc = api.getDocument();
    if (!property) property = doc.getProperty(path);
    let targetTypes = property.targetTypes;
    let valueModel;
    switch (property.type) {
      case 'boolean': {
        valueModel = new BooleanModel(api, path);
        break
      }
      case 'number': {
        valueModel = new NumberModel(api, path);
        break
      }
      case 'string': {
        valueModel = new StringModel(api, path);
        break
      }
      case 'text': {
        valueModel = new TextModel(api, path);
        break
      }
      case 'object': {
        valueModel = new ObjectModel(api, path);
        break
      }
      default: {
        if (property.isReference()) {
          if (property.isOwned()) {
            if (property.isArray()) {
              valueModel = new CollectionModel(api, path, targetTypes);
            } else {
              valueModel = new ChildModel(api, path, targetTypes);
            }
          } else {
            if (property.isArray()) {
              valueModel = new ManyRelationshipModel(api, path, targetTypes);
            } else {
              valueModel = new SingleRelationshipModel(api, path, targetTypes);
            }
          }
        }
      }
    }
    return valueModel
  }

  function createNodePropertyModels (api, node, hooks = {}) {
    let properties = new Map();
    for (let p of node.getSchema()) {
      if (p.name === 'id') continue
      if (p.name === 'type') continue
      // EXPERIMENTAL: allowing to override creation of a property model
      // for the purpose of flattening....
      // TODO: this could also be done via option

      let hook = substance.isFunction(hooks) ? hooks : hooks[p.name];

      if (hook) {
        let val = hook(p);
        // allow to skip properties by returning nil
        if (substance.isNil(val)) continue

        if (val instanceof Map) {
          for (let [name, model] of val) {
            properties.set(name, model);
          }
        } else if (val._isValue) {
          properties.set(p.name, val);
        } else {
          // expecting either a single ValueModel, or a Map(name->ValueModel)
          throw new Error('Illegal value')
        }
      } else {
        let valueModel = createValueModel(api, [node.id, p.name], p);
        properties.set(p.name, valueModel);
      }
    }
    return properties
  }

  /*
    Note: this implementation is different to the core implementation
    in that regard that it serializes child nodes before their parents
  */
  class JSONConverterNew {
    importDocument (doc, json) {
      if (!json.nodes) {
        throw new Error('Invalid JSON format.')
      }
      // the json should just be an array of nodes
      var nodes = json.nodes;
      doc.import(tx => {
        nodes.forEach(node => tx.create(node));
      });
      return doc
    }

    exportDocument (doc) {
      var schema = doc.getSchema();
      var json = {
        schema: {
          name: schema.name
        },
        nodes: []
      };
      let visited = {};

      function _export (node) {
        if (!node) return
        if (visited[node.id]) return
        visited[node.id] = true;
        let nodeSchema = node.getSchema();
        nodeSchema.getOwnedProperties().forEach(prop => {
          let val = node[prop.name];
          if (substance.isArray(val)) {
            val.forEach(id => {
              _export(doc.get(id));
            });
          } else {
            _export(doc.get(val));
          }
        });
        json.nodes.push(node.toJSON());
      }

      substance.forEach(doc.getNodes(), node => _export(node));

      return json
    }
  }

  function removeModelObserver (comp) {
    comp.context.appState.removeObserver(comp);
  }

  class AbstractScrollPane extends substance.Component {
    getActionHandlers () {
      return {
        'scrollSelectionIntoView': this._scrollSelectionIntoView
      }
    }
    /*
      Expose scrollPane as a child context
    */
    getChildContext () {
      return {
        scrollPane: this
      }
    }

    didMount () {
      if (substance.platform.inBrowser) {
        this.windowEl = substance.DefaultDOMElement.wrapNativeElement(window);
        this.windowEl.on('resize', this._onResize, this);
      }
      // FIXME: we need to define when exactly this must be executed
      // ATM this causes trouble when
      this.context.appState.addObserver(['@any'], this._afterRender, this, { stage: 'position' });
    }

    dispose () {
      if (this.windowEl) {
        this.windowEl.off(this);
      }
      this.context.appState.off(this);
    }

    getName () {
      return this.props.name
    }

    _computeOverlayHints () {
      let contentRect = this._getContentRect();
      let selectionRect = this._getSelectionRect();
      return {
        contentRect,
        selectionRect
      }
    }

    _reduceOverlayHints (hints) {
      // TODO: introduce a reducer for this
      this.context.appState.set('overlayHints', hints);
    }

    /*
      Determine selection rectangle relative to content element
      and emit a selection:positioned event with positioning hints
    */
    _position () {
      let hints = this._computeOverlayHints();
      if (hints) {
        this._reduceOverlayHints(hints);
        // TODO: this is problematic and needs to be approached in
        // a different way.
        // Now we use overlays not only for selection anchored popups
        // but also for menu dropdowns.
        // Only for cases where the overlay needs to be position with a selection
        // we should do that. I.e. I guess this should not be considered here at all
        // but rather done along with the selection rendering
        // this._scrollSelectionIntoView(hints.selectionRect)
      }
    }

    _afterRender () {
      this._position();
    }

    _onResize () {
      this._position();
    }

    /*
      Determine mouse bounds relative to content element
      and emit context-menu:opened event with positioning hints
    */
    _onContextMenu (e) {
      e.preventDefault();
      let mouseBounds = this._getMouseBounds(e);
      this.emit('context-menu:opened', {
        mouseBounds: mouseBounds
      });
    }

    _scrollSelectionIntoView () {
      // console.log('AbstractScrollPane._scrollSelectionIntoView()')
      let hints = this.context.appState.get('overlayHints');
      if (!hints) {
        // console.log('...no hints')
        return
      }
      let selectionRect = hints.selectionRect;
      if (!selectionRect) {
        // console.log('...no selection rect')
        return
      }
      let upperBound = this.getScrollPosition();
      let lowerBound = upperBound + this.getHeight();
      let selTop = selectionRect.top;
      let selBottom = selectionRect.top + selectionRect.height;
      if ((selTop < upperBound && selBottom < upperBound) ||
          (selTop > lowerBound && selBottom > lowerBound)) {
        this.setScrollPosition(selTop);
      }
    }

    /**
      Returns the height of scrollPane (inner content overflows)
    */
    getHeight () {
      throw new Error('Abstract method')
    }

    /**
      Returns the cumulated height of a panel's content
    */
    getContentHeight () {
      throw new Error('Abstract method')
    }

    getContentElement () {
      // TODO: should be wrapped in DefaultDOMElement
      throw new Error('Abstract method')
    }

    /**
      Get the `.se-scrollable` element
    */
    getScrollableElement () {
      throw new Error('Abstract method')
    }

    /**
      Get current scroll position (scrollTop) of `.se-scrollable` element
    */
    getScrollPosition () {
      throw new Error('Abstract method')
    }

    setScrollPosition () {
      throw new Error('Abstract method')
    }

    /**
      Get offset relative to `.se-content`.

      @param {DOMNode} el DOM node that lives inside the
    */
    getPanelOffsetForElement(el) { // eslint-disable-line
      throw new Error('Abstract method')
    }

    /**
      Scroll to a given sub component.

      @param {String} componentId component id, must be present in data-id attribute
    */
    scrollTo(componentId, onlyIfNotVisible) { // eslint-disable-line
      throw new Error('Abstract method')
    }

    _getContentRect () {
      return this.getContentElement().getNativeElement().getBoundingClientRect()
    }

    /*
      Get selection rectangle relative to panel content element
    */
    _getSelectionRect () {
      let appState = this.context.appState;
      let sel = appState.selection;
      let selectionRect;
      if (substance.platform.inBrowser && sel && !sel.isNull()) {
        let contentEl = this.getContentElement();
        let contentRect = contentEl.getNativeElement().getBoundingClientRect();
        if (sel.isNodeSelection()) {
          let nodeId = sel.nodeId;
          let nodeEl = contentEl.find(`*[data-id="${nodeId}"]`);
          if (nodeEl) {
            let nodeRect = nodeEl.getNativeElement().getBoundingClientRect();
            selectionRect = substance.getRelativeRect(contentRect, nodeRect);
          } else {
            console.error(`FIXME: could not find a node with data-id=${nodeId}`);
          }
        } else {
          selectionRect = substance.getSelectionRect(contentRect);
        }
      }
      return selectionRect
    }

    _getMouseBounds (e) {
      return substance.getRelativeMouseBounds(e, this.getContentElement().getNativeElement())
    }
  }

  /**
    Wraps content in a scroll pane.

    @class ScrollPane
    @component

    @prop {String} scrollbarType 'native' or 'substance' for a more advanced visual scrollbar. Defaults to 'native'
    @prop {String} [scrollbarPosition] 'left' or 'right' only relevant when scrollBarType: 'substance'. Defaults to 'right'
    @prop {ui/Highlights} [highlights] object that maintains highlights and can be manipulated from different sources

    @example

    ```js
    $$(BodyScrollPane).append(
      content,
      $$(ContextMenu)
      $$(Overlay)
    )
    ```
  */
  class BodyScrollPane extends AbstractScrollPane {
    /*
      Expose scrollPane as a child context
    */
    getChildContext () {
      return {
        scrollPane: this
      }
    }

    getName () {
      return 'body'
    }

    render ($$) {
      let el = $$('div');
      if (this.props.contextMenu === 'custom') {
        el.on('contextmenu', this._onContextMenu);
      }
      el.append(this.props.children);
      return el
    }

    /**
      Returns the height of scrollPane (inner content overflows)
    */
    getHeight () {
      if (substance.platform.inBrowser) {
        return window.innerHeight
      } else {
        return 0
      }
    }

    /**
      Returns the cumulated height of a panel's content
    */
    getContentHeight () {
      if (substance.platform.inBrowser) {
        return document.body.scrollHeight
      } else {
        return 0
      }
    }

    getContentElement () {
      if (substance.platform.inBrowser) {
        return substance.DefaultDOMElement.wrapNativeElement(window.document.body)
      } else {
        return null
      }
    }

    // /**
    //   Get the `.se-scrollable` element
    // */
    getScrollableElement () {
      if (substance.platform.inBrowser) {
        return document.body
      } else {
        return null
      }
    }

    /**
      Get current scroll position (scrollTop) of `.se-scrollable` element
    */
    getScrollPosition () {
      if (substance.platform.inBrowser) {
        return document.body.scrollTop
      } else {
        return 0
      }
    }

    setScrollPosition (scrollPos) {
      if (substance.platform.inBrowser) {
        document.body.scrollTop = scrollPos;
      }
    }

    /**
      Get offset relative to `.se-content`.

      @param {DOMNode} el DOM node that lives inside the
    */
    getPanelOffsetForElement(el) { // eslint-disable-line
      console.warn('TODO: implement');
    }

    /**
      Scroll to a given sub component.

      @param {String} componentId component id, must be present in data-id attribute
    */
    scrollTo(componentId, onlyIfNotVisible) { // eslint-disable-line
      console.warn('TODO: implement');
    }
  }

  class ValueComponent extends substance.Component {
    didMount () {
      const appState = this.context.appState;
      const path = this._getPath();
      appState.addObserver(['document'], this._rerenderOnModelChange, this, {
        stage: 'render',
        document: { path }
      });
    }

    dispose () {
      const appState = this.context.appState;
      appState.removeObserver(this);
    }

    // EXPERIMENTAL:
    // trying to avoid unnecessary rerenderings
    shouldRerender (newProps) {
      return newProps.model !== this.props.model
    }

    _rerenderOnModelChange () {
      // console.log('Rerendering ValueComponent after model update:', this._getPath())
      this.rerender();
    }

    _getPath () {
      return this.props.model._path
    }
  }

  class CheckboxInput extends substance.Component {
    render ($$) {
      const isChecked = Boolean(this.props.value);
      const icon = isChecked ? 'fa-check-square-o' : 'fa-square-o';
      let el = $$('div').addClass('sc-checkbox')
        .on('click', this._onClick);
      el.append(
        // TODO: use icon provider
        $$(substance.FontAwesomeIcon, { icon: icon }).addClass('se-icon')
      );
      return el
    }

    _onClick (e) {
      e.preventDefault();
      e.stopPropagation();
      this.send('toggleValue');
    }
  }

  class BooleanComponent extends ValueComponent {
    getActionHandlers () {
      return {
        toggleValue: this._toggleValue
      }
    }

    render ($$) {
      const model = this.props.model;
      const value = model.getValue();
      let el = $$('div').addClass('sc-boolean');
      if (!this.context.editable) {
        el.addclass('sm-readonly');
      }
      el.append(
        $$(CheckboxInput, { value })
      );
      return el
    }

    _toggleValue () {
      if (this.context.editable) {
        const model = this.props.model;
        this.props.model.setValue(!model.getValue());
      }
    }
  }

  class Button extends substance.Component {
    render ($$) {
      let el = $$('button')
        .addClass('sc-button');

      if (this.props.icon) {
        el.append(this.renderIcon($$));
      }
      if (this.props.label) {
        el.append(this.renderLabel($$));
      }
      if (this.props.tooltip) {
        el.attr('title', this.props.tooltip);
      }
      if (this.props.dropdown) {
        el.append(this.renderDropdownIcon($$));
      }
      if (this.props.active) {
        el.addClass('sm-active');
      }
      if (this.props.theme) {
        el.addClass('sm-theme-' + this.props.theme);
      }

      if (this.props.disabled) {
        // make button inaccessible
        el.attr('tabindex', -1)
          .attr('disabled', true);
      } else {
        // make button accessible for tab-navigation
        el.attr('tabindex', 1);
      }

      // Ability to inject additional elements (should be avoided!)
      el.append(this.props.children);
      return el
    }

    renderIcon ($$) {
      let iconEl = this.context.iconProvider.renderIcon($$, this.props.icon);
      return iconEl
    }

    renderDropdownIcon ($$) {
      let iconEl = this.context.iconProvider.renderIcon($$, 'dropdown');
      iconEl.addClass('se-dropdown');
      return iconEl
    }

    renderLabel ($$) {
      return $$('span').addClass('se-label').append(
        this.getLabel(this.props.label)
      )
    }

    getLabel (name) {
      let labelProvider = this.context.labelProvider;
      return labelProvider.getLabel(name, this.props.commandState)
    }
  }

  function getComponentForModel (context, model) {
    let componentRegistry = context.componentRegistry;
    let ComponentClass = componentRegistry.get(model.type);
    if (!ComponentClass) {
      throw new Error(`No Component class registered for model type ${model.type}.`)
    }
    return ComponentClass
  }

  class ChildComponent extends ValueComponent {
    render ($$) {
      const child = this.props.model.getChild();
      let ComponentClass = getComponentForModel(this.context, child);
      let props = Object.assign({}, this.props);
      props.node = child;
      delete props.model;
      return $$(ComponentClass, props)
    }
  }

  const INLINENODES = ['a', 'b', 'big', 'i', 'small', 'tt', 'abbr', 'acronym', 'cite', 'code', 'dfn', 'em', 'kbd', 'strong', 'samp', 'time', 'var', 'bdo', 'br', 'img', 'map', 'object', 'q', 'script', 'span', 'sub', 'sup', 'button', 'input', 'label', 'select', 'textarea'].reduce((m, n) => { m[n] = true; return m }, {});

  /*
    A rewrite of the original Substance.Clipboard, which uses a better JSONConverter implementation.
    Note: this should eventually moved back into Substance core.
  */
  class ClipboardNew {
    copy (clipboardData, context) {
      // content specific manipulation API
      let api = context.api;
      let snippet = api.copy();
      this._setClipboardData(clipboardData, context, snippet);
    }

    cut (clipboardData, context) {
      let api = context.api;
      let snippet = api.cut();
      this._setClipboardData(clipboardData, context, snippet);
    }

    paste (clipboardData, context, options = {}) {
      let types = {};
      for (let i = 0; i < clipboardData.types.length; i++) {
        types[clipboardData.types[i]] = true;
      }
      let html = types['text/html'] ? clipboardData.getData('text/html') : '';
      let success = false;
      if (html && !options.plainTextOnly) {
        success = this._pasteHtml(html, context, options);
      }
      if (!success) {
        // in all other cases we fall back to plain-text
        let plainText = types['text/plain'] ? clipboardData.getData('text/plain') : '';
        this._pasteText(plainText, context, options);
      }
    }

    _setClipboardData (clipboardData, context, snippet) {
      let plainText = this._createClipboardText(context, snippet);
      let html = this._createClipboardHtml(context, snippet);
      clipboardData.setData('text/plain', plainText);
      clipboardData.setData('text/html', html);
    }

    _createClipboardText (context, snippet) {
      let configurator = context.configurator;
      let textExporter = configurator.getExporter('text');
      return textExporter.exportNode(snippet.getContainer())
    }

    _createClipboardHtml (context, snippet) {
      let htmlExporter = context.configurator.getExporter('html');
      let elements = htmlExporter.convertContainer(snippet, snippet.getContainer().getPath());
      // special treatment for a text snippet
      let snippetHtml;
      if (elements.length === 1 && elements[0].attr('data-id') === substance.documentHelpers.TEXT_SNIPPET_ID) {
        snippetHtml = elements[0].innerHTML;
      } else {
        snippetHtml = elements.map(el => {
          return el.outerHTML
        }).join('');
      }
      let jsonConverter = new JSONConverterNew();
      let jsonStr = JSON.stringify(jsonConverter.exportDocument(snippet));
      let substanceContent = `<script id="substance-clipboard" type="application/json">${jsonStr}</script>`;
      let html = '<html><head>' + substanceContent + '</head><body>' + snippetHtml + '</body></html>';
      return html
    }

    _pasteHtml (html, context, options = {}) {
      let htmlDoc;
      try {
        htmlDoc = substance.DefaultDOMElement.parseHTML(html);
      } catch (err) {
        console.error('Could not parse HTML received from the clipboard', err);
        return false
      }

      // when copying from a substance editor we store JSON in a script tag in the head
      // If the import fails e.g. because the schema is incompatible
      // we fall back to plain HTML import
      let snippet;
      if (html.search(/script id=.substance-clipboard./) >= 0) {
        let substanceData = htmlDoc.find('#substance-clipboard');
        if (substanceData) {
          let jsonStr = substanceData.textContent;
          try {
            snippet = this._importFromJSON(context, jsonStr);
          } finally {
            if (!snippet) {
              console.error('Could not convert clipboard content.');
            }
          }
        }
      }
      if (!snippet) {
        let state = {};
        Object.assign(state, this._detectApplicationType(html, htmlDoc));
        // Under windows and in Microsoft Word we can exploit the fact
        // that the paste content is wrapped inside <!--StartFragment--> and <!--EndFragment-->
        if (substance.platform.isWindows || state.isMicrosoftWord) {
          // very strange: this was not working at some day
          // let match = /<!--StartFragment-->(.*)<!--EndFragment-->/.exec(html)
          // ... but still this
          const START_FRAGMENT = '<!--StartFragment-->';
          const END_FRAGMENT = '<!--EndFragment-->';
          let mStart = html.indexOf(START_FRAGMENT);
          if (mStart >= 0) {
            let mEnd = html.indexOf(END_FRAGMENT);
            let fragment = html.slice(mStart + START_FRAGMENT.length, mEnd);
            htmlDoc = substance.DefaultDOMElement.parseHTML(fragment);
          }
        }
        // Note: because we are parsing the HTML not as snippet
        // the parser will always create a full HTML document
        // and there will always be a <body>
        // In case, the clipboard HTML is just a snippet
        // the body will contain the parsed snippet
        let bodyEl = htmlDoc.find('body');
        bodyEl = this._sanitizeBody(state, bodyEl);
        if (!bodyEl) {
          console.error('Invalid HTML.');
          return false
        }
        bodyEl = this._wrapIntoParagraph(bodyEl);
        snippet = context.appState.document.createSnippet();
        let htmlImporter = context.configurator.getImporter('html');
        htmlImporter.setDocument(snippet);
        let container = snippet.get(substance.documentHelpers.SNIPPET_ID);
        bodyEl.getChildren().forEach(el => {
          let node = htmlImporter.convertElement(el);
          if (node) {
            container.append(node.id);
          }
        });
      }
      return context.api.paste(snippet, options)
    }

    _pasteText (text, context) {
      context.api.insertText(text);
    }

    _importFromJSON (context, jsonStr) {
      let snippet = context.appState.document.newInstance();
      let jsonData = JSON.parse(jsonStr);
      let converter = new JSONConverterNew();
      converter.importDocument(snippet, jsonData);
      return snippet
    }

    _detectApplicationType (html, htmlDoc) {
      let state = {};
      let generatorMeta = htmlDoc.find('meta[name="generator"]');
      let xmnlsw = htmlDoc.find('html').getAttribute('xmlns:w');
      if (generatorMeta) {
        let generator = generatorMeta.getAttribute('content');
        if (generator.indexOf('LibreOffice') > -1) {
          state.isLibreOffice = true;
        }
      } else if (xmnlsw) {
        if (xmnlsw.indexOf('office:word') > -1) {
          state.isMicrosoftWord = true;
        }
      } else if (html.indexOf('docs-internal-guid') > -1) {
        state.isGoogleDoc = true;
      }
      return state
    }

    _sanitizeBody (state, body) {
      // Remove <meta> element
      body.findAll('meta').forEach(el => el.remove());
      // Some word processors are exporting new lines instead of spaces
      // for these editors we will replace all new lines with space
      if (state.isLibreOffice || state.isMicrosoftWord) {
        let bodyHtml = body.getInnerHTML();
        body.setInnerHTML(bodyHtml.replace(/\r\n|\r|\n/g, ' '));
      }
      if (state.isGoogleDoc) {
        body = this._fixupGoogleDocsBody(state, body);
      }
      return body
    }

    _fixupGoogleDocsBody (state, body) {
      if (!body) return
      // Google Docs has a strange convention to use a bold tag as
      // container for the copied elements
      // HACK: we exploit the fact that this element has an id with a
      // specific format, e.g., id="docs-internal-guid-5bea85da-43dc-fb06-e327-00c1c6576cf7"
      let bold = body.find('b');
      if (bold && /^docs-internal/.exec(bold.id)) {
        body = bold;
      }
      // transformations to turn formatations encoded via styles
      // into semantic HTML tags
      body.findAll('span').forEach(span => {
        // Google Docs uses spans with inline styles
        // insted of inline nodes
        // We are scanning each span for certain inline styles:
        // font-weight: 700 -> <b>
        // font-style: italic -> <i>
        // vertical-align: super -> <sup>
        // vertical-align: sub -> <sub>
        // TODO: improve the result for other editors by fusing adjacent annotations of the same type
        let nodeTypes = [];
        if (span.getStyle('font-weight') === '700') nodeTypes.push('b');
        if (span.getStyle('font-style') === 'italic') nodeTypes.push('i');
        if (span.getStyle('vertical-align') === 'super') nodeTypes.push('sup');
        if (span.getStyle('vertical-align') === 'sub') nodeTypes.push('sub');
        // remove the style so the element becomes cleaner
        span.removeAttribute('style');
        createInlineNodes(span.getParent(), true);

        function createInlineNodes (parentEl, isRoot) {
          if (nodeTypes.length > 0) {
            let el = parentEl.createElement(nodeTypes[0]);
            if (nodeTypes.length === 1) el.append(span.textContent);
            if (isRoot) {
              parentEl.replaceChild(span, el);
            } else {
              parentEl.appendChild(el);
            }
            nodeTypes.shift();
            createInlineNodes(el);
          }
        }
      });

      // Union siblings with the same tags, e.g. we are turning
      // <b>str</b><b><i>ong</i></b> to <b>str<i>ong</i></b>
      let tags = ['b', 'i', 'sup', 'sub'];
      tags.forEach(tag => {
        body.findAll(tag).forEach(el => {
          let previousSiblingEl = el.getPreviousSibling();
          if (previousSiblingEl && el.tagName === previousSiblingEl.tagName) {
            let parentEl = el.getParent();
            let newEl = parentEl.createElement(tag);
            newEl.setInnerHTML(previousSiblingEl.getInnerHTML() + el.getInnerHTML());
            parentEl.replaceChild(el, newEl);
            parentEl.removeChild(previousSiblingEl);
          }

          // Union siblings and child with the same tags, e.g. we are turning
          // <i>emph</i><b><i>asis</i></b> to <i>emph<b>asis</b></i>
          // Note that at this state children always have the same text content
          // e.g. there can't be cases like <b><i>emph</i> asis</b> so we don't treat them
          if (previousSiblingEl && previousSiblingEl.tagName && el.getChildCount() > 0 && el.getChildAt(0).tagName === previousSiblingEl.tagName) {
            let parentEl = el.getParent();
            let childEl = el.getChildAt(0);
            let newEl = parentEl.createElement(previousSiblingEl.tagName);
            let newChildEl = newEl.createElement(tag);
            newChildEl.setTextContent(childEl.textContent);
            newEl.appendChild(newChildEl);
            parentEl.replaceChild(el, newEl);
          }
        });
      });

      return body
    }

    // if the content only
    _wrapIntoParagraph (bodyEl) {
      let childNodes = bodyEl.getChildNodes();
      let shouldWrap = false;
      for (let i = 0; i < childNodes.length; i++) {
        const c = childNodes[i];
        if (c.isTextNode()) {
          if (!(/^\s+$/.exec(c.textContent))) {
            shouldWrap = true;
            break
          }
        } else if (INLINENODES[c.tagName]) {
          shouldWrap = true;
          break
        }
      }
      if (shouldWrap) {
        let p = bodyEl.createElement('p');
        p.append(childNodes);
        bodyEl.append(p);
      }
      return bodyEl
    }
  }

  function ModifiedSurface (Surface) {
    class _ModifiedSurface extends Surface {
      constructor (parent, props, options) {
        super(parent, _monkeyPatchSurfaceProps(parent, props), options);
      }

      didMount () {
        const surfaceManager = this.getSurfaceManager();
        if (surfaceManager && this.isEditable()) {
          surfaceManager.registerSurface(this);
        }
        const globalEventHandler = this.getGlobalEventHandler();
        if (globalEventHandler) {
          globalEventHandler.addEventListener('keydown', this._muteNativeHandlers, this);
        }
      }

      dispose () {
        const surfaceManager = this.getSurfaceManager();
        // ATTENTION: no matter if registered or not, we always try to unregister
        surfaceManager.unregisterSurface(this);
        const globalEventHandler = this.getGlobalEventHandler();
        if (globalEventHandler) {
          globalEventHandler.removeEventListener('keydown', this._muteNativeHandlers);
        }
      }

      setProps (newProps) {
        return super.setProps(_monkeyPatchSurfaceProps(this.parent, newProps))
      }

      render ($$) {
        // NOTE: experimenting with additional event handlers
        // After we are sure that we want this we should add this to the core implementation
        let el = super.render($$);
        if (!this.isDisabled()) {
          if (!this.isReadonly()) {
            // prevent click from bubbling up
            el.on('click', this.onClick);
          }
        }
        return el
      }

      _initializeClipboard () {
        return new ClipboardNew()
      }

      _onCopy (e) {
        e.preventDefault();
        e.stopPropagation();
        let clipboardData = e.clipboardData;
        this.clipboard.copy(clipboardData, this.context);
      }

      _onCut (e) {
        e.preventDefault();
        e.stopPropagation();
        let clipboardData = e.clipboardData;
        this.clipboard.cut(clipboardData, this.context);
      }

      _onPaste (e) {
        e.preventDefault();
        e.stopPropagation();
        let clipboardData = e.clipboardData;
        // TODO: allow to force plain-text paste
        this.clipboard.paste(clipboardData, this.context);
      }

      // mostly copied from 'Substance.Surface.onMouseDown()'
      // trying to improve the mouse handling
      // not letting bubble up handled events
      onMouseDown (event) {
        if (!this._shouldConsumeEvent(event)) {
          // console.log('skipping mousedown', this.id)
          return false
        }
        // stopping propagation because now the event is considered to be handled
        event.stopPropagation();

        // EXPERIMENTAL: trying to 'reserve' a mousedown event
        // so that parents know that they shouldn't react
        // This is similar to event.stopPropagation() but without
        // side-effects.
        // Note: some browsers do not do clicks, selections etc. on children if propagation is stopped
        if (event.__reserved__) {
          // console.log('%s: mousedown already reserved by %s', this.id, event.__reserved__.id)
          return
        } else {
          // console.log('%s: taking mousedown ', this.id)
          event.__reserved__ = this;
        }

        // NOTE: this is here to make sure that this surface is contenteditable
        // For instance, IsolatedNodeComponent sets contenteditable=false on this element
        // to achieve selection isolation
        if (this.isEditable()) {
          this.el.setAttribute('contenteditable', true);
        }

        // TODO: what is this exactly?
        if (event.button !== 0) {
          return
        }

        // special treatment for triple clicks
        if (!(substance.platform.isIE && substance.platform.version < 12) && event.detail >= 3) {
          let sel = this.getEditorSession().getSelection();
          if (sel.isPropertySelection()) {
            this._selectProperty(sel.path);
            event.preventDefault();
            event.stopPropagation();
            return
          } else if (sel.isContainerSelection()) {
            this._selectProperty(sel.startPath);
            event.preventDefault();
            event.stopPropagation();
            return
          }
        }
        // 'mouseDown' is triggered before 'focus' so we tell
        // our focus handler that we are already dealing with it
        // The opposite situation, when the surface gets focused e.g. using keyboard
        // then the handler needs to kick in and recover a persisted selection or such
        this._state.skipNextFocusEvent = true;

        // this is important for the regular use case, where the mousup occurs within this component
        this.el.on('mouseup', this.onMouseUp, this);
        // NOTE: additionally we need to listen to mousup on document to catch events outside the surface
        // TODO: it could still be possible not to receive this event, if mouseup is triggered on a component that consumes the event
        if (substance.platform.inBrowser) {
          let documentEl = substance.DefaultDOMElement.wrapNativeElement(window.document);
          documentEl.on('mouseup', this.onMouseUp, this);
        }
      }

      onMouseUp (e) {
        // console.log('Surface.onMouseUp', this.id)
        this.el.off('mouseup', this.onMouseUp, this);
        if (substance.platform.inBrowser) {
          let documentEl = substance.DefaultDOMElement.wrapNativeElement(window.document);
          documentEl.off('mouseup', this.onMouseUp, this);
        }
        // console.log('Surface.onMouseup', this.id);
        // ATTENTION: filtering events does not make sense here,
        // as we need to make sure that pick the selection even
        // when the mouse is released outside the surface
        // if (!this._shouldConsumeEvent(e)) return
        e.stopPropagation();
        // ATTENTION: this delay is necessary for cases the user clicks
        // into an existing selection. In this case the window selection still
        // holds the old value, and is set to the correct selection after this
        // being called.
        this._delayed(() => {
          let sel = this.domSelection.getSelection();
          this._setSelection(sel);
        });
      }

      onClick (event) {
        if (!this._shouldConsumeEvent(event)) {
          // console.log('skipping mousedown', this.id)
          return false
        }
        // stop bubbling up here
        event.stopPropagation();
      }
    }
    return _ModifiedSurface
  }

  function _monkeyPatchSurfaceProps (parent, props) {
    let newProps = Object.assign({}, props);
    if (props.model && !props.node) {
      const model = props.model;
      switch (model.type) {
        case 'collection': {
          newProps.containerPath = model._path;
          break
        }
        default: {
          // TODO: do we really need this anymore?
          if (model._node) {
            newProps.node = model._node;
          }
        }
      }
    }
    // TODO: we should revisit this in Substance
    if (props.editable === false || !parent.context.editable) {
      newProps.editing = 'readonly';
    }
    return newProps
  }

  /*
    Customized ContainerEditor that
      - works with Models, and AppState API,
      - produces a fall-back display for nodes which are not supported yet.
  */
  class ContainerEditorNew extends ModifiedSurface(substance.ContainerEditor) {
    // overriding event registration
    didMount () {
      super.didMount();

      let appState = this.context.appState;
      appState.addObserver(['selection'], this._onSelectionChanged, this, {
        stage: 'render'
      });
      appState.addObserver(['document'], this._onContainerChanged, this, {
        stage: 'render',
        document: {
          path: this.containerPath
        }
      });
    }

    dispose () {
      super.dispose();

      this.context.appState.off(this);
    }

    // overriding this to control editability
    render ($$) {
      let el = super.render($$);

      if (this.isEditable()) {
        el.addClass('sm-editable');
      } else {
        el.addClass('sm-readonly');
        // HACK: removing contenteditable if not editable
        // TODO: we should fix substance.TextPropertyEditor to be consistent with props used in substance.Surface
        el.setAttribute('contenteditable', false);
      }

      return el
    }

    // overriding the default implementation, to control the behavior
    // for nodes without explicitly registered component
    _getNodeComponentClass (node) {
      let ComponentClass = this.getComponent(node.type, 'not-strict');
      if (ComponentClass) {
        // text components are used directly
        if (node.isText() || this.props.disabled) {
          return ComponentClass
        // other components are wrapped into an IsolatedNodeComponent
        // except the component is itself a customized IsolatedNodeComponent
        } else if (ComponentClass.prototype._isCustomNodeComponent || ComponentClass.prototype._isIsolatedNodeComponent) {
          return ComponentClass
        } else {
          return this.getComponent('isolated-node')
        }
      } else {
        // for text nodes without an component registered explicitly
        // we use the default text component
        if (node.isText()) {
          return this.getComponent('text-node')
        // otherwise component for unsupported nodes
        } else {
          return this.getComponent('unsupported-node')
        }
      }
    }

    _getNodeProps (model) {
      let props = super._getNodeProps(model);
      props.placeholder = this.props.placeholder;
      return props
    }

    _handleEnterKey (event) {
      // for SHIFT-ENTER a line break is inserted (<break> if allowed, or \n alternatively)
      if (event.shiftKey) {
        event.preventDefault();
        event.stopPropagation();
        this._softBreak();
      } else {
        super._handleEnterKey(event);
      }
    }

    _softBreak () {
      let editorSession = this.getEditorSession();
      let sel = editorSession.getSelection();
      if (sel.isPropertySelection()) {
        // find out if the current node allows for <break>
        let doc = editorSession.getDocument();
        let prop = doc.getProperty(sel.start.path);
        if (prop.targetTypes && prop.targetTypes.indexOf('break') !== -1) {
          editorSession.transaction(tx => {
            let br = tx.create({ type: 'break' });
            tx.insertInlineNode(br);
          }, { action: 'soft-break' });
        } else {
          editorSession.transaction(tx => {
            tx.insertText('\n');
          }, { action: 'soft-break' });
        }
      } else {
        editorSession.transaction((tx) => {
          tx.break();
        }, { action: 'break' });
      }
    }
  }

  function getComponentForNode (comp, node) {
    let componentRegistry = comp.context.componentRegistry;
    let ComponentClass = componentRegistry.get(node.type);
    if (!ComponentClass) {
      let superTypes = node.getSchema().getSuperTypes();
      for (let superType of superTypes) {
        ComponentClass = componentRegistry.get(superType);
        if (ComponentClass) break
      }
    }
    if (!ComponentClass) {
      throw new Error(`No Component class registered for model type ${node.type}.`)
    }
    return ComponentClass
  }

  function renderNode ($$, comp, node, props = {}) {
    let NodeComponent = getComponentForNode(comp, node);
    props = Object.assign({
      disabled: comp.props.disabled,
      node
    }, props);
    return $$(NodeComponent, props)
  }

  /**
   * A component that renders a CHILDREN value.
   *
   * Note: I decided to use the name Collection here as from the application point of view a CHILDREN field is a collection.
   */
  class CollectionComponent extends substance.Component {
    render ($$) {
      const props = this.props;
      const model = props.model;
      let renderAsContainer;
      if (props.hasOwnProperty('container')) {
        renderAsContainer = Boolean(props.container);
      } else {
        renderAsContainer = model.getSchema().isContainer();
      }
      if (renderAsContainer) {
        return $$(EditableCollection, Object.assign({}, props, {
          containerPath: props.model.getPath()
        }))
      } else {
        return $$(ReadOnlyCollection, props)
      }
    }
  }

  class ReadOnlyCollection extends ValueComponent {
    // NOTE: this is less efficient than ContainerEditor as it will always render the whole collection
    render ($$) {
      let props = this.props;
      let model = props.model;
      let el = $$('div').addClass('sc-collection').attr('data-id', substance.getKeyForPath(model.getPath()));
      let items = model.getItems();
      el.append(
        items.map(item => renderNode($$, this, item, { disabled: props.disabled }).ref(item.id))
      );
      return el
    }
  }

  class EditableCollection extends ContainerEditorNew {
    _getClassNames () {
      return 'sc-collection sc-container-editor sc-surface'
    }
  }

  const DISABLED$1 = { disabled: true };

  /**
   * A component that renders a group of tools.
   *
   * @param {string} props.name
   * @param {string} props.style
   * @param {string} props.theme
   * @param {boolean} props.hideDisabled
   * @param {array} props.items array of item specifications
   * @param {object} props.commandStates command states by name
   */
  class ToolGroup extends substance.Component {
    constructor (...args) {
      super(...args);

      this._deriveState(this.props);
    }

    willReceiveProps (newProps) {
      this._deriveState(newProps);
    }

    getTheme () {
      // HACK: falling back to 'light' in a hard-coded way
      return this.props.theme || 'light'
    }

    _deriveState (props) {
      if (this._isTopLevel) {
        this._derivedState = this._deriveGroupState(props, props.commandStates);
      } else {
        this._derivedState = props.itemState;
      }
    }

    render ($$) {
      const { name, hideDisabled } = this.props;
      let el = $$('div')
        .addClass(this._getClassNames())
        .addClass('sm-' + name);

      let hasEnabledItem = this._derivedState.hasEnabledItem;
      if (hasEnabledItem || !hideDisabled) {
        el.append(this._renderLabel($$));
        el.append(this._renderItems($$));
      }

      return el
    }

    _renderLabel ($$) {
      // EXPERIMENTAL: showing a ToolGroup label an
      const { style, label } = this.props;
      if (style === 'descriptive' && label) {
        const SeparatorClass = this.getComponent('tool-separator');
        return $$(SeparatorClass, { label })
      }
    }

    _renderItems ($$) {
      const { style, hideDisabled, commandStates } = this.props;
      const theme = this.getTheme();
      const { itemStates } = this._derivedState;
      let els = [];
      for (let itemState of itemStates) {
        let item = itemState.item;
        let type = item.type;
        switch (type) {
          case 'command': {
            const commandName = item.name;
            let commandState = itemState.commandState;
            if (itemState.enabled || !hideDisabled) {
              let ToolClass = this._getToolClass(item);
              els.push(
                $$(ToolClass, {
                  item,
                  commandState,
                  style,
                  theme
                }).ref(commandName)
              );
            }
            break
          }
          case 'separator': {
            let ToolSeparator = this.getComponent('tool-separator');
            els.push(
              $$(ToolSeparator, item)
            );
            break
          }
          default: {
            if (!hideDisabled || itemState.enabled || itemState.hasEnabledItem) {
              let ToolClass = this._getToolClass(item);
              els.push(
                // ATTENTION: we are passing down options present on the current
                // group, but they can be overridden via spec
                // TODO: add all con
                $$(ToolClass, Object.assign({ hideDisabled, style }, item, {
                  commandStates,
                  itemState,
                  theme
                })).ref(item.name)
              );
            }
          }
        }
      }
      return els
    }

    get _isTopLevel () { return false }

    // ATTENTION: this is only called for top-level tool groups (Menu, Prompt, ) which are ToolDrop
    _deriveGroupState (group, commandStates) {
      let itemStates = group.items.map(item => this._deriveItemState(item, commandStates));
      let hasEnabledItem = itemStates.some(item => item.enabled || item.hasEnabledItem);
      return {
        item: group,
        itemStates,
        hasEnabledItem
      }
    }

    _deriveItemState (item, commandStates) {
      switch (item.type) {
        case 'command': {
          let commandState = commandStates[item.name] || DISABLED$1;
          return {
            item,
            commandState,
            enabled: !commandState.disabled
          }
        }
        case 'group':
        case 'dropdown':
        case 'prompt':
        case 'switcher': {
          return this._deriveGroupState(item, commandStates)
        }
        case 'separator':
        case 'spacer': {
          return { item }
        }
        default:
          throw new Error('Unsupported item type')
      }
    }

    _getClassNames () {
      return 'sc-tool-group'
    }

    _getToolClass (item) {
      // use an ToolClass from toolSpec if configured inline in ToolGroup spec
      let ToolClass;
      if (item.ToolClass) {
        ToolClass = item.ToolClass;
      } else {
        switch (item.type) {
          case 'command': {
            // try to use a tool registered by the same name as the command
            ToolClass = this.getComponent(item.name, 'no-throw');
            if (!ToolClass) {
              // using the default tool otherwise
              ToolClass = this.getComponent('tool');
            }
            break
          }
          case 'dropdown': {
            ToolClass = this.getComponent('tool-dropdown');
            break
          }
          case 'group': {
            ToolClass = this.getComponent('tool-group');
            break
          }
          case 'prompt': {
            ToolClass = this.getComponent('tool-prompt');
            break
          }
          case 'separator': {
            ToolClass = this.getComponent('tool-separator');
            break
          }
          case 'spacer': {
            ToolClass = this.getComponent('tool-spacer');
            break
          }
          case 'switcher': {
            ToolClass = this.getComponent('tool-switcher');
            break
          }
          default: {
            console.error('Unsupported item type inside ToolGroup:', item.type);
          }
        }
      }

      return ToolClass
    }
  }

  class ToolPanel extends ToolGroup {
    get _isTopLevel () { return true }
  }

  // TODO: refactor this. I don't like how this is tight to ScrollPane
  class ContextMenu extends ToolPanel {
    didMount () {
      super.didMount();
      if (!this.context.scrollPane) {
        throw new Error('Requires a scrollPane context')
      }
      this.context.scrollPane.on('context-menu:opened', this._onContextMenuOpened, this);
    }

    dispose () {
      super.dispose();
      this.context.scrollPane.off(this);
    }

    render ($$) {
      let el = $$('div')
        .addClass(this._getClassNames())
        .addClass('sm-hidden')
        .addClass('sm-theme-' + this.getTheme());
      el.append(
        $$('div').addClass('se-active-tools').append(
          this._renderItems($$)
        ).ref('entriesContainer')
      );
      return el
    }

    _getClassNames () {
      return 'sc-context-menu'
    }

    /*
      Positions the content menu relative to the scrollPane
    */
    _onContextMenuOpened (hints) {
      // ATTENTION: assuming that the context menu is always only showing enabled tools
      if (this._derivedState.hasEnabledItem) {
        let mouseBounds = hints.mouseBounds;
        this.el.removeClass('sm-hidden');
        let contextMenuWidth = this.el.htmlProp('offsetWidth');

        // By default, context menu are aligned left bottom to the mouse coordinate clicked
        this.el.css('top', mouseBounds.top);
        let leftPos = mouseBounds.left;
        // Must not exceed left bound
        leftPos = Math.max(leftPos, 0);
        // Must not exceed right bound
        let maxLeftPos = mouseBounds.left + mouseBounds.right - contextMenuWidth;
        leftPos = Math.min(leftPos, maxLeftPos);
        this.el.css('left', leftPos);
      }
    }
  }

  /*
    This is an eperimental wrap component for rendering a section in dialogs
    with label and description on top of content.
    Example:
    ```
      $$(DialogSectionComponent, {label: 'Enter DOI', description: 'use a comma to separate values'})
        .append($$(DOIInput))
    ```
  */
  class DialogSectionComponent extends substance.Component {
    render ($$) {
      const label = this.props.label;
      const description = this.props.description;
      const children = this.props.children;

      const el = $$('div').addClass('sc-dialog-section');

      if (label) {
        const sectionTitleEl = $$('div').addClass('se-dialog-section-title').append(
          $$('div').addClass('se-label').append(label)
        );
        if (description) {
          sectionTitleEl.append(
            $$('div').addClass('se-description').append(description)
          );
        }
        el.append(sectionTitleEl);
      }
      el.append(
        $$('div').addClass('se-dialog-section-content').append(children)
      );
      return el
    }
  }

  /**
    @param {string} props.text
  */
  class Tooltip extends substance.Component {
    render ($$) {
      let el = $$('div').addClass('sc-tooltip');
      el.append(this.props.text);
      return el
    }
  }

  class FormRowComponent extends substance.Component {
    render ($$) {
      const label = this.props.label;
      const issues = this.props.issues || [];
      const hasIssues = issues.length > 0;
      const children = this.props.children;

      const el = $$('div').addClass('sc-form-row');

      if (label) {
        const labelEl = $$('div').addClass('se-label').append(label);
        if (hasIssues) {
          // TODO: use issue.key and labelProvider here
          let tooltipText = issues.map(issue => issue.message).join(', ');
          labelEl.append(
            $$('div').addClass('se-warning').append(
              $$(substance.FontAwesomeIcon, { icon: 'fa-warning' }).addClass('se-icon'),
              $$(Tooltip, { text: tooltipText })
            )
          );
        }
        el.append(labelEl);
      }
      if (hasIssues) {
        el.addClass('sm-warning');
      }
      el.append(
        $$('div').addClass('se-editor').append(children)
      );
      return el
    }
  }

  class InputWithButton extends substance.Component {
    render ($$) {
      let input = this.props.input;
      let button = this.props.button;

      let el = $$('div').addClass('sc-input-with-button');

      if (input) el.append(input.addClass('se-input'));
      if (button) el.append(button.addClass('se-button'));

      return el
    }
  }

  /*
    This is overriding Substance.IsolatedInlineNodeComponent to support Models.
  */
  class IsolatedInlineNodeComponentNew extends substance.IsolatedInlineNodeComponent {
    // overriding AbstractIsolatedNodeComponent.didMount() because it uses deprecated EditorSession.onRender()
    didMount () {
      let appState = this.context.appState;
      appState.addObserver(['selection'], this._onSelectionChanged, this, { stage: 'render' });
    }

    // overriding AbstractIsolatedNodeComponent.dispose() because it uses EditorSession.off() in a way which has been deprecated
    dispose () {
      this.context.appState.off(this);
    }
  }

  /*
    This is overriding Substance.IsolatedInlineNodeComponent
      - to support Models.
      - to make all IsolatedNodeComponents 'open'
  */
  class IsolatedNodeComponentNew extends substance.IsolatedNodeComponent {
    constructor (parent, props, options) {
      super(parent, props, options);
      // HACK: overriding 'closed' IsolatedNodeComponents per se
      // TODO: on the long term we need to understand if it may be better to open
      // IsolatedNodes by default and only close them if needed.
      // The UX is improved much also in browsers like FF.
      // Still we need to evaluate this decision in the near future.
      this.blockingMode = 'open';
    }

    // overriding AbstractIsolatedNodeComponent.didMount() because it uses deprecated EditorSession.onRender()
    didMount () {
      let appState = this.context.appState;
      appState.addObserver(['selection'], this._onSelectionChanged, this, { stage: 'render' });
    }

    // overriding AbstractIsolatedNodeComponent.dispose() because it uses EditorSession.off() in a way which has been deprecated
    dispose () {
      this.context.appState.off(this);
    }

    // overriding the core implementation to select the node on all unhandled clicks.
    // Note: this caused a regression, because the original InlineNode component was letting events bubble up.
    onClick (event) {
      event.stopPropagation();
      event.preventDefault();
      this.selectNode();
    }
  }

  const _ManagedComponentCache = new Map();

  /*
    Example:
    ```
    $$(Managed(Toolbar), { bindings: ['commandState'] })
    ```
    `commandStates` will be taken from the app-state, and merged with the other props.
    When `commandStates` is changed, Toolbar automatically will be rerendered automatically via extendProps.
  */
  function Managed (ComponentClass) {
    if (_ManagedComponentCache.has(ComponentClass)) return _ManagedComponentCache.get(ComponentClass)

    // an anonymous class that takes care of mapping props that start with $
    class ManagedComponent extends substance.Component {
      constructor (...args) {
        super(...args);

        if (!this.context.appState) {
          throw new Error("'context.appState' is required for Managed Components.")
        }
        this._config = this._compileManagedProps(this.props);
        this._props = this._deriveManagedProps(this.props);
      }

      didMount () {
        if (this._config) {
          this._register();
        }
      }

      willReceiveProps (newProps) {
        let config = this._compileManagedProps(newProps);
        let props = this._deriveManagedProps(newProps);
        if (!this._config && config) {
          this._register();
        } else if (this._config && !config) {
          this._deregister();
        }
        this._config = config;
        this._props = props;
      }

      dispose () {
        this.context.appState.off(this);
      }

      render ($$) {
        return $$(ComponentClass, this._props).ref('managed')
      }

      _register () {
        const { stage, names } = this._config;
        this.context.appState.addObserver(names, this._onUpdate, this, { stage });
      }

      _deregister () {
        this.context.appState.off(this);
      }

      _onUpdate () {
        this._props = this._deriveManagedProps();
        this.refs.managed.extendProps(this._props);
      }

      _compileManagedProps (props) {
        let stage = 'render';
        let names = props.bindings || [];
        if (names.length > 0) {
          return { stage, names }
        } else {
          return null
        }
      }

      _deriveManagedProps (props) {
        const state = this.context.appState;
        const config = this._config;
        if (config) {
          let derivedProps = Object.assign({}, props);
          delete derivedProps.bindings;
          config.names.forEach(name => {
            derivedProps[name] = state.get(name);
          });
          return derivedProps
        } else {
          return props
        }
      }
    }

    _ManagedComponentCache.set(ComponentClass, ManagedComponent);

    return ManagedComponent
  }

  function OverlayMixin (Component) {
    class OverlayComponent extends Component {
      didMount () {
        super.didMount();

        let appState = this.context.appState;

        appState.addObserver(['overlayId'], this._onOverlayIdHasChanged, this, { stage: 'render' });
      }

      dispose () {
        super.dispose();

        this.context.appState.removeObserver(this);
      }

      _getOverlayId () {
        return this.getId()
      }

      _canShowOverlay () {
        return this.context.appState.overlayId === this._getOverlayId()
      }

      _toggleOverlay () {
        this.send('toggleOverlay', this._getOverlayId());
      }

      _onOverlayIdHasChanged () {
        // console.log('Rerendering overlay component because overlay id has changed', this._getOverlayId()')
        this.rerender();
      }
    }
    return OverlayComponent
  }

  class MultiSelectInput extends OverlayMixin(substance.Component) {
    getInitialState () {
      return {
        isExpanded: this._canShowOverlay()
      }
    }

    willReceiveProps () {
      this.extendState(this.getInitialState());
    }

    render ($$) {
      const selected = this.props.selected;
      const isEmpty = selected.length === 0;
      const selectedLabels = selected.map(item => item.toString());
      const isExpanded = this.state.isExpanded;
      const label = isEmpty ? this.getLabel('multi-select-default-value') : selectedLabels.join('; ');

      const el = $$('div').addClass('sc-multi-select-input');
      if (isEmpty) el.addClass('sm-empty');
      el.addClass(isExpanded ? 'sm-expanded' : 'sm-collapsed');
      el.append(
        $$('div').addClass('se-label').text(label)
      );
      if (isExpanded) {
        el.addClass('sm-active');
        el.append(
          this._renderOptions($$)
        );
      }
      el.on('click', this._onClick)
        .on('dblclick', this._stopAndPreventDefault)
        .on('mousedown', this._stopAndPreventDefault);

      return el
    }

    _renderOptions ($$) {
      const label = this.props.label;
      const selected = this.props.selected;
      const selectedIdx = selected.map(item => item.id);
      const options = this._getOptions();
      const editorEl = $$('div').ref('options').addClass('se-select-editor').append(
        $$('div').addClass('se-arrow'),
        $$('div').addClass('se-select-label')
          .append(label)
      );
      options.forEach(option => {
        const isSelected = selectedIdx.indexOf(option.id) > -1;
        const icon = isSelected ? 'checked-item' : 'unchecked-item';
        editorEl.append(
          $$('div').addClass('se-select-item').addClass(isSelected ? 'sm-selected' : '').append(
            this.context.iconProvider.renderIcon($$, icon).addClass('se-icon'),
            $$('div').addClass('se-item-label')
              // TODO: I would like to have this implementation more agnostic of a specific data structure
              .append(option.toString()).ref(option.id)
          ).on('click', this._onToggleItem.bind(this, option))
        );
      });
      return editorEl
    }

    _getOverlayId () {
      return this.props.overlayId || this.getId()
    }

    _getOptions () {
      return this.getParent().getAvailableOptions()
    }

    // toggleOption (event) {
    //   event.preventDefault()
    //   event.stopPropagation()
    //   super._toggleOverlay()
    // }

    _stopAndPreventDefault (event) {
      event.stopPropagation();
      event.preventDefault();
    }

    _onClick (event) {
      this._stopAndPreventDefault(event);
      super._toggleOverlay();
    }

    _onOverlayIdHasChanged () {
      let overlayId = this.context.appState.overlayId;
      let id = this._getOverlayId();
      let needUpdate = false;
      if (this.state.isExpanded) {
        needUpdate = (overlayId !== id);
      } else {
        needUpdate = (overlayId === id);
      }
      if (needUpdate) {
        this.extendState(this.getInitialState());
      }
    }

    _onToggleItem (option, event) {
      event.stopPropagation();
      event.preventDefault();
      this.send('toggleOption', option);
    }
  }

  class ManyRelationshipComponent extends ValueComponent {
    didMount () {
      // ATTENTION: relationships are unfortunately tricky regarding updates
      // obvious things are covered by the used helper, e.g., if the model is changed
      // or a one of the used targets has been removed
      // Other things are pretty much impossible to detect in a general way
      // e.g. the creation of a new target, or the deletion of an existing one
      // In this case the selection will be out of sync, and hopefully the implementation does react correctly
      // TODO: make sure that this is the case
      this.context.appState.addObserver(['document'], this._rerenderOnModelChangeIfNecessary, this, { stage: 'render' });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    render ($$) {
      const label = this.getLabel('select-item') + ' ' + this.props.label;
      const options = this.getAvailableOptions();
      let selected = this._getSelectedOptions(options);
      let el = $$('div').addClass(this._getClassNames());
      if (this.context.editable) {
        el.append(
          $$(MultiSelectInput, {
            label,
            selected,
            overlayId: this.props.model.id
          })
        );
      } else {
        const selectedLabels = selected.map(item => item ? item.toString() : null).filter(Boolean);
        let label = selectedLabels.join('; ');
        el.addClass('sm-readonly').append(label);
      }
      return el
    }

    _getClassNames () {
      return 'sc-many-relationship'
    }

    getActionHandlers () {
      return {
        toggleOption: this._toggleTarget,
        toggleOverlay: this._toggleOverlay
      }
    }

    getAvailableOptions () {
      return this.props.model.getAvailableOptions()
    }

    _getSelectedOptions (options) {
      // pick all selected items from options this makes life easier for the MutliSelectComponent
      // because it does not need to map via ids, just can check equality
      let targetIds = this.props.model.getValue();
      let selected = targetIds.map(id => options.find(item => item.id === id)).filter(Boolean);
      return selected
    }

    _toggleTarget (target) {
      if (this.context.editable) {
        this.props.model.toggleTarget(target);
      }
    }

    _toggleOverlay () {
      const appState = this.context.appState;
      let overlayId = appState.overlayId;
      let modelId = this.props.model.id;
      if (overlayId === modelId) {
        this.getParent().send('toggleOverlay');
      } else {
        // ATTENTION: At the moment a reducer maps value selections to appState.overlayId
        // i.e. we must not call toggleOverlay
        // But if we decided to disable the reducer this would break if
        // we used the common implementation.
        // TODO: rethink this approach in general
        this.context.api.selectValue(this._getPath());
        // DO NOT UNCOMMENT THIS LINE
        // appState.set('overlayId', modelId, 'propagateImmediately')
      }
    }

    _rerenderOnModelChangeIfNecessary (change) {
      let updateNeeded = Boolean(change.hasUpdated(this._getPath()));
      if (!updateNeeded) {
        let ids = this.props.model.getValue();
        if (ids) {
          if (!substance.isArray(ids)) {
            ids = [ids];
          }
          for (let id of ids) {
            if (change.hasDeleted(id) || change.hasUpdated(id)) {
              updateNeeded = true;
              break
            }
          }
        }
      }
      if (updateNeeded) {
        this._rerenderOnModelChange();
      }
    }

    _rerenderOnModelChange () {
      // console.log('Rerendering RelationshipComponent because model has changed', this._getPath())
      this.rerender();
    }
  }

  /**
    ModalDialog component

    @class
    @component

    @prop {String} width 'small', 'medium', 'large' and 'full'

    @example

    ```js
    var form = $$(ModalDialog, {
      width: 'medium',
      textAlign: 'center'
    });
    ```
  */
  class ModalDialog extends substance.Component {
    render ($$) {
      let el = $$('div').addClass('sc-modal-dialog');
      let width = this.props.width || 'large';

      // TODO: don't think that this is good enough. Right the modal is closed by any unhandled click.
      // Need to be discussed.
      el.on('click', this._closeModal);
      el.on('keydown', this._onKeydown);

      if (this.props.width) {
        el.addClass('sm-width-' + width);
      }

      if (this.props.transparent) {
        el.addClass('sm-transparent-bg');
      }

      el.append(
        $$('div').addClass('se-body').append(
          this.props.children
        )
      );
      return el
    }

    _onKeydown (e) {
      e.stopPropagation();
    }

    _closeModal (e) {
      e.preventDefault();
      e.stopPropagation();
      // wrap the target so that we can use DOMElement API
      let targetEl = substance.DefaultDOMElement.wrap(e.target);
      let closeSurfaceClick = targetEl.hasClass('sc-modal-dialog');
      if (closeSurfaceClick) {
        this.send('closeModal');
      }
    }
  }

  class ModelComponent extends substance.Component {
    didMount () {
      addModelObserver(this.props.model, this.rerender, this);
    }

    dispose () {
      removeModelObserver(this);
    }

    // EXPERIMENTAL:
    // trying to avoid unnecessary rerenderings
    shouldRerender (newProps) {
      return newProps.model !== this.props.model
    }
  }

  /*
    Overridden version of Substance.Surface with modifications from 'ModifiedSurface'
  */
  class SurfaceNew extends ModifiedSurface(substance.Surface) {}

  class TextInput extends SurfaceNew {
    render ($$) {
      const TextPropertyComponent = this.getComponent('text-property');
      const placeholder = this.props.placeholder;
      const path = this.props.path;
      const isEditable = this.isEditable();
      // TODO: we should refactor Substance.TextPropertyEditor so that it can be used more easily
      let el = SurfaceNew.prototype.render.apply(this, arguments);
      el.addClass('sc-text-input');
      // Attention: being disabled does not necessarily mean not-editable, whereas non-editable is always disabled
      // A Surface can also be disabled because it is blurred, for instance.
      if (isEditable) {
        el.addClass('sm-editable');
        if (!this.props.disabled) {
          el.addClass('sm-enabled');
          el.attr('contenteditable', true);
          // native spellcheck
          el.attr('spellcheck', this.props.spellcheck === 'native');
        }
      } else {
        el.addClass('sm-readonly');
      }
      let content = $$(TextPropertyComponent, {
        doc: this.getDocument(),
        tagName: 'div',
        placeholder,
        path
      }).addClass('se-input');
      el.append(content);
      return el
    }

    // this is needed e.g. by SelectAllCommand
    get _isTextPropertyEditor () {
      return true
    }

    // this is needed e.g. by SelectAllCommand
    getPath () {
      return this.props.path
    }
  }

  class StringComponent extends substance.Component {
    render ($$) {
      let placeholder = this.props.placeholder;
      let model = this.props.model;
      let path = model.getPath();
      let name = substance.getKeyForPath(path);
      let el = $$('div').addClass(this.getClassNames());
      if (this.props.readOnly) {
        let doc = this.context.api.getDocument();
        let TextPropertyComponent = this.getComponent('text-property');
        el.append(
          $$(TextPropertyComponent, {
            doc,
            tagName: 'div',
            placeholder,
            path
          })
        );
      } else {
        el.append(
          $$(TextInput, {
            name,
            path,
            placeholder
          })
        );
      }
      return el
    }

    getClassNames () {
      return 'sc-string'
    }
  }

  class TextComponent extends StringComponent {
    getClassNames () {
      return 'sc-text'
    }
  }

  class ObjectComponent extends ValueComponent {
    render ($$) {
      let el = $$('div').addClass('sc-object');
      // TODO: implement a default editor for object type values
      return el
    }
  }

  class SingleRelationshipComponent extends ManyRelationshipComponent {
    _getClassNames () {
      return 'sc-single-relationship'
    }

    _getSelectedOptions (options) {
      let targetId = this.props.model.getValue();
      if (!targetId) return []
      let selectedOption = options.find(item => {
        if (item) return item.id === targetId
      });
      let selected = selectedOption ? [selectedOption] : [];
      return selected
    }
  }

  class TextNodeComponent extends substance.Component {
    /*
      ATTENTION: There is another mechanism which leads to rerendering of TextPropertyComponents (-> MarkersManager)
      HACK: To avoid double rendering of text nodes, we do not register for updates here
      TODO: rethink this.
    */
    didMount () {}

    render ($$) {
      let parentSurface = this.context.surface;
      let TextPropertyComponent;
      // render the TextNode as Surface if the parent is not a ContainerEditor
      if (parentSurface && parentSurface.isContainerEditor()) {
        // Note: when inside a ContainerEditor, then this is not a editor itself
        TextPropertyComponent = this.getComponent('text-property');
      } else {
        TextPropertyComponent = this.getComponent('text-property-editor');
      }
      const node = this.props.node;
      const tagName = this.getTagName();
      const path = node.getPath();
      let el = $$(tagName)
        .addClass(this.getClassNames())
        .attr('data-id', node.id);
      el.append(
        $$(TextPropertyComponent, {
          doc: node.getDocument(),
          name: substance.getKeyForPath(path),
          path,
          placeholder: this.props.placeholder
        })
      );
      // TODO: ability to edit attributes
      return el
    }

    getTagName () {
      return 'div'
    }

    getClassNames () {
      // TODO: don't violate the 'sc-' contract
      return 'sc-text-node sm-' + this.props.node.type
    }
  }

  var ModelComponentPackage = {
    name: 'Model Components',
    configure (configurator) {
      // TODO: maybe we want to use just '<type>' as name instead of '<type>-model'
      configurator.addComponent('boolean', BooleanComponent);
      configurator.addComponent('child', ChildComponent);
      // TODO: do we need this anymore?
      configurator.addComponent('collection', CollectionComponent);
      configurator.addComponent('many-relationship', ManyRelationshipComponent);
      configurator.addComponent('object', ObjectComponent);
      configurator.addComponent('single-relationship', SingleRelationshipComponent);
      configurator.addComponent('string', StringComponent);
      configurator.addComponent('text', TextComponent);
      // LEGACY
      // TODO: do we need this anymore?
      configurator.addComponent('text-node', TextNodeComponent);
    }
  }

  function getSettings (comp) {
    let appState = comp.context.appState;
    return appState.settings
  }

  function renderModel ($$, comp, valueModel, options = {}) {
    let ValueComponent = comp.getComponent(valueModel.type);

    let valueSettings;
    let settings = getSettings(comp);
    if (settings) {
      valueSettings = settings.getSettingsForValue(valueModel.getPath());
    }
    let props = Object.assign({
      disabled: comp.props.disabled,
      // TODO: rename 'model' to 'value' (then we have it is clear when node and when values are used)
      model: valueModel
    }, valueSettings, options);
    return $$(ValueComponent, props)
  }

  function renderValue ($$, comp, doc, path, options = {}) {
    let prop = doc.getProperty(path);
    let valueModel = createValueModel(comp.context.editorSession, path, prop);
    return renderModel($$, comp, valueModel, options)
  }

  function NodeComponentMixin (Component) {
    return class NodeComponent extends Component {
      didMount () {
        super.didMount();
        const node = this._getNode();
        this.context.appState.addObserver(['document'], this._onNodeUpdate, this, { document: { path: [node.id] }, stage: 'render' });
      }

      dispose () {
        super.dispose();

        this.context.appState.off(this);
      }

      _getNode () {
        return this.props.node
      }

      _renderValue ($$, propertyName, options = {}) {
        let node = this._getNode();
        let doc = node.getDocument();
        return renderValue($$, this, doc, [node.id, propertyName], options)
      }

      _onNodeUpdate () {
        this.rerender();
      }
    }
  }

  class NodeComponent extends NodeComponentMixin(substance.Component) {}

  /**
    @param {object} overlayHints hints derived from the rendered selection.
  */
  class Overlay extends ToolPanel {
    didMount () {
      super.didMount();

      this._positionOverlay();

      // TODO: avoid using appState directly, instead use a Managed component
      this.context.appState.addObserver(['overlayHints'], this._positionOverlay, this, { stage: 'finalize' });
    }

    dispose () {
      super.dispose();

      this.context.appState.removeObserver(this);
    }

    didUpdate () {
      super.didUpdate();

      this._positionOverlay();
    }

    render ($$) {
      let el = $$('div').addClass('sc-overlay');
      el.addClass('sm-hidden');
      el.addClass('sm-theme-' + this.getTheme());
      el.append(
        $$('div').addClass('se-active-tools').append(
          this._renderItems($$)
        ).ref('entriesContainer')
      );
      return el
    }

    _positionOverlay () {
      let hints = this.context.appState.get('overlayHints');
      let hasEnabledItem = this._derivedState.hasEnabledItem;
      if (hints && hasEnabledItem) {
        this.el.removeClass('sm-hidden');
        let overlayWidth = this.el.htmlProp('offsetWidth');
        let selRect = hints.selectionRect;
        if (selRect) {
          let selectionMaxWidth = selRect.width;
          // By default, Overlays are aligned center/bottom to the selection
          this.el.css('top', selRect.top + selRect.height);
          let leftPos = selRect.left + selectionMaxWidth / 2 - overlayWidth / 2;
          // Must not exceed left bound
          leftPos = Math.max(leftPos, 0);
          // Must not exceed right bound
          let maxLeftPos = selRect.left + selectionMaxWidth + selRect.right - overlayWidth;
          leftPos = Math.min(leftPos, maxLeftPos);
          this.el.css('left', leftPos);
        } else {
          this.el.addClass('sm-hidden');
        }
      } else {
        this.el.addClass('sm-hidden');
      }
    }
  }

  class PinnedMessage extends substance.Component {
    render ($$) {
      const icon = this.props.icon;
      const label = this.props.label;

      const el = $$('div').addClass('sc-pinned-message');
      const wrapper = $$('div').addClass('se-msg-wrap');

      if (icon) {
        wrapper.append(
          $$(substance.FontAwesomeIcon, { icon }).addClass('se-icon')
        );
      }

      if (label) {
        wrapper.append(
          $$('div').addClass('se-msg')
            .append(label)
        );
      }

      el.append(wrapper);

      return el
    }
  }

  /**
    Wraps content in a scroll pane.

    NOTE: It is best practice to put all overlays as direct childs of the ScrollPane
          to reduce the chance that positioning gets messed up (position: relative)

    @prop {String} scrollbarType 'native' or 'substance' for a more advanced visual scrollbar. Defaults to 'native'
    @prop {String} [scrollbarPosition] 'left' or 'right' only relevant when scrollBarType: 'substance'. Defaults to 'right'
    @prop {ui/Highlights} [highlights] object that maintains highlights and can be manipulated from different sources

    @example

    ```js
    $$(ScrollPane, {
      scrollbarType: 'substance', // defaults to native
      scrollbarPosition: 'left', // defaults to right
      onScroll: this.onScroll.bind(this),
      highlights: this.contentHighlights,
    })
    ```
  */
  class ScrollPane extends AbstractScrollPane {
    didMount () {
      super.didMount();

      // TODO: these should come from AppState
      if (this.refs.scrollbar && this.props.highlights) {
        this.props.highlights.on('highlights:updated', this.onHighlightsUpdated, this);
      }

      if (this.refs.scrollbar) {
        if (substance.platform.inBrowser) {
          this.domObserver = new window.MutationObserver(this._onContentChanged.bind(this));
          this.domObserver.observe(this.el.getNativeElement(), {
            subtree: true,
            attributes: true,
            characterData: true,
            childList: true
          });
        }
      }
    }

    dispose () {
      super.dispose();

      if (this.props.highlights) {
        this.props.highlights.off(this);
      }
      if (this.domObserver) {
        this.domObserver.disconnect();
      }
    }

    render ($$) {
      let el = $$('div')
        .addClass('sc-scroll-pane');

      if (substance.platform.isFF) {
        el.addClass('sm-firefox');
      }

      // When noStyle is provided we just use ScrollPane as a container, but without
      // any absolute positioned containers, leaving the body scrollable.
      if (!this.props.noStyle) {
        el.addClass('sm-default-style');
      }

      // Initialize Substance scrollbar (if enabled)
      if (this.props.scrollbarType === 'substance') {
        el.addClass('sm-substance-scrollbar');
        el.addClass('sm-scrollbar-position-' + this.props.scrollbarPosition);

        el.append(
          // TODO: is there a way to pass scrollbar highlights already
          // via props? Currently the are initialized with a delay
          $$(substance.Scrollbar, {
            scrollPane: this
          }).ref('scrollbar')
            .attr('id', 'content-scrollbar')
        );

        // Scanline is debugging purposes, display: none by default.
        el.append(
          $$('div').ref('scanline').addClass('se-scanline')
        );
      }

      el.append(
        $$('div').ref('scrollable').addClass('se-scrollable').append(
          this.renderContent($$)
        ).on('scroll', this.onScroll)
      );
      return el
    }

    renderContent ($$) {
      let contentEl = $$('div').ref('content').addClass('se-content');
      contentEl.append(this.props.children);
      if (this.props.contextMenu === 'custom') {
        contentEl.on('contextmenu', this._onContextMenu);
      }
      return contentEl
    }

    _onContentChanged () {
      this._contentChanged = true;
    }

    _afterRender () {
      super._afterRender();

      if (this.refs.scrollbar && this._contentChanged) {
        this._contentChanged = false;
        this._updateScrollbar();
      }
    }

    _updateScrollbar () {
      if (this.refs.scrollbar) {
        this.refs.scrollbar.updatePositions();
      }
    }

    onHighlightsUpdated (highlights) {
      this.refs.scrollbar.extendProps({
        highlights: highlights
      });
    }

    onScroll () {
      let scrollPos = this.getScrollPosition();
      let scrollable = this.refs.scrollable;
      if (this.props.onScroll) {
        this.props.onScroll(scrollPos, scrollable);
      }
      // FIXME: bring back TOC activeEntry
      // if (this.props.tocProvider) {
      //   this.props.tocProvider.markActiveEntry(this)
      // }
      this.emit('scroll', scrollPos, scrollable);
    }

    /**
      Returns the height of scrollPane (inner content overflows)
    */
    getHeight () {
      let scrollableEl = this.getScrollableElement();
      return scrollableEl.height
    }

    /**
      Returns the cumulated height of a panel's content
    */
    getContentHeight () {
      let contentEl = this.refs.content.el.getNativeElement();
      // Important to use scrollHeight here (e.g. to consider overflowing
      // content, that stretches the content area, such as an overlay or
      // a context menu)
      return contentEl.scrollHeight
    }

    /**
      Get the `.se-content` element
    */
    getContentElement () {
      return this.refs.content.el
    }

    /**
      Get the `.se-scrollable` element
    */
    getScrollableElement () {
      return this.refs.scrollable.el
    }

    /**
      Get current scroll position (scrollTop) of `.se-scrollable` element
    */
    getScrollPosition () {
      let scrollableEl = this.getScrollableElement();
      return scrollableEl.getProperty('scrollTop')
    }

    setScrollPosition (scrollPos) {
      // console.log('ScrollPane.setScrollPosition()')
      let scrollableEl = this.getScrollableElement();
      scrollableEl.setProperty('scrollTop', scrollPos);
    }

    /**
      Get offset relative to `.se-content`.

      @param {DOMNode} el DOM node that lives inside the
    */
    getPanelOffsetForElement (el) {
      let contentContainerEl = this.refs.content.el;
      let rect = substance.getRelativeBoundingRect(el, contentContainerEl);
      return rect.top
    }

    /**
      Scroll to a given sub component.

      @param {String} componentId component id, must be present in data-id attribute
    */
    scrollTo (selector, onlyIfNotVisible) {
      // console.log('ScrollPane.scrollTo()', selector)
      let scrollableEl = this.getScrollableElement();
      let el = scrollableEl.find(selector);
      if (el) {
        this.scrollElementIntoView(el, onlyIfNotVisible);
      } else {
        console.warn(`No match found for selector '${selector}' in scrollable container`);
      }
    }

    scrollElementIntoView (el, onlyIfNotVisible) {
      // console.log('ScrollPane.scrollTo()', selector)
      let scrollableEl = this.getScrollableElement();
      const offset = this.getPanelOffsetForElement(el);
      let shouldScroll = true;
      if (onlyIfNotVisible) {
        const height = scrollableEl.height;
        const oldOffset = scrollableEl.getProperty('scrollTop');
        shouldScroll = (offset < oldOffset || oldOffset + height < offset);
      }
      if (shouldScroll) {
        this.setScrollPosition(offset);
      }
    }

    _onResize (...args) {
      super._onResize(...args);
      this._updateScrollbar();
    }

    _onContextMenu (e) {
      super._onContextMenu(e);
      this._updateScrollbar();
    }
  }

  /**
   * Overriding the original implementation
   * 1. to retrieve markers from MarkersManager in addition to Annotations
   * 2. to change the way how place-holders are rendered
   * 3. to provide default implementation for unsupported inline nodes
  */
  class TextPropertyComponentNew extends substance.TextPropertyComponent {
    didMount () {
      this.context.appState.addObserver(['document'], this.rerender, this, { stage: 'render', document: { path: this.getPath() } });
    }

    dispose () {
      this.context.appState.off(this);
    }

    render ($$) {
      let path = this.getPath();

      let el = this._renderContent($$)
        .addClass('sc-text-property')
        .attr({
          'data-path': substance.getKeyForPath(path)
        })
        .css({
          'white-space': 'pre-wrap'
        });

      if (this.isEmpty()) {
        el.addClass('sm-empty');
        if (this.props.placeholder) {
          el.setAttribute('data-placeholder', this.props.placeholder);
        }
      }

      if (!this.props.withoutBreak) {
        el.append($$('br'));
      }

      return el
    }

    getAnnotations () {
      let path = this.getPath();
      let annos = this.getDocument().getAnnotations(path) || [];
      let markersManager = this.context.markersManager;
      if (markersManager) {
        annos = annos.concat(markersManager.getMarkers(path));
      }
      return annos
    }

    _getUnsupportedInlineNodeComponentClass () {
      return this.getComponent('unsupported-inline-node')
    }
  }

  /*
    Overridden version of Substance.TextPropertyEditor to support Models and new AppState API
  */
  class TextPropertyEditorNew extends ModifiedSurface(substance.TextPropertyEditor) {
    // overriding event registration
    didMount () {
      super.didMount();

      let appState = this.context.appState;
      appState.addObserver(['selection'], this._onSelectionChanged, this, {
        stage: 'render'
      });
    }

    dispose () {
      super.dispose();

      this.context.appState.off(this);
    }

    render ($$) {
      let el = super.render($$);

      // We have added these improvements:
      // - editable vs read-only
      // - disabling contenteditable in read-only mode
      if (this.isEditable()) {
        el.addClass('sm-editable');
      } else {
        el.addClass('sm-readonly');
        // HACK: removing contenteditable if not editable
        // TODO: we should fix substance.TextPropertyEditor to be consistent with props used in substance.Surface
        el.setAttribute('contenteditable', false);
      }
      return el
    }
  }

  /**
   *
   * @param {string} props.style menu style, one of 'minimal', 'descriptive', 'full'
   * @param {string} props.theme
   * @param {object} props.item
   * @param {object} props.commandState
   */
  class Tool extends substance.Component {
    render ($$) {
      const { style, theme, commandState } = this.props;
      let el;
      switch (style) {
        case 'minimal': {
          el = $$(Button, {
            style,
            theme,
            icon: this._getIconName(),
            tooltip: this._getTooltipText()
          });
          break
        }
        case 'descriptive': {
          // TODO: try to use Button instead
          el = $$('button');
          el.append(
            this._renderLabel($$),
            this._renderKeyboardShortcut($$)
          );
          break
        }
        default: {
          // TODO: try to use Button instead
          el = $$('button');
          el.append(
            this._renderIcon($$),
            this._renderLabel($$),
            this._renderKeyboardShortcut($$)
          );
        }
      }
      el.addClass(this.getClassNames());
      el.on('click', this._onClick)
        // ATTENTION: we need to preventDefault on mousedown, otherwise
        // native DOM selection disappears
        .on('mousedown', this._onMousedown);

      if (commandState.active) {
        el.addClass('sm-active');
      }
      if (commandState.disabled) {
        // make button inaccessible
        el.attr('tabindex', -1)
          .attr('disabled', true);
      } else {
        // make button accessible for tab-navigation
        el.attr('tabindex', 1);
      }

      return el
    }

    click () {
      return this.el.click()
    }

    executeCommand (params) {
      const { item, commandState } = this.props;
      // TODO: rethink this. Should we inhibit command execution here
      // or rely on the command not to execute when disabled?
      if (!commandState.disabled) {
        this.send('executeCommand', item.name, params);
      }
    }

    getClassNames () {
      return `sc-tool sm-${this.props.item.name}`
    }

    _getLabel () {
      const { item, commandState } = this.props;
      const labelName = item.label || item.name;
      const labelProvider = this.context.labelProvider;
      return labelProvider.getLabel(labelName, commandState)
    }

    _getIconName () {
      const item = this.props.item;
      const iconName = item.icon || item.name;
      return iconName
    }

    _getKeyboardShortcut () {
      const name = this.props.item.name;
      const config = this.context.config;
      return config.getKeyboardShortcutsByCommandName(name)
    }

    _getTooltipText () {
      const label = this._getLabel();
      const keyboardShortcut = this._getKeyboardShortcut();
      if (keyboardShortcut) {
        return [label, ' (', keyboardShortcut, ')'].join('')
      } else {
        return label
      }
    }

    _renderLabel ($$) {
      return $$('div').addClass('se-label').append(
        this._getLabel()
      )
    }

    _renderIcon ($$) {
      const iconName = this._getIconName();
      return $$('div').addClass('se-icon').append(
        this.context.iconProvider.renderIcon($$, iconName)
      )
    }

    _renderKeyboardShortcut ($$) {
      const keyboardShortcut = this._getKeyboardShortcut();
      return $$('div').addClass('se-keyboard-shortcut').append(
        keyboardShortcut || ''
      )
    }

    _onClick (e) {
      e.preventDefault();
      e.stopPropagation();
      this.executeCommand();
    }

    _onMousedown (e) {
      e.preventDefault();
    }

    // this is used by TextureConfigurator
    get _isTool () {
      return true
    }
  }

  /**
   * @param {string} props.style
   * @param {string} props.theme
   * @param {object} props.item
   * @param {object} props.commandState
   */
  class ToggleTool extends Tool {
    getClassNames () {
      return `sc-toggle-tool sc-tool sm-${this.props.item.name}`
    }
  }

  class Toolbar extends ToolPanel {
    render ($$) {
      let el = $$('div').addClass('sc-toolbar');
      el.append(
        $$('div').addClass('se-active-tools').append(
          this._renderItems($$)
        ).ref('entriesContainer')
      );
      return el
    }
  }

  // TODO: use OverlayMixin to avoid code redundancy
  class ToolDropdown extends ToolGroup {
    didMount () {
      this.context.appState.addObserver(['overlayId'], this.rerender, this, { stage: 'render' });
    }
    dispose () {
      this.context.appState.removeObserver(this);
    }
    render ($$) {
      const appState = this.context.appState;
      const { commandStates, style, theme, hideDisabled, alwaysVisible } = this.props;
      const toggleName = this._getToggleName();
      const hasEnabledItem = this._derivedState.hasEnabledItem;
      const showChoices = appState.overlayId === this.getId();

      let el = $$('div').addClass('sc-tool-dropdown');
      el.addClass('sm-' + this.props.name);

      if (!hasEnabledItem) {
        el.addClass('sm-disabled');
      } else if (showChoices) {
        el.addClass('sm-open');
      }

      if (!hideDisabled || hasEnabledItem || alwaysVisible) {
        const Button = this.getComponent('button');
        let toggleButtonProps = {
          dropdown: true,
          active: showChoices,
          theme,
          // HACK: we are passing the command state allowing to render labels with template strings
          commandState: commandStates[toggleName]
        };
        if (style === 'minimal') {
          toggleButtonProps.icon = toggleName;
        } else {
          toggleButtonProps.label = toggleName;
        }
        let toggleButton = $$(Button, toggleButtonProps).ref('toggle')
          .addClass('se-toggle')
          .on('click', this._onClick)
          // ATTENTION: we need to preventDefault on mousedown, otherwise
          // native DOM selection disappears
          .on('mousedown', this._onMousedown);
        el.append(toggleButton);

        if (showChoices) {
          el.append(
            $$('div').addClass('se-choices').append(
              this._renderItems($$)
            ).ref('choices')
          );
        } else if (style === 'minimal' || toggleName !== this.props.name) {
          // NOTE: tooltips are only rendered when explanation is needed
          el.append(
            this._renderToolTip($$)
          );
        }
      }
      return el
    }

    _renderToolTip ($$) {
      let labelProvider = this.context.labelProvider;
      return $$(Tooltip, {
        text: labelProvider.getLabel(this.props.name)
      })
    }

    get _isTopLevel () {
      return true
    }

    _deriveState (props) {
      super._deriveState(props);

      if (this.props.displayActiveCommand) {
        this._derivedState.activeCommandName = this._getActiveCommandName(props.items, props.commandStates);
      }
    }

    _getActiveCommandName (items, commandStates) {
      // FIXME: getting an active commandName does only make sense for a flat dropdown
      for (let item of items) {
        if (item.type === 'command') {
          const commandName = item.name;
          let commandState = commandStates[commandName];
          if (commandState && commandState.active) {
            return commandName
          }
        }
      }
    }

    _getToggleName () {
      if (this.props.displayActiveCommand) {
        return this._derivedState.activeCommandName || this.props.name
      } else {
        return this.props.name
      }
    }

    _onMousedown (event) {
      event.preventDefault();
    }

    _onClick (event) {
      event.preventDefault();
      event.stopPropagation();
      if (this._hasChoices()) {
        this.send('toggleOverlay', this.getId());
      }
    }

    _hasChoices () {
      return (!this.props.hideDisabled || this._derivedState.hasEnabledItem)
    }
  }

  // TODO: explain why this is necessary. Do we really need styles for this?
  // Or could we just use 'group' within Overlay?
  class ToolPrompt extends ToolGroup {
    _getClassNames () {
      return 'sc-tool-prompt'
    }
  }

  class ToolSpacer extends substance.Component {
    render ($$) {
      return $$('div').addClass('sc-tool-spacer')
    }
  }

  class ToolSwitcher extends ToolPanel {
    _getClassNames () {
      return 'sc-tool-switcher'
    }
  }

  const ESCAPE = substance.parseKeyEvent(substance.parseKeyCombo('Escape'));

  class Input extends substance.Component {
    render ($$) {
      let { path, type, placeholder } = this.props;
      let val = this._getDocumentValue();

      let el = $$('input').attr({
        value: val,
        type,
        placeholder
      }).addClass('sc-input')
        .val(val)
        .on('keydown', this._onKeydown);
      if (path) {
        el.on('change', this._onChange);
      }
      return el
    }

    submit () {
      let editorSession = this.context.editorSession;
      let path = this.props.path;
      let newVal = this.el.val();
      let oldVal = this._getDocumentValue();
      if (newVal !== oldVal) {
        editorSession.transaction(function (tx) {
          tx.set(path, newVal);
        });
        return true
      }
    }

    focus () {
      this.el.getNativeElement().focus();
    }

    _onChange () {
      if (this.submit() && this.props.retainFocus) {
        // ATTENTION: running the editor flow will rerender the model selection
        // which takes away the focus from this input
        this.focus();
      }
    }

    _getDocumentValue () {
      if (this.props.val) {
        return this.props.val
      } else {
        let editorSession = this.context.editorSession;
        let path = this.props.path;
        return editorSession.getDocument().get(path)
      }
    }

    _onKeydown (event) {
      let combo = substance.parseKeyEvent(event);
      switch (combo) {
        // ESCAPE reverts the current pending change
        case ESCAPE: {
          event.stopPropagation();
          event.preventDefault();
          this.el.val(this._getDocumentValue());
          break
        }
        default:
          // nothing
      }
    }
  }

  class ToolSeparator extends substance.Component {
    render ($$) {
      const label = this.props.label;
      let el = $$('div').addClass('sc-tool-separator');
      if (label) {
        el.append(
          $$('div').addClass('se-label').append(
            this.getLabel(label)
          )
        );
      }
      return el
    }
  }

  class TextArea extends Input {
    render ($$) {
      const { path, rows, cols, wrap, placeholder } = this.props;
      let value = this._getDocumentValue();
      let el = $$('textarea').attr({
        value,
        placeholder,
        rows,
        cols,
        wrap
      }).addClass('sc-text-area')
        .val(value)
        .on('keydown', this._onKeydown);
      if (path) {
        el.on('change', this._onChange);
      }
      return el
    }
  }

  var BasePackage = {
    name: 'TextureBase',
    configure: function (configurator) {
      configurator.import(substance.ButtonPackage);
      configurator.import(substance.ScrollPanePackage);
      configurator.import(substance.BodyScrollPanePackage);
      configurator.import(substance.SplitPanePackage);
      configurator.import(substance.TabbedPanePackage);
      configurator.import(substance.ScrollbarPackage);
      configurator.import(substance.ContextMenuPackage);
      configurator.import(substance.OverlayPackage);
      configurator.import(substance.DropzonesPackage);
      configurator.import(substance.ToolPanelPackage);

      configurator.addComponent('annotation', AnnotationComponent);
      // customized built-ins
      configurator.addComponent('container-editor', ContainerEditorNew);
      configurator.addComponent('isolated-node', IsolatedNodeComponentNew);
      configurator.addComponent('inline-node', IsolatedInlineNodeComponentNew);
      configurator.addComponent('text-property', TextPropertyComponentNew);
      configurator.addComponent('text-property-editor', TextPropertyEditorNew);

      // replacing Substance components with custom ones
      configurator.addComponent('scroll-pane', ScrollPane, true);
      configurator.addComponent('body-scroll-pane', BodyScrollPane, true);

      configurator.addComponent('button', Button, true);
      configurator.addComponent('context-menu', ContextMenu, true);
      configurator.addComponent('input', Input);
      configurator.addComponent('modal', ModalDialog);
      configurator.addComponent('overlay', Overlay, true);
      configurator.addComponent('text-area', TextArea);
      configurator.addComponent('tool', Tool, true);
      // TODO: remove toggle-tool
      configurator.addComponent('toggle-tool', ToggleTool, true);
      configurator.addComponent('toolbar', Toolbar, true);
      configurator.addComponent('tool-dropdown', ToolDropdown, true);
      configurator.addComponent('tool-group', ToolGroup, true);
      configurator.addComponent('tool-prompt', ToolPrompt, true);
      configurator.addComponent('tool-separator', ToolSeparator, true);
      configurator.addComponent('tool-spacer', ToolSpacer, true);
      configurator.addComponent('tool-switcher', ToolSwitcher, true);

      configurator.addLabel('text-types', {
        en: 'Text Type',
        de: 'Texttyp'
      });
      configurator.addLabel('container-selection', {
        en: 'Container',
        de: 'Container'
      });
      configurator.addLabel('@container', {
        en: 'Container',
        de: 'Container'
      });
    }
  }

  /*
    Attention: in contrast to Substance.SelectAllCommand, this implementation does not take
    the surface type into consideration.
    The problem is, that for that, appState.focusedSurface would need to be reduced
    in an earlier stage, which is impossible, as Surfaces are rendered during 'render'
    stage. So this is kind of an chicken-egg problem.
    In general, we should avoid making commandStates depend on rendered components.
  */
  class SelectAllCommand extends substance.Command {
    getCommandState (params) {
      let editorSession = params.editorSession;
      let isBlurred = editorSession.isBlurred();
      let sel = editorSession.getSelection();
      let disabled = (
        isBlurred ||
        !sel || sel.isNull()
      );
      return { disabled }
    }

    execute (params, context) {
      let editorSession = context.editorSession;
      let doc = editorSession.getDocument();
      let appState = context.appState;
      let focusedSurface = appState.focusedSurface;
      if (focusedSurface) {
        let sel = null;
        let surfaceId = focusedSurface.id;
        if (focusedSurface._isContainerEditor) {
          let containerPath = focusedSurface.getContainerPath();
          let nodeIds = doc.get(containerPath);
          if (nodeIds.length === 0) return false
          let firstNodeId = nodeIds[0];
          let lastNodeId = substance.last(nodeIds);
          sel = doc.createSelection({
            type: 'container',
            startPath: [firstNodeId],
            startOffset: 0,
            endPath: [lastNodeId],
            endOffset: 1,
            containerPath,
            surfaceId
          });
        } else if (focusedSurface._isTextPropertyEditor) {
          let path = focusedSurface.getPath();
          let text = doc.get(path);
          sel = editorSession.createSelection({
            type: 'property',
            path: path,
            startOffset: 0,
            endOffset: text.length,
            surfaceId
          });
        }
        if (sel) {
          editorSession.setSelection(sel);
        }
        return true
      }
      return false
    }
  }

  var EditorBasePackage = {
    name: 'EditorBase',
    configure: function (config) {
      config.addCommand('undo', substance.UndoCommand, { commandGroup: 'undo-redo' });
      config.addCommand('redo', substance.RedoCommand, { commandGroup: 'undo-redo' });
      config.addCommand('select-all', SelectAllCommand, { commandGroup: 'selection' });

      config.addIcon('insert', { 'fontawesome': 'fa-plus' });
      config.addIcon('undo', { 'fontawesome': 'fa-undo' });
      config.addIcon('redo', { 'fontawesome': 'fa-repeat' });
      config.addIcon('edit', { 'fontawesome': 'fa-cog' });
      config.addIcon('delete', { 'fontawesome': 'fa-times' });
      config.addIcon('expand', { 'fontawesome': 'fa-arrows-h' });
      config.addIcon('truncate', { 'fontawesome': 'fa-arrows-h' });

      config.addLabel('undo', {
        en: 'Undo',
        de: 'Rückgängig'
      });
      config.addLabel('redo', {
        en: 'Redo',
        de: 'Wiederherstellen'
      });
      config.addLabel('select-all', {
        en: 'Select All',
        de: 'Alles Auswählen'
      });
      config.addLabel('close', {
        en: 'Close',
        de: 'Schließen'
      });

      config.addKeyboardShortcut('CommandOrControl+Z', { command: 'undo' });
      config.addKeyboardShortcut('CommandOrControl+Shift+Z', { command: 'redo' });
      config.addKeyboardShortcut('CommandOrControl+A', { command: 'select-all' });
    }
  }

  class AddEntityCommand extends substance.Command {
    getCommandState () {
      return { disabled: false }
    }

    execute (params, context) {
      const workflow = this.config.workflow;
      if (workflow) {
        context.editor.send('startWorkflow', workflow);
      } else {
        const appState = context.appState;
        const viewName = appState.get('viewName');
        // ATTENTION: for now when an entity is added from within the manuscript view
        // we switch to the metadata view and then execute the command again
        // However, this is tricky, because this needs be done by a different CommandManager.
        // ATTENTION 2: some entities are allowed in both views (such as Footnotes)
        // For now we use `config.metadataOnly` for those entity types which are only
        // available in the metadata view
        if (viewName !== 'metadata' && this.config.metadataOnly) {
          context.editor.send('updateViewName', 'metadata');
          // HACK: using the ArticlePanel instance to get to the current editor
          // so that we can dispatch 'executeCommand'
          context.articlePanel.refs.content.send('executeCommand', this.name, params);
        } else {
          this._addItemToCollection(params, context);
          context.editor.send('toggleOverlay');
        }
      }
    }

    _addItemToCollection (params, context) {
      const api = context.api;
      const collectionPath = this.config.collection;
      let editorSession = context.editorSession;
      editorSession.transaction(tx => {
        let node = this._createNode(tx);
        substance.documentHelpers.append(tx, collectionPath, node.id);
        tx.selection = api._selectFirstRequiredPropertyOfMetadataCard(node);
      });
    }

    _createNode (tx) {
      return tx.create({ type: this.config.type })
    }
  }

  /* eslint-disable no-template-curly-in-string */
  var ArticleToolbarPackage = {
    name: 'article-toolbar',
    configure (config) {
      config.addToolPanel('toolbar', [
        {
          name: 'mode',
          type: 'switcher',
          style: 'descriptive',
          hideDisabled: true,
          displayActiveCommand: true,
          items: [
            { type: 'command', name: 'open-manuscript', label: 'open-manuscript', icon: 'manuscript' },
            { type: 'command', name: 'open-metadata', label: 'open-metadata', icon: 'metadata' }
          ]
        },
        {
          name: 'document-tools',
          type: 'group',
          style: 'minimal',
          items: [
            { type: 'command', name: 'undo' },
            { type: 'command', name: 'redo' },
            { type: 'command', name: 'save' }
          ]
        },
        {
          name: 'primary-annotations',
          type: 'group',
          style: 'minimal',
          items: [
            { type: 'command', name: 'toggle-bold', label: 'bold', icon: 'bold' },
            { type: 'command', name: 'toggle-italic', label: 'italic', icon: 'italic' },
            { type: 'command', name: 'create-external-link', label: 'link', icon: 'link' }
          ]
        },
        {
          name: 'insert',
          type: 'dropdown',
          style: 'descriptive',
          hideDisabled: true,
          alwaysVisible: true,
          items: [
            {
              name: 'content',
              type: 'group',
              items: [
                { type: 'command', name: 'insert-figure', label: 'figure' },
                { type: 'command', name: 'insert-table', label: 'table' },
                { type: 'command', name: 'insert-block-quote', label: 'block-quote' },
                { type: 'command', name: 'insert-block-formula', label: 'equation' },
                { type: 'command', name: 'insert-file', label: 'file' },
                { type: 'command', name: 'insert-footnote', label: 'footnote' },
                { type: 'command', name: 'insert-reference', label: 'reference' }
              ]
            },
            {
              name: 'inline-content',
              type: 'group',
              label: 'inline',
              items: [
                { type: 'command', name: 'insert-inline-formula', label: 'math' },
                { type: 'command', name: 'insert-inline-graphic', label: 'inline-graphic' },
                { type: 'command', name: 'create-external-link', label: 'link', icon: 'link' },
                { type: 'command', name: 'insert-xref-bibr', label: 'citation' },
                { type: 'command', name: 'insert-xref-figure', label: 'figure-reference' },
                { type: 'command', name: 'insert-xref-table', label: 'table-reference' },
                { type: 'command', name: 'insert-xref-footnote', label: 'footnote-reference' },
                { type: 'command', name: 'insert-xref-formula', label: 'equation-reference' },
                { type: 'command', name: 'insert-xref-file', label: 'file-reference' }
              ]
            },
            {
              name: 'metadata',
              type: 'group',
              label: 'metadata',
              items: [
                { type: 'command', name: 'insert-author', label: 'author' },
                { type: 'command', name: 'insert-editor', label: 'editor' },
                { type: 'command', name: 'insert-group', label: 'group' },
                { type: 'command', name: 'insert-organisation', label: 'affiliation' },
                { type: 'command', name: 'insert-funder', label: 'funder' },
                { type: 'command', name: 'insert-keyword', label: 'keyword' },
                { type: 'command', name: 'insert-subject', label: 'subject' }
              ]
            }
          ]
        },
        {
          name: 'format',
          type: 'dropdown',
          style: 'descriptive',
          items: [
            { type: 'command', name: 'toggle-bold', label: 'bold' },
            { type: 'command', name: 'toggle-italic', label: 'italic' },
            { type: 'command', name: 'toggle-subscript', label: 'subscript' },
            { type: 'command', name: 'toggle-superscript', label: 'superscript' },
            { type: 'command', name: 'toggle-monospace', label: 'monospace' },
            { type: 'command', name: 'toggle-small-caps', label: 'small-caps' },
            { type: 'command', name: 'toggle-underline', label: 'underline' },
            { type: 'command', name: 'toggle-overline', label: 'overline' },
            { type: 'command', name: 'toggle-strike-through', label: 'strike-through' }
          ]
        },
        {
          name: 'text-types',
          type: 'dropdown',
          style: 'descriptive',
          hideDisabled: true,
          displayActiveCommand: true,
          items: [
            { type: 'command-group', name: 'text-types' }
          ]
        },
        {
          name: 'divider',
          type: 'spacer'
        },
        {
          name: 'mobile-mode',
          type: 'dropdown',
          style: 'descriptive',
          hideDisabled: false,
          displayActiveCommand: true,
          items: [
            { type: 'command', name: 'open-manuscript', label: 'open-manuscript', icon: 'manuscript' },
            { type: 'command', name: 'open-metadata', label: 'open-metadata', icon: 'metadata' }
          ]
        },
        {
          name: 'context-tools',
          type: 'dropdown',
          style: 'descriptive',
          // hide disabled items but not the dropdown itself
          hideDisabled: true,
          alwaysVisible: true,
          items: [
            {
              type: 'group',
              name: 'table',
              style: 'descriptive',
              label: 'table-tools',
              items: [
                { type: 'command-group', name: 'table' },
                { type: 'command-group', name: 'table-insert' },
                { type: 'command-group', name: 'table-delete' }
              ]
            },
            {
              type: 'group',
              name: 'file',
              style: 'descriptive',
              label: 'file-tools',
              items: [
                { type: 'command-group', name: 'file' }
              ]
            },
            {
              type: 'group',
              name: 'figure',
              style: 'descriptive',
              label: 'figure-tools',
              items: [
                { type: 'command-group', name: 'figure-panel' }
              ]
            },
            {
              type: 'group',
              name: 'footnote',
              style: 'descriptive',
              label: 'footnote-tools',
              items: [
                { type: 'command-group', name: 'footnote' }
              ]
            },
            {
              type: 'group',
              name: 'list',
              style: 'descriptive',
              label: 'list-tools',
              items: [
                { type: 'command-group', name: 'list' }
              ]
            },
            {
              type: 'group',
              name: 'custom-metadata-fields',
              style: 'descriptive',
              label: 'metadata-field-tools',
              items: [
                { type: 'command-group', name: 'custom-metadata-fields' }
              ]
            },
            {
              type: 'group',
              name: 'author',
              style: 'descriptive',
              items: [
                { type: 'command-group', name: 'author' }
              ]
            },
            {
              type: 'group',
              name: 'reference',
              style: 'descriptive',
              items: [
                { type: 'command-group', name: 'reference' }
              ]
            },
            {
              type: 'group',
              name: 'collection',
              style: 'descriptive',
              items: [
                { type: 'command-group', name: 'collection' }
              ]
            }
          ]
        }
      ]);

      // Context menus
      config.addToolPanel('context-menu', [
        {
          name: 'context-menu',
          type: 'group',
          style: 'descriptive',
          hideDisabled: true,
          items: [
            { type: 'command-group', name: 'file' },
            { type: 'command-group', name: 'figure-panel' },
            { type: 'command-group', name: 'footnote' },
            { type: 'command-group', name: 'author' },
            { type: 'command-group', name: 'reference' },
            { type: 'command-group', name: 'collection' },
            { type: 'command-group', name: 'list' },
            { type: 'command-group', name: 'custom-metadata-fields' }
          ]
        }
      ]);
      config.addToolPanel('table-context-menu', [
        {
          name: 'table-context-menu',
          type: 'group',
          style: 'descriptive',
          label: 'table',
          items: [
            { type: 'command-group', name: 'table-insert' },
            { type: 'command-group', name: 'table-delete' }
          ]
        }
      ]);

      // Icons
      config.addIcon('bold', { 'fontawesome': 'fa-bold' });
      config.addIcon('italic', { 'fontawesome': 'fa-italic' });
      config.addIcon('link', { 'fontawesome': 'fa-link' });

      // Format tools labels
      config.addLabel('format', 'Format');
      config.addLabel('bold', 'Bold');
      config.addLabel('italic', 'Italic');
      config.addLabel('link', 'Link');
      config.addLabel('monospace', 'Monospace');
      config.addLabel('overline', 'Overline');
      config.addLabel('small-caps', 'Small Caps');
      config.addLabel('strike-through', 'Strike Through');
      config.addLabel('subscript', 'Subscript');
      config.addLabel('superscript', 'Superscript');
      config.addLabel('underline', 'Underline');
      // List tools labels
      config.addLabel('list-tools', 'List');
      config.addLabel('toggle-unordered-list', {
        en: 'Bulleted list',
        de: 'Liste'
      });
      config.addLabel('toggle-ordered-list', {
        en: 'Numbered list',
        de: 'Aufzählung'
      });
      config.addLabel('indent-list', {
        en: 'Increase indentation',
        de: 'Einrückung vergrößern'
      });
      config.addLabel('dedent-list', {
        en: 'Decrease indentation',
        de: 'Einrückung verringern'
      });
      // Insert tools labels
      config.addLabel('insert', 'Insert');
      config.addLabel('figure', 'Figure');
      config.addLabel('table', 'Table');
      config.addLabel('block-quote', 'Block Quote');
      config.addLabel('equation', 'Equation');
      config.addLabel('file', 'File');
      config.addLabel('footnote', 'Footnote');
      config.addLabel('inline', 'Inline');
      config.addLabel('math', 'Math');
      config.addLabel('inline-graphic', 'Inline Graphic');
      config.addLabel('citation', 'Citation');
      config.addLabel('figure-reference', 'Figure Reference');
      config.addLabel('table-reference', 'Table Reference');
      config.addLabel('footnote-reference', 'Footnote Reference');
      config.addLabel('equation-reference', 'Equation Reference');
      config.addLabel('file-reference', 'File Reference');
      config.addLabel('metadata', 'Metadata');
      config.addLabel('reference', 'Reference');
      config.addLabel('author', 'Author');
      config.addLabel('editor', 'Editor');
      config.addLabel('group', 'Group');
      config.addLabel('affiliation', 'Affiliation');
      config.addLabel('funder', 'Funder');
      config.addLabel('keyword', 'Keyword');
      config.addLabel('subject', 'Subject');
      // Table tools labels
      config.addLabel('table-tools', 'Table');
      config.addLabel('insert-rows-above', {
        en: 'Insert ${nrows} rows above'
      });
      config.addLabel('insert-rows-below', {
        en: 'Insert ${nrows} rows below'
      });
      config.addLabel('insert-columns-left', {
        en: 'Insert ${ncols} columns left'
      });
      config.addLabel('insert-columns-right', {
        en: 'Insert ${ncols} columns right'
      });
      config.addLabel('delete-rows', {
        en: 'Delete ${nrows} rows'
      });
      config.addLabel('delete-columns', {
        en: 'Delete ${ncols} columns'
      });
      config.addLabel('toggle-cell-heading', {
        en: 'Cell heading'
      });
      config.addLabel('toggle-cell-merge', {
        en: 'Merge cell'
      });
      // File tools
      config.addLabel('file-tools', 'File');
      config.addLabel('replace-file', 'Replace File');
      config.addLabel('download-file', 'Download File');
      // Figure tools
      config.addLabel('figure-tools', 'Figure');
      config.addLabel('add-figure-panel', 'Add Panel');
      config.addLabel('replace-figure-panel-image', 'Replace Image');
      config.addLabel('remove-figure-panel', 'Remove Panel');
      config.addLabel('move-up-figure-panel', 'Move Panel Up');
      config.addLabel('move-down-figure-panel', 'Move Panel Down');
      config.addLabel('open-figure-panel-image', 'Open Image');
      // Footnote tools
      config.addLabel('footnote-tools', 'Footnote');
      config.addLabel('remove-footnote', 'Remove Footnote');
      // Collection tools
      config.addLabel('collection-tools', 'Collection');
      config.addLabel('move-up-col-item', 'Move Item Up');
      config.addLabel('move-down-col-item', 'Move Item Down');
      config.addLabel('remove-col-item', 'Remove Item');
      // Custom field tools
      config.addLabel('metadata-field-tools', 'Metadata');
      config.addLabel('add-metadata-field', 'Add Metadata Field');
      config.addLabel('move-down-metadata-field', 'Move Down Metadata Field');
      config.addLabel('move-up-metadata-field', 'Move Up Metadata Field');
      config.addLabel('remove-metadata-field', 'Remove Metadata Field');
      // Author tools
      config.addLabel('edit-author', 'Edit Author');
      // Reference tools
      config.addLabel('edit-reference', 'Edit Reference');
      config.addLabel('remove-reference', 'Remove Reference');
      // Context tools
      config.addLabel('context-tools', 'Edit');
      // Mode
      config.addLabel('mode', 'Mode');
      config.addLabel('mobile-mode', 'Mode');
      config.addLabel('open-manuscript', 'Manuscript');
      config.addLabel('open-metadata', 'Details');
    }
  }

  /* eslint-disable no-template-curly-in-string */
  var EntityLabelsPackage = {
    name: 'entity-labels',
    configure (config) {
      // EXPERIMENTAL: I want to move to more natural label specifications
      config.addLabel('enter-something', 'Enter ${something}');

      // TODO: at some point I want to refactor the configuration so that we have only one place for labels

      // general
      config.addLabel('edit-references', 'Edit References');
      config.addLabel('edit-affiliations', 'Edit Affiliations');
      config.addLabel('show-more-fields', 'More fields');
      config.addLabel('show-less-fields', 'Less fields');
      config.addLabel('multi-select-default-value', 'Click to select a value');
      config.addLabel('select-default-value', 'No value selected');

      // item types
      config.addLabel('journal-article-ref', 'Journal Article');
      config.addLabel('edit-journal-article-ref', 'Edit Journal Article');
      config.addLabel('add-journal-article-ref', 'Add Journal Article');
      config.addLabel('create-journal-article-ref', 'Create Journal Article');

      config.addLabel('book-ref', 'Book');
      config.addLabel('edit-book-ref', 'Edit Book');
      config.addLabel('add-book-ref', 'Add Book');
      config.addLabel('create-book-ref', 'Create Book');

      config.addLabel('chapter-ref', 'Chapter');
      config.addLabel('edit-chapter-ref', 'Edit Chapter');
      config.addLabel('add-chapter-ref', 'Add Chapter');
      config.addLabel('create-chapter-ref', 'Create Chapter');

      config.addLabel('conference-paper-ref', 'Conference Paper');
      config.addLabel('create-conference-paper-ref', 'Create Conference Paper');
      config.addLabel('edit-conference-paper-ref', 'Edit Conference Paper');

      config.addLabel('webpage-ref', 'Webpage');
      config.addLabel('create-webpage-ref', 'Create Webpage');
      config.addLabel('edit-webpage-ref', 'Edit Webpage');

      config.addLabel('thesis-ref', 'Thesis');
      config.addLabel('create-thesis-ref', 'Create Thesis');
      config.addLabel('edit-thesis-ref', 'Edit Thesis');

      config.addLabel('software-ref', 'Software');
      config.addLabel('create-software-ref', 'Create Software');
      config.addLabel('edit-software-ref', 'Edit Software');

      config.addLabel('report-ref', 'Report');
      config.addLabel('create-report-ref', 'Create Report');
      config.addLabel('edit-report-ref', 'Edit Report');

      config.addLabel('data-publication-ref', 'Data Publication');
      config.addLabel('create-data-publication-ref', 'Create Data Publication');
      config.addLabel('edit-data-publication-ref', 'Edit Data Publication');

      config.addLabel('magazine-article-ref', 'Magazine Article');
      config.addLabel('create-magazine-article-ref', 'Create Magazine Article');
      config.addLabel('edit-magazine-article-ref', 'Edit Magazine Article');

      config.addLabel('newspaper-article-ref', 'Newspaper Article');
      config.addLabel('create-newspaper-article-ref', 'Create Newspaper Article');
      config.addLabel('edit-newspaper-article-ref', 'Edit Newspaper Article');

      config.addLabel('patent-ref', 'Patent');
      config.addLabel('create-patent-ref', 'Create Patent');

      config.addLabel('article-ref', 'Article');
      config.addLabel('create-article-ref', 'Create Article');

      // fields labels
      config.addLabel('authors', 'Authors');
      config.addLabel('edit-authors', 'Edit Authors');

      config.addLabel('editors', 'Editors');
      config.addLabel('edit-editors', 'Edit Editors');

      config.addLabel('translators', 'Translators');
      config.addLabel('edit-translators', 'Edit Translators');

      config.addLabel('abstract', 'Abstract');
      config.addLabel('accessedDate', 'Accessed Date');
      config.addLabel('accessionId', 'Accession ID');
      config.addLabel('archiveId', 'Archive ID');
      config.addLabel('arkId', 'ARK ID');
      config.addLabel('assignee', 'Assignee');
      config.addLabel('confLoc', 'Conference Location');
      config.addLabel('confName', 'Conference Name');
      config.addLabel('containerTitle', 'Source');
      config.addLabel('day', 'Day');
      config.addLabel('doi', 'DOI');
      config.addLabel('edition', 'Edition');
      config.addLabel('elocationId', 'E-Location ID');
      config.addLabel('fpage', 'First Page');
      config.addLabel('given-names', 'Given Names');
      config.addLabel('inventors', 'Inventors');
      config.addLabel('isbn', 'ISBN');
      config.addLabel('issue', 'Issue');
      config.addLabel('issue-title', 'Issue Title');
      config.addLabel('lpage', 'Last Page');
      config.addLabel('month', 'Month');
      config.addLabel('name', 'Name');
      config.addLabel('pageCount', 'Page Count');
      config.addLabel('pageRange', 'Page Range');
      config.addLabel('patentCountry', 'Patent Country');
      config.addLabel('patentNumber', 'Patent Number');
      config.addLabel('partTitle', 'Part Title');
      config.addLabel('pmid', 'PubMed ID');
      config.addLabel('publisherLoc', 'Publisher Location');
      config.addLabel('publisherName', 'Publisher Name');
      config.addLabel('source', 'Source');
      config.addLabel('sponsors', 'Sponsors');
      config.addLabel('series', 'Series');
      config.addLabel('title', 'Title');
      config.addLabel('version', 'Version');
      config.addLabel('volume', 'Volume');
      config.addLabel('year', 'Year');

      config.addLabel('acceptedDate', 'Accepted Date');
      config.addLabel('publishedDate', 'Published Date');
      config.addLabel('receivedDate', 'Received Date');
      config.addLabel('revReceivedDate', 'Revision Received Date');
      config.addLabel('revRequestedDate', 'Revision Requested Date');

      // person labels
      config.addLabel('person', 'Person');
      config.addLabel('add-person', 'Add Person');
      config.addLabel('edit-person', 'Edit Person');
      config.addLabel('create-person', 'Create Person');
      config.addLabel('orcid', 'ORCID');
      config.addLabel('givenNames', 'Given Names');
      config.addLabel('surname', 'Surname');
      config.addLabel('alias', 'Alias');
      config.addLabel('prefix', 'Prefix');
      config.addLabel('suffix', 'Suffix');
      config.addLabel('bio', 'Biography');
      config.addLabel('affiliations', 'Affiliations');
      config.addLabel('funders', 'Funders');
      config.addLabel('group', 'Group');
      config.addLabel('equalContrib', 'Equal Contribution');
      config.addLabel('corresp', 'Corresponding Author');
      config.addLabel('deceased', 'Deceased');

      // organisation labels
      config.addLabel('organisation', 'Affiliation');
      config.addLabel('add-organisation', 'Add Organisation');
      config.addLabel('edit-organisation', 'Edit Organisation');
      config.addLabel('create-organisation', 'Create Organisation');
      config.addLabel('division1', 'Division 1 (Department)');
      config.addLabel('division2', 'Division 2');
      config.addLabel('division3', 'Division 3');
      config.addLabel('street', 'Address Line 1 (Street)');
      config.addLabel('addressComplements', 'Address Line 2 (Complements)');
      config.addLabel('city', 'City');
      config.addLabel('state', 'State');
      config.addLabel('postalCode', 'Postal Code');
      config.addLabel('country', 'Country');
      config.addLabel('phone', 'Phone');
      config.addLabel('fax', 'Fax');
      config.addLabel('email', 'Email');
      config.addLabel('uri', 'Website');
      config.addLabel('members', 'Members');
      config.addLabel('edit-members', 'Edit Members');

      // award labels
      config.addLabel('funder', 'Funder');
      config.addLabel('institution', 'Institution');
      config.addLabel('fundRefId', 'Institution Identifier');
      config.addLabel('awardId', 'Award Identifier');

      // keyword labels
      config.addLabel('keyword', 'Keyword');
      config.addLabel('category', 'Category');
      config.addLabel('language', 'Language');

      // subject labels
      config.addLabel('subject', 'Subject');

      // figure labels
      config.addLabel('figure', 'Figure');
      config.addLabel('content', 'Content');
      config.addLabel('legend', 'Legend');
      config.addLabel('copyrightStatement', 'Copyright Statement');
      config.addLabel('copyrightYear', 'Copyright Year');
      config.addLabel('copyrightHolder', 'Copyright Holder');
      config.addLabel('license', 'License');
      config.addLabel('licenseText', 'License Text (optional)');

      // table figure labels
      config.addLabel('table-figure', 'Table');

      // translatable labels
      config.addLabel('translatable', 'Translation');

      // footnote labels
      config.addLabel('fn', 'Footnote');
    }
  }

  class AbstractComponent extends NodeComponent {
    render ($$) {
      let el = $$('div').addClass('sc-abstract');
      el.append(
        this._renderValue($$, 'content', {
          placeholder: this.getLabel('abstract-placeholder')
        })
      );
      return el
    }
  }

  class AuthorsListComponent extends substance.CustomSurface {
    getInitialState () {
      let items = this._getAuthors();
      return {
        hidden: items.length === 0,
        edit: false
      }
    }

    didMount () {
      super.didMount();

      const appState = this.context.appState;
      appState.addObserver(['selection'], this.rerender, this, { stage: 'render' });
    }

    dispose () {
      super.dispose();
      this.context.appState.removeObserver(this);
    }

    render ($$) {
      let el = $$('div').addClass('sc-authors-list');
      el.append(
        this._renderAuthors($$)
      );
      return el
    }

    _renderAuthors ($$) {
      const sel = this.context.appState.selection;

      const authors = this._getAuthors();
      let els = [];
      authors.forEach((author, index) => {
        const short = author.type === 'organisation';
        const authorEl = $$('span').addClass('se-contrib').html(
          this.context.api._renderEntity(author, { short })
        ).on('click', this._selectAuthor.bind(this, author.id));
        if (sel && sel.customType === 'author' && sel.data.authorId === author.id) {
          authorEl.addClass('sm-selected');
        }
        els.push(authorEl);
        if (index < authors.length - 1) {
          els.push(', ');
        }
      });
      return els
    }

    _getCustomResourceId () {
      return 'authors-list'
    }

    _getAuthors () {
      return this.props.model.getItems()
    }

    _selectAuthor (authorId) {
      const newSel = {
        type: 'custom',
        customType: 'author',
        nodeId: authorId,
        data: {
          authorId
        }
      };
      this.context.editorSession.setSelection(newSel);
    }
  }

  class BreakComponent extends substance.Component {
    render ($$) {
      return $$('br')
    }
  }

  class PreviewComponent extends substance.Component {
    getChildContext () {
      return {
        editable: false
      }
    }

    render ($$) {
      let id = this.props.id;
      let el = $$('div')
        .addClass('sc-preview')
        .attr({ 'data-id': id });

      if (this.props.thumbnail) {
        el.append(
          $$('div').addClass('se-thumbnail').append(
            this.props.thumbnail
          )
        );
      }

      el.append(
        $$('div').addClass('se-label').append(
          this.props.label
        ),
        // NOTE: description is passed in as HTML string
        $$('div').addClass('se-description').append(
          this.props.description
        )
      );
      return el
    }
  }

  class BlockFormulaComponent extends NodeComponent {
    render ($$) {
      const mode = this.props.mode;
      const node = this.props.node;
      const label = getLabel(node) || '?';
      const source = node.content;

      if (mode === PREVIEW_MODE) {
        return $$(PreviewComponent, {
          id: node.id,
          label,
          description: $$('div').html(katex.renderToString(source))
        })
      }

      let el = $$('div')
        .addClass('sc-block-formula')
        .attr('data-id', node.id);

      if (!source) {
        el.append('?');
      } else {
        try {
          el.append(
            $$('span').addClass('se-formula').html(katex.renderToString(source))
          );
          el.append($$('div').addClass('se-blocker'));
        } catch (error) {
          el.addClass('sm-error')
            .text(error.message);
        }
      }

      el.append(
        $$('div').addClass('se-label').append(label)
      );

      return el
    }
  }

  class BlockQuoteComponent extends NodeComponent {
    render ($$) {
      let node = this.props.node;
      let el = $$('div')
        .addClass('sc-block-quote')
        .attr('data-id', node.id);

      el.append(
        this._renderValue($$, 'content', { placeholder: this.getLabel('content-placeholder') }),
        this._renderValue($$, 'attrib', { placeholder: this.getLabel('attribution-placeholder') })
      );
      return el
    }
  }

  class CustomMetadataFieldComponent extends NodeComponent {
    render ($$) {
      let el = $$('div').addClass('sc-custom-metadata-field');
      el.append(
        this._renderValue($$, 'name', { placeholder: this.getLabel('enter-custom-field-name') }).addClass('se-field-name'),
        this._renderValue($$, 'value', { placeholder: this.getLabel('enter-custom-field-value') })
      );
      return el
    }
  }

  class ExtLinkComponent extends NodeComponentMixin(substance.AnnotationComponent) {
    render ($$) {
      let node = this.props.node;
      let el = super.render($$);
      el.attr('href', node.href);
      return el
    }

    getTagName () {
      return 'a'
    }
  }

  class FigureComponent extends NodeComponent {
    /*
      Note: in the Manuscript View only one figure panel is shown at time.
    */
    render ($$) {
      let mode = this._getMode();
      let node = this.props.node;
      let panels = node.panels;

      let el = $$('div').addClass('sc-figure').addClass(`sm-${mode}`).attr('data-id', node.id);
      if (panels.length > 0) {
        let content = this._renderCarousel($$, panels);
        el.append(content);
      }
      return el
    }

    _renderCarousel ($$, panels) {
      if (panels.length === 1) {
        return this._renderCurrentPanel($$)
      } else {
        return $$('div').addClass('se-carousel').append(
          this._renderNavigation($$),
          $$('div').addClass('se-current-panel').append(
            this._renderCurrentPanel($$)
          )
        )
      }
    }

    _renderCurrentPanel ($$) {
      let panel = this._getCurrentPanel();
      let PanelComponent = this.getComponent(panel.type);
      return $$(PanelComponent, {
        node: panel,
        mode: this.props.mode
      }).ref(panel.id)
    }

    _renderNavigation ($$) {
      const node = this.props.node;
      const panels = node.getPanels();
      const numberOfPanels = panels.length;
      const currentIndex = this._getCurrentPanelIndex() + 1;
      const currentPosition = currentIndex + ' / ' + numberOfPanels;
      const leftControl = $$('div').addClass('se-control sm-previous').append(
        this._renderIcon($$, 'left-control')
      );
      if (currentIndex > 1) {
        leftControl.on('click', this._onSwitchPanel.bind(this, 'left'));
      } else {
        leftControl.addClass('sm-disabled');
      }
      const rightControl = $$('div').addClass('se-control sm-next').append(this._renderIcon($$, 'right-control'));
      if (currentIndex < numberOfPanels) {
        rightControl.on('click', this._onSwitchPanel.bind(this, 'right'));
      } else {
        rightControl.addClass('sm-disabled');
      }
      return $$('div').addClass('se-navigation').append(
        $$('div').addClass('se-current-position').append(currentPosition),
        $$('div').addClass('se-controls').append(
          leftControl,
          rightControl
        )
      )
    }

    _getMode () {
      return this.props.mode || 'manuscript'
    }

    _getCurrentPanel () {
      let node = this.props.node;
      let doc = node.getDocument();
      let currentPanelIndex = this._getCurrentPanelIndex();
      let ids = node.panels;
      return doc.get(ids[currentPanelIndex])
    }

    _getCurrentPanelIndex () {
      let node = this.props.node;
      let state = node.state;
      let panels = node.panels;
      let currentPanelIndex = 0;
      if (state) {
        currentPanelIndex = state.currentPanelIndex;
      }
      // FIXME: state is corrupt
      if (currentPanelIndex < 0 || currentPanelIndex >= panels.length) {
        console.error('figurePanel.state.currentPanelIndex is corrupt');
        state.currentPanelIndex = currentPanelIndex = 0;
      }
      return currentPanelIndex
    }

    _onSwitchPanel (direction) {
      let currentIndex = this._getCurrentPanelIndex();
      this.context.api._switchFigurePanel(this.props.node, direction === 'left' ? --currentIndex : ++currentIndex);
    }

    _renderIcon ($$, iconName) {
      return $$('div').addClass('se-icon').append(
        this.context.iconProvider.renderIcon($$, iconName)
      )
    }
  }

  /**
   * A component that renders a node in a generic way iterating all properties.
   */
  class DefaultNodeComponent extends substance.Component {
    didMount () {
      // EXPERIMENTAL: ExperimentalArticleValidator updates `node.id, @issues`
      const node = this._getNode();
      this.context.appState.addObserver(['document'], this._rerenderWhenIssueHaveChanged, this, {
        stage: 'render',
        document: {
          path: [node.id, '@issues']
        }
      });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    getInitialState () {
      return {
        fullMode: false
      }
    }

    render ($$) {
      const fullMode = this.state.fullMode;
      const node = this._getNode();
      // TODO: issues should be accessed via model, not directly
      const nodeIssues = node['@issues'];
      let hasIssues = (nodeIssues && nodeIssues.size > 0);
      const el = $$('div').addClass(this._getClassNames()).attr('data-id', node.id);
      // EXPERIMENTAL: highlighting fields with issues
      if (hasIssues) {
        el.addClass('sm-warning');
      }
      el.append(this._renderHeader($$));

      const properties = this._getProperties();
      const propNames = Array.from(properties.keys());
      // all required and non-empty properties are always displayed
      let mandatoryPropNames = this._getRequiredOrNonEmptyPropertyNames(properties);
      let visiblePropNames = fullMode ? propNames : mandatoryPropNames;
      // show only the first k items
      if (visiblePropNames.length === 0) {
        visiblePropNames = propNames.slice(0, CARD_MINIMUM_FIELDS);
      }
      let hasHiddenProps = mandatoryPropNames.length < propNames.length;

      for (let name of visiblePropNames) {
        let value = properties.get(name);
        el.append(
          this._renderProperty($$, name, value, nodeIssues)
        );
      }

      const controlEl = $$('div').addClass('se-control')
        .on('click', this._toggleMode);

      if (hasHiddenProps) {
        if (fullMode) {
          controlEl.append(
            $$(substance.FontAwesomeIcon, { icon: 'fa-chevron-up' }).addClass('se-icon'),
            this.getLabel('show-less-fields')
          );
        } else {
          controlEl.append(
            $$(substance.FontAwesomeIcon, { icon: 'fa-chevron-down' }).addClass('se-icon'),
            this.getLabel('show-more-fields')
          );
        }
      }

      const footer = $$('div').addClass('se-footer').append(
        controlEl
      );

      el.append(footer);

      return el
    }

    _renderProperty ($$, name, value, nodeIssues) {
      const PropertyEditor = this._getPropertyEditorClass(name, value);
      const editorProps = this._getPropertyEditorProps(name, value);
      // skip this property if the editor implementation produces nil
      if (PropertyEditor) {
        const issues = nodeIssues ? nodeIssues.get(name) : [];
        return $$(FormRowComponent, {
          label: editorProps.label,
          issues
        }).addClass(`sm-${name}`).append(
          $$(PropertyEditor, editorProps).ref(name)
        )
      }
    }

    _getNode () {
      return this.props.node
    }

    _getProperties () {
      if (!this._properties) {
        this._properties = this._createPropertyModels();
      }
      return this._properties
    }

    _createPropertyModels () {
      return createNodePropertyModels(this.context.api, this._getNode())
    }

    _getClassNames () {
      return `sc-default-model sm-${this._getNode().type}`
    }

    _renderHeader ($$) {
      // TODO: rethink this. IMO it is not possible to generalize this implementation.
      // Maybe it is better to just use the regular component and pass a prop to allow the component to render in a 'short' style
      const ModelPreviewComponent = this.getComponent('model-preview', true);
      const node = this._getNode();
      let header = $$('div').addClass('se-header');
      if (ModelPreviewComponent) {
        header.append(
          $$(ModelPreviewComponent, { node })
        );
      }
      return header
    }

    /*
      Can be overriden to specify for which properties, labels should be hidden.
    */
    _showLabelForProperty (prop) {
      return true
    }

    // TODO: get rid of this
    get isRemovable () {
      return true
    }

    _getPropertyEditorClass (name, value) {
      return this.getComponent(value.type)
    }

    _getPropertyEditorProps (name, value) {
      let props = {
        // TODO: rename to value
        model: value,
        placeholder: this._getPlaceHolder(name)
      };
      if (this._showLabelForProperty(name)) {
        props.label = this.getLabel(name);
      }
      // TODO: is this really what we want? i.e. every CHILDREN value
      // is rendered as a container?
      if (value.type === 'collection') {
        props.container = true;
      }
      return props
    }

    _getPlaceHolder (name) {
      // ATTENTION: usually we avoid using automatically derived labels
      // but this class is all about a automated rendereding
      let placeHolder;
      // first try to get the canonical label
      const canonicalLabel = `${name}-placeholder`;
      placeHolder = this.getLabel(canonicalLabel);
      // next try to get a label using a template 'Enter ${something}'
      if (placeHolder === canonicalLabel) {
        let nameLabel = this.getLabel(name);
        if (nameLabel) {
          placeHolder = this.getLabel('enter-something', { something: nameLabel });
        } else {
          console.warn(`Please define a label for key "${name}"`);
        }
      }
      return placeHolder
    }

    _getRequiredOrNonEmptyPropertyNames (properties) {
      const api = this.context.api;
      let result = new Set();
      for (let [name, value] of properties) {
        if (!value.isEmpty() || api._isFieldRequired(value._getPropertySelector())) {
          result.add(name);
        }
      }
      return Array.from(result)
    }

    _toggleMode () {
      const fullMode = this.state.fullMode;
      this.extendState({ fullMode: !fullMode });
    }

    _rerenderWhenIssueHaveChanged () {
      // console.log('Rerendering NodeModelCompent after issues have changed', this._getNode().id)
      this.rerender();
    }
  }

  class LicenseEditor extends ValueComponent {
    render ($$) {
      const model = this.props.model;
      const value = model.getValue();
      let el = $$('div').addClass('sc-license-editor');

      const licenseSelector = $$('select').ref('input').addClass('se-select')
        .on('click', this._suppressClickPropagation)
        .on('change', this._setLicense);

      licenseSelector.append(
        $$('option').append(this.getLabel('select-license'))
      );

      LICENSES.forEach(l => {
        const option = $$('option').attr({ value: l.id }).append(l.name);
        if (l.id === value) option.attr({ selected: 'selected' });
        licenseSelector.append(option);
      });

      el.append(licenseSelector);

      return el
    }

    _setLicense () {
      const model = this.props.model;
      const input = this.refs.input;
      const value = input.getValue();
      model.setValue(value);
    }

    _suppressClickPropagation (e) {
      e.stopPropagation();
    }
  }

  class FigureMetadataComponent extends ValueComponent {
    render ($$) {
      let items = this.props.model.getItems();
      let el = $$('div').addClass('sc-figure-metadata');
      if (items.length > 0) {
        el.append(
          items.map(field => this._renderMetadataField($$, field))
        );
      } else {
        el.addClass('sm-empty').append(this.getLabel('empty-figure-metadata'));
      }
      return el
    }

    _renderMetadataField ($$, metadataField) {
      let MetdataFieldComponent = this.getComponent(metadataField.type);
      return $$(MetdataFieldComponent, { node: metadataField }).ref(metadataField.id)
    }
  }

  class FigurePanelComponentWithMetadata extends DefaultNodeComponent {
    _getClassNames () {
      return `sc-figure-metadata sc-default-node`
    }

    _renderHeader ($$) {
      const node = this.props.node;
      let header = $$('div').addClass('se-header');
      header.append(
        $$('div').addClass('se-label').text(getLabel(node))
      );
      return header
    }

    // overriding this to get spawn a special editor for the content
    _getPropertyEditorClass (name, value) {
      // skip 'label' here, as it is shown 'read-only' in the header instead
      if (name === 'label') {
        return null
      // special editor to pick license type
      } else if (name === 'license') {
        return LicenseEditor
      } else if (name === 'metadata') {
        return FigureMetadataComponent
      } else {
        return super._getPropertyEditorClass(name, value)
      }
    }

    _createPropertyModels () {
      const api = this.context.api;
      const node = this.props.node;
      const doc = node.getDocument();
      // ATTENTION: we want to show permission properties like they were fields of the panel itself
      // for that reason we are creating a property map where the permission fields are merged in
      return createNodePropertyModels(api, this.props.node, {
        // EXPERIMENTAL: trying to allow
        'permission': () => {
          let permission = doc.get(node.permission);
          return createNodePropertyModels(api, permission)
        }
      })
    }

    _showLabelForProperty (prop) {
      // Don't render a label for content property to use up the full width
      if (prop === 'content') {
        return false
      }
      return true
    }
  }

  // TODO: we need to rethink how we model labels
  // ATM, we have it in the schema, but we are using node state
  class LabelComponent extends substance.Component {
    didMount () {
      this.context.appState.addObserver(['document'], this.rerender, this, { stage: 'render', document: { path: [this.props.node.id] } });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    render ($$) {
      const label = getLabel(this.props.node);
      return $$('div').addClass('sc-label').text(label)
    }
  }

  class FigurePanelComponent extends NodeComponent {
    render ($$) {
      const mode = this._getMode();
      // different rendering when rendered as preview or in metadata view
      if (mode === PREVIEW_MODE) {
        return this._renderPreviewVersion($$)
      } else if (mode === METADATA_MODE) {
        return this._renderMetadataVersion($$)
      } else {
        return this._renderManuscriptVersion($$)
      }
    }

    _getClassNames () {
      return `sc-figure-panel`
    }

    _renderManuscriptVersion ($$) {
      const mode = this._getMode();
      const node = this.props.node;
      const SectionLabel = this.getComponent('section-label');

      let el = $$('div')
        .addClass(this._getClassNames())
        .attr('data-id', node.id)
        .addClass(`sm-${mode}`);

      el.append(
        $$(SectionLabel, { label: 'label-label' }),
        $$(LabelComponent, { node }),
        // no label for the graphic
        this._renderContent($$),
        $$(SectionLabel, { label: 'title-label' }),
        this._renderValue($$, 'title', { placeholder: this.getLabel('title-placeholder') }).addClass('se-title'),
        $$(SectionLabel, { label: 'legend-label' }),
        this._renderValue($$, 'legend', { placeholder: this.getLabel('legend-placeholder') }).addClass('se-legend')
      );

      // TODO: this is problematic as this node does not necessarily rerender if node.metadata has changed
      // the right way is to use a ModelComponent or use an incremental updater
      // rerender the whole component on metadata changes is not good, as it leads to double rerender, because FigureMetadataComponent reacts too
      if (node.metadata.length > 0) {
        el.append(
          $$(SectionLabel, { label: 'metadata-label' }),
          $$(FigureMetadataComponent, { model: createValueModel(this.context.api, [node.id, 'metadata']) })
        );
      }

      return el
    }

    _renderContent ($$) {
      return this._renderValue($$, 'content').addClass('se-content')
    }

    _renderPreviewVersion ($$) {
      const node = this.props.node;
      // TODO: We could return the PreviewComponent directly.
      // However this yields an error we need to investigate.
      let thumbnail;
      let content = node.getContent();
      if (content.type === 'graphic') {
        let ContentComponent = this.getComponent(content.type);
        thumbnail = $$(ContentComponent, {
          node: content
        });
      }
      // TODO: PreviewComponent should work with a model
      // FIXME: there is problem with redirected components
      // and Component as props
      return $$('div').append($$(PreviewComponent, {
        id: node.id,
        thumbnail,
        label: getLabel(node)
      })).addClass('sc-figure-panel').attr('data-id', node.id)
    }

    _renderMetadataVersion ($$) {
      return $$(FigurePanelComponentWithMetadata, { node: this.props.node })
    }

    _getMode () {
      return this.props.mode || 'manuscript'
    }
  }

  class FootnoteComponent extends NodeComponent {
    render ($$) {
      const mode = this.props.mode;
      if (mode === PREVIEW_MODE) {
        return this._renderPreviewVersion($$)
      }

      const footnote = this.props.node;
      let label = getLabel(footnote) || '?';

      let el = $$('div').addClass('sc-footnote').attr('data-id', footnote.id);
      el.append(
        $$('div').addClass('se-container').append(
          $$('div').addClass('se-label').append(label),
          this._renderValue($$, 'content', { placeholder: this.getLabel('footnote-placeholder') })
        )
      );
      return el
    }

    _renderPreviewVersion ($$) {
      let footnote = this.props.node;
      let el = $$('div').addClass('sc-footnote').attr('data-id', footnote.id);

      let label = getLabel(footnote) || '?';
      el.append(
        $$(PreviewComponent, {
          id: footnote.id,
          label: label,
          description: this._renderValue($$, 'content', {
            // TODO: we should need to pass down 'disabled' manually
            // editable=false should be disabled per-se
            disabled: true,
            editable: false
          })
        })
      );
      return el
    }
  }

  class HeadingComponent extends TextNodeComponent {
    getClassNames () {
      return 'sc-heading sc-text-node'
    }

    getTagName () {
      return 'h' + this.props.node.level
    }
  }

  class InlineFormulaComponent extends NodeComponent {
    // ATTENTION: this is very similar to BlockFormulaComponent
    // but unfortunately also substantially different
    // e.g. has no blocker, elements are spans, error message as tooltip
    render ($$) {
      const node = this.props.node;
      let el = $$('span')
        .addClass('sc-inline-formula')
        .attr('data-id', node.id);
      let source = node.content;
      if (!source) {
        el.append('?');
      } else {
        try {
          el.append(
            $$('span').addClass('se-formula').html(katex.renderToString(source))
          );
        } catch (error) {
          el.addClass('sm-error')
            .append('\u26A0')
            .append($$('span').addClass('se-message').text(error.message));
        }
      }
      return el
    }
  }

  class GraphicComponent extends NodeComponent {
    render ($$) {
      const node = this.props.node;
      const urlResolver = this.context.urlResolver;
      let url = node.href;
      if (urlResolver) {
        url = urlResolver.resolveUrl(url);
      }

      let el = $$(this.tagName).addClass(this._getClassNames())
        .attr('data-id', node.id);
      if (this.state.errored) {
        let errorEl = $$(this.tagName).addClass('se-error').append(
          this.context.iconProvider.renderIcon($$, 'graphic-load-error').addClass('se-icon')
        );
        this._renderError($$, errorEl);
        el.append(errorEl);
      } else {
        el.append(
          $$('img').attr({ src: url })
            .on('error', this._onLoadError)
        );
      }
      return el
    }

    _renderError ($$, errorEl) {
      errorEl.append(
        this.getLabel('graphic-load-error')
      );
    }

    _getClassNames () {
      return 'sc-graphic'
    }

    get tagName () {
      return 'div'
    }

    _onLoadError () {
      this.extendState({ errored: true });
    }
  }

  class InlineGraphicComponent extends GraphicComponent {
    get tagName () { return 'span' }

    _getClassNames () {
      return 'sc-inline-graphic'
    }

    _renderError ($$, errorEl) {
      errorEl.attr('title', this.getLabel('graphic-load-error'));
    }
  }

  class ListComponent extends NodeComponent {
    render ($$) {
      const ListItemComponent = this.getComponent('list-item');
      let node = this.props.node;
      // TODO: is it ok to rely on Node API here?
      let el = substance.renderListNode(node, item => {
        // item is either a list item node, or a tagName
        if (substance.isString(item)) {
          return $$(item)
        } else if (item.type === 'list-item') {
          return $$(ListItemComponent, {
            node: item
          }).ref(item.id)
        }
      });
      el.addClass('sc-list').attr('data-id', node.id);
      return el
    }

    // we need this ATM to prevent this being wrapped into an isolated node (see ContainerEditor._renderNode())
    get _isCustomNodeComponent () { return true }
  }

  class ListItemComponent extends NodeComponent {
    render ($$) {
      const node = this.props.node;
      const doc = node.getDocument();
      const path = node.getPath();
      const TextPropertyComponent = this.getComponent('text-property');

      let el = $$('li').addClass('sc-list-item');
      el.append(
        $$(TextPropertyComponent, {
          doc,
          name: substance.getKeyForPath(path),
          path
        })
      );
      // for nested lists
      if (this.props.children) {
        el.append(this.props.children);
      }
      return el
    }
  }

  class ManuscriptSection extends substance.Component {
    didMount () {
      addModelObserver(this.props.model, this._onModelUpdate, this);
    }

    dispose () {
      removeModelObserver(this);
    }

    render ($$) {
      const { model, name, label, children, hideWhenEmpty } = this.props;
      const SectionLabel = this.getComponent('section-label');

      let el = $$('div')
        .addClass('sc-manuscript-section')
        .addClass(`sm-${name}`)
        .attr({
          'data-section': name
        });
      // only rendering content if
      if (hideWhenEmpty && model.length === 0) {
        el.addClass('sm-empty');
      } else {
        el.append($$(SectionLabel, { label }));
        el.append(children);
      }

      return el
    }

    _onModelUpdate () {
      if (this.props.hideWhenEmpty) {
        this.rerender();
      }
    }
  }

  class ManuscriptComponent extends substance.Component {
    render ($$) {
      const manuscript = this.props.model;
      const AuthorsListComponent = this.getComponent('authors-list');
      const ReferenceListComponent = this.getComponent('reference-list');

      let el = $$('div').addClass('sc-manuscript');

      // TODO: maybe we want to be able to configure if a section should be hidden when empty

      // Title
      let titleModel = manuscript.getTitle();
      el.append(
        $$(ManuscriptSection, {
          name: 'title',
          label: this.getLabel('title-label'),
          model: titleModel
        }).append(
          renderModel($$, this, titleModel, {
            placeholder: this.getLabel('title-placeholder')
          }).addClass('sm-title')
        )
      );
      // Sub-title
      let subTitleModel = manuscript.getSubTitle();
      el.append(
        $$(ManuscriptSection, {
          name: 'subtitle',
          label: this.getLabel('subtitle-label'),
          model: subTitleModel
        }).append(
          renderModel($$, this, subTitleModel, {
            placeholder: this.getLabel('subtitle-placeholder')
          }).addClass('sm-subtitle')
        )
      );
      // Authors
      let authorsModel = manuscript.getAuthors();
      el.append(
        $$(ManuscriptSection, {
          name: 'authors',
          label: this.getLabel('authors-label'),
          model: authorsModel,
          hideWhenEmpty: true
        }).append(
          $$(AuthorsListComponent, {
            model: authorsModel,
            placeholder: this.getLabel('authors-placeholder')
          }).addClass('sm-authors')
        )
      );
      // Abstract
      let abstractModel = manuscript.getAbstract();
      el.append(
        $$(ManuscriptSection, {
          name: 'abstract',
          label: this.getLabel('abstract-label'),
          model: abstractModel
        }).append(
          renderModel($$, this, abstractModel, {
            name: 'abstract',
            placeholder: this.getLabel('abstract-placeholder')
          }).addClass('sm-abstract')
        )
      );
      // Body
      let bodyModel = manuscript.getBody();
      el.append(
        $$(ManuscriptSection, {
          name: 'body',
          label: this.getLabel('body-label'),
          model: bodyModel
        }).append(
          renderModel($$, this, bodyModel, {
            name: 'body',
            placeholder: this.getLabel('body-placeholder')
          }).addClass('sm-body')
        )
      );
      // Footnotes
      let footnotesModel = manuscript.getFootnotes();
      el.append(
        $$(ManuscriptSection, {
          name: 'footnotes',
          label: this.getLabel('footnotes-label'),
          model: footnotesModel,
          hideWhenEmpty: true
        }).append(
          renderModel($$, this, footnotesModel).addClass('sm-footnotes')
        )
      );
      // References
      let referencesModel = manuscript.getReferences();
      el.append(
        $$(ManuscriptSection, {
          name: 'references',
          label: this.getLabel('references-label'),
          model: referencesModel,
          hideWhenEmpty: true
        }).append(
          $$(ReferenceListComponent, {
            model: referencesModel
          }).addClass('sm-references')
        )
      );

      return el
    }
  }

  class ModelPreviewComponent extends substance.Component {
    didMount () {
      this.context.appState.addObserver(['document'], this._onDocumentChange, this, { stage: 'render' });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    render ($$) {
      // TODO: rethink this. IMO rendering should not be part of the Article API
      // Either it could be part of the general Model API, i.e. model.previewHtml()
      // or we could use some kind of configurable renderer, very much like a converter
      let node = this.props.node;
      let el = $$('div').addClass('sc-model-preview');
      el.html(
        this.context.api._renderEntity(node)
      );
      return el
    }

    _onDocumentChange (change) {
      ifNodeOrRelatedHasChanged(this.props.node, change, () => this.rerender());
    }
  }

  class ParagraphComponent extends TextNodeComponent {
    getClassNames () {
      return 'sc-paragraph sc-text-node'
    }
  }

  // ATTENTION: this is displays all RefContribs of a Reference in an 'in-place' style i.e. like a little table
  class InplaceRefContribsEditor extends ValueComponent {
    getActionHandlers () {
      return {
        removeContrib: this._removeContrib
      }
    }
    render ($$) {
      const Button$$1 = this.getComponent('button');

      let el = $$('div').addClass('sc-inplace-ref-contrib-editor');
      el.append(this._renderRefContribs($$));
      el.append(
        $$(Button$$1, {
          icon: 'insert'
        }).addClass('se-add-value')
          .on('click', this._addContrib)
      );
      return el
    }

    _renderRefContribs ($$) {
      const model = this.props.model;
      let items = model.getItems();
      return items.map(item => this._renderRefContrib($$, item))
    }

    _renderRefContrib ($$, refContrib) {
      let id = refContrib.id;
      return $$(InplaceRefContribEditor, { node: refContrib }).ref(id)
    }

    _addContrib () {
      const model = this.props.model;
      const path = model.getPath();
      this.context.api._appendChild(path, { type: 'ref-contrib' });
    }

    _removeContrib (contrib) {
      const model = this.props.model;
      const path = model.getPath();
      this.context.api._deleteChild(path, contrib);
    }
  }

  class InplaceRefContribEditor extends NodeComponent {
    render ($$) {
      const node = this.props.node;
      const Button$$1 = this.getComponent('button');
      let el = $$('div').addClass('sc-inplace-ref-contrib-editor');
      el.append(
        $$(FormRowComponent).attr('data-id', node.id).addClass('sm-ref-contrib').append(
          this._renderValue($$, 'name', {
            placeholder: this.getLabel('name')
          }).addClass('sm-name'),
          this._renderValue($$, 'givenNames', {
            placeholder: this.getLabel('given-names')
          }).addClass('sm-given-names'),
          $$(Button$$1, {
            icon: 'remove'
          // TODO: do we need this ref?
          }).ref('remove-button').addClass('se-remove-value')
            .on('click', this._onRemove)
        )
      );
      return el
    }

    _onRemove () {
      this.send('removeContrib', this.props.node);
    }
  }

  class ReferenceComponent extends NodeComponent {
    render ($$) {
      let mode = this.props.mode;
      let node = this.props.node;
      let label = this._getReferenceLabel();
      // TODO: this should also use model
      let html = this.context.api._renderEntity(node);
      // TODO: use the label provider
      html = html || '<i>Not available</i>';
      if (mode === PREVIEW_MODE) {
        // NOTE: We return PreviewComponent directly, to prevent inheriting styles from .sc-reference
        return $$(PreviewComponent, {
          id: node.id,
          label,
          description: $$('div').html(html)
        })
      } else if (mode === METADATA_MODE) {
        return $$(ReferenceMetadataComponent, { node })
      } else {
        let el = $$('div').addClass('sc-reference');
        el.append(
          $$('div').addClass('se-label').append(label),
          $$('div').addClass('se-text').html(html)
        ).attr('data-id', node.id);
        return el
      }
    }

    _getReferenceLabel () {
      return getLabel(this.props.node) || '?'
    }
  }

  class ReferenceMetadataComponent extends DefaultNodeComponent {
    _getClassNames () {
      return 'sc-reference sm-metadata'
    }
    // using a special inplace property editor for 'ref-contrib's
    _getPropertyEditorClass (name, value) {
      if (value.hasTargetType('ref-contrib')) {
        return InplaceRefContribsEditor
      } else {
        return super._getPropertyEditorClass(name, value)
      }
    }
  }

  class ReferenceListComponent extends substance.CustomSurface {
    didMount () {
      super.didMount();

      const appState = this.context.appState;
      appState.addObserver(['document'], this.rerender, this, { stage: 'render', document: { path: ['article', 'references'] } });
      appState.addObserver(['selection'], this.rerender, this, { stage: 'render' });
    }

    dispose () {
      super.dispose();
      // TODO: as we have a node for references now, we should turn this into a NodeComponent instead
      this.context.appState.removeObserver(this);
    }

    getInitialState () {
      let bibliography = this._getBibliography();
      return {
        hidden: (bibliography.length === 0)
      }
    }

    render ($$) {
      const sel = this.context.appState.selection;
      const bibliography = this._getBibliography();

      let el = $$('div').addClass('sc-reference-list')
        .attr('data-id', 'ref-list');

      if (this.state.hidden) {
        el.addClass('sm-hidden');
        return el
      }

      bibliography.forEach(ref => {
        const referenceEl = renderNode($$, this, ref)
          .ref(ref.id)
          .on('click', this._selectReference.bind(this, ref.id));

        if (sel && sel.customType === 'reference' && sel.data.referenceId === ref.id) {
          referenceEl.addClass('sm-selected');
        }

        el.append(referenceEl);
      });

      return el
    }

    _getCustomResourceId () {
      return 'reference-list'
    }

    _getBibliography () {
      let references = this.props.model.getItems();
      references.sort((a, b) => {
        return getPos(a) - getPos(b)
      });
      return references
    }

    _selectReference (referenceId) {
      const newSel = {
        type: 'custom',
        customType: 'reference',
        nodeId: referenceId,
        data: {
          referenceId
        }
      };
      this.context.editorSession.setSelection(newSel);
    }
  }

  class SectionLabel extends substance.Component {
    render ($$) {
      const label = this.props.label;
      return $$('div').addClass('sc-section-label')
        .append(this.getLabel(label))
    }
  }

  function createTableSelection (tableId, data, surfaceId) {
    if (!data.anchorCellId || !data.focusCellId) throw new Error('Invalid selection data')
    return {
      type: 'custom',
      customType: 'table',
      nodeId: tableId,
      data: data,
      surfaceId
    }
  }

  function getSelectionData (sel) {
    if (sel && sel.customType === 'table') {
      return sel.data
    }
    return {}
  }

  function getSelectedRange (table, selData) {
    return getCellRange(table, selData.anchorCellId, selData.focusCellId)
  }

  function computeSelectionRectangle (ulRect, lrRect) {
    let selRect = {};
    selRect.top = ulRect.top;
    selRect.left = ulRect.left;
    selRect.width = lrRect.left + lrRect.width - selRect.left;
    selRect.height = lrRect.top + lrRect.height - selRect.top;
    return selRect
  }

  function getCellRange (table, anchorCellId, focusCellId) {
    let anchorCell = table.get(anchorCellId);
    let focusCell = table.get(focusCellId);
    let startRow = Math.min(anchorCell.rowIdx, focusCell.rowIdx);
    let startCol = Math.min(anchorCell.colIdx, focusCell.colIdx);
    let endRow = Math.max(anchorCell.rowIdx + anchorCell.rowspan - 1, focusCell.rowIdx + focusCell.rowspan - 1);
    let endCol = Math.max(anchorCell.colIdx + anchorCell.colspan - 1, focusCell.colIdx + focusCell.colspan - 1);
    return { startRow, startCol, endRow, endCol }
  }

  function computeUpdatedSelection (table, selData, dr, dc, expand) {
    let focusCellId = selData.focusCellId;
    let focusCell = table.get(focusCellId);
    let rowIdx = focusCell.rowIdx;
    let colIdx = focusCell.colIdx;
    let rowspan = focusCell.rowspan;
    let colspan = focusCell.colspan;
    let newFocusCell;
    if (dr) {
      if (dr < 0) {
        newFocusCell = table.getCell(rowIdx + dr, colIdx);
      } else if (dr > 0) {
        newFocusCell = table.getCell(rowIdx + rowspan - 1 + dr, colIdx);
      }
    } else if (dc) {
      if (dc < 0) {
        newFocusCell = table.getCell(rowIdx, colIdx + dc);
      } else if (dc > 0) {
        newFocusCell = table.getCell(rowIdx, colIdx + colspan - 1 + dc);
      }
    }
    if (newFocusCell) {
      if (newFocusCell.shadowed) newFocusCell = newFocusCell.masterCell;
      let newFocusCellId = newFocusCell.id;
      let newAnchorCellId = selData.anchorCellId;
      if (!expand) {
        newAnchorCellId = newFocusCellId;
      }
      return {
        anchorCellId: newAnchorCellId,
        focusCellId: newFocusCellId
      }
    } else {
      return selData
    }
  }

  function generateTable (doc, nrows, ncols, tableId) {
    return substance.documentHelpers.createNodeFromJson(doc, Table.getTemplate({
      id: tableId,
      headerRows: 1,
      rows: nrows,
      cols: ncols
    }))
  }

  function createTableFromTabularData (doc, data, tableId) {
    return substance.documentHelpers.createNodeFromJson(doc, {
      id: tableId,
      type: 'table',
      rows: data.map(rowData => {
        return {
          type: 'table-row',
          cells: rowData.map(cellValue => {
            return {
              type: 'table-cell',
              content: String(cellValue)
            }
          })
        }
      })
    })
  }

  const { getRangeFromMatrix } = substance.tableHelpers;

  var tableHelpers = /*#__PURE__*/Object.freeze({
    createTableSelection: createTableSelection,
    getSelectionData: getSelectionData,
    getSelectedRange: getSelectedRange,
    computeSelectionRectangle: computeSelectionRectangle,
    getCellRange: getCellRange,
    computeUpdatedSelection: computeUpdatedSelection,
    generateTable: generateTable,
    createTableFromTabularData: createTableFromTabularData,
    getRangeFromMatrix: getRangeFromMatrix
  });

  class TableCellEditor extends TextPropertyEditorNew {
    _getClassNames () {
      return 'sc-table-cell-editor ' + super._getClassNames()
    }

    _handleEscapeKey (event) {
      this.__handleKey(event, 'escape');
    }

    _handleEnterKey (event) {
      this.__handleKey(event, 'enter');
    }

    _handleTabKey (event) {
      this.__handleKey(event, 'tab');
    }

    __handleKey (event, name) {
      event.stopPropagation();
      event.preventDefault();
      this.el.emit(name, {
        altKey: event.altKey,
        ctrlKey: event.ctrlKey,
        metaKey: event.metaKey,
        shiftKey: event.shiftKey,
        code: event.code
      });
    }
  }

  class TableCellComponent extends NodeComponent {
    render ($$) {
      const cell = this.props.node;
      let el = $$(cell.heading ? 'th' : 'td');
      el.addClass('sc-table-cell');
      el.attr({
        'data-id': cell.id,
        'data-row-idx': cell.rowIdx,
        'data-col-idx': cell.colIdx
      });
      if (cell.rowspan > 1) {
        el.attr('rowspan', cell.rowspan);
      }
      if (cell.colspan > 1) {
        el.attr('colspan', cell.colspan);
      }
      el.append(
        $$(TableCellEditor, {
          path: cell.getPath(),
          disabled: this.props.disabled,
          multiLine: true
        }).ref(cell.id)
      );
      return el
    }

    getId () {
      return this.getAttribute('data-id')
    }
  }

  class TableContextMenu extends ToolPanel {
    render ($$) {
      let el = $$('div').addClass('sc-table-context-menu sc-context-menu');
      el.append(
        $$('div').append(
          this._renderItems($$)
        ).ref('entriesContainer')
      );
      return el
    }
  }

  class TableComponent extends substance.CustomSurface {
    constructor (...args) {
      super(...args);

      this._selectionData = {};
      this._clipboard = new ClipboardNew();
    }

    getChildContext () {
      return {
        surface: this,
        parentSurfaceId: this.getId(),
        // HACK: nulling this so that nested surfaces get an id that are relative to
        // this surface instead of the isolatedNodeComponent
        isolatedNodeComponent: null
      }
    }

    shouldRerender (newProps) {
      return (newProps.node !== this.props.node || newProps.disabled !== this.props.disabled)
    }

    didMount () {
      super.didMount();

      this._tableSha = this.props.node._getSha();
      const appState = this.context.appState;

      appState.addObserver(['document'], this._onDocumentChange, this, { stage: 'render' });
      appState.addObserver(['selection'], this._onSelectionChange, this, { stage: 'render' });

      this._positionSelection(this._getSelectionData());
    }

    dispose () {
      super.dispose();

      const appState = this.context.appState;
      appState.off(this);
    }

    render ($$) {
      let el = $$('div').addClass('sc-table');
      el.on('mousedown', this._onMousedown)
        .on('mouseup', this._onMouseup)
        .on('click', this._prevent);
      el.append(this._renderTable($$));
      el.append(this._renderKeyTrap($$));
      el.append(this._renderUnclickableOverlays($$));
      // el.append(this._renderClickableOverlays($$))
      el.append(this._renderContextMenu($$));
      return el
    }

    _renderTable ($$) {
      let table = $$('table').ref('table');
      let node = this.props.node;
      let matrix = node.getCellMatrix();
      for (let i = 0; i < matrix.length; i++) {
        let cells = matrix[i];
        let tr = $$('tr');
        for (let j = 0; j < cells.length; j++) {
          if (cells[j].shadowed) continue
          let cell = cells[j];
          tr.append(
            $$(TableCellComponent, { node: cell, disabled: true })
              .ref(cell.id)
              .on('enter', this._onCellEnter)
              .on('tab', this._onCellTab)
              .on('escape', this._onCellEscape)
          );
        }
        table.append(tr);
      }
      table.on('mousemove', this._onMousemove)
        .on('dblclick', this._onDblclick)
        .on('contextmenu', this._onContextMenu)
        .on('contextmenuitemclick', this._onContextMenuItemClick);
      return table
    }

    _renderKeyTrap ($$) {
      return $$('textarea').addClass('se-keytrap').ref('keytrap')
        .css({ position: 'absolute', width: 0, height: 0, opacity: 0 })
        .on('keydown', this._onKeydown)
        .on('input', this._onInput)
        .on('copy', this._onCopy)
        .on('paste', this._onPaste)
        .on('cut', this._onCut)
    }

    _renderUnclickableOverlays ($$) {
      let el = $$('div').addClass('se-unclickable-overlays');
      el.append(
        this._renderSelectionOverlay($$)
      );
      el.append(
        this.props.unclickableOverlays
      );
      return el
    }

    _renderSelectionOverlay ($$) {
      let el = $$('div').addClass('se-selection-overlay');
      el.append(
        $$('div').addClass('se-selection-anchor').ref('selAnchor').css('visibility', 'hidden'),
        $$('div').addClass('se-selection-range').ref('selRange').css('visibility', 'hidden')
      );
      return el
    }

    _renderContextMenu ($$) {
      const configurator = this.context.configurator;
      let contextMenu;
      const items = configurator.getToolPanel('table-context-menu');
      if (items) {
        contextMenu = $$(Managed(TableContextMenu), {
          items,
          bindings: ['commandStates']
        });
      } else {
        contextMenu = $$('div');
      }
      contextMenu.ref('contextMenu')
        .addClass('se-context-menu')
        .css({ display: 'none' });
      return contextMenu
    }

    _onDocumentChange () {
      const table = this.props.node;
      // Note: using a simplified way to detect when a table
      // has changed structurally
      // TableElementNode is detecting such changes and
      // updates an internal 'sha' that we can compare against
      if (table._hasShaChanged(this._tableSha)) {
        this.rerender();
        this._tableSha = table._getSha();
      }
    }

    _onSelectionChange () {
      const doc = this.context.editorSession.getDocument();
      const sel = this.context.appState.selection;
      const self = this;
      if (!sel || sel.isNull()) {
        _disableActiveCell();
        this._hideSelection();
      } else if (sel.isPropertySelection()) {
        let nodeId = sel.path[0];
        if (this._activeCell !== nodeId) {
          _disableActiveCell();
          let newCellEditor = this.refs[nodeId];
          if (newCellEditor) {
            // console.log('ENABLING CELL EDITOR', nodeId)
            newCellEditor.extendProps({ disabled: false });
            this._activeCell = nodeId;
          }
        }
        if (this._activeCell) {
          // TODO: this could be simplified
          let cell = doc.get(this._activeCell);
          this._positionSelection({
            type: 'range',
            anchorCellId: cell.id,
            focusCellId: cell.id
          }, true);
        } else {
          this._hideSelection();
        }
      } else if (sel.surfaceId !== this.getId()) {
        _disableActiveCell();
        this._hideSelection();
      } else {
        _disableActiveCell();
      }
      this._hideContextMenu();

      function _disableActiveCell () {
        const activeCellId = self._activeCell;
        if (activeCellId) {
          let cellEditor = self.refs[activeCellId];
          if (cellEditor) {
            // console.log('DISABLING CELL EDITOR', activeCellId)
            cellEditor.extendProps({ disabled: true });
          }
          self._activeCell = null;
        }
      }
    }

    _onMousedown (e) {
      // console.log('TableComponent._onMousedown()')
      e.stopPropagation();
      // TODO: do not update the selection if right-clicked and already having a selection
      if (substance.platform.inBrowser) {
        substance.DefaultDOMElement.wrap(window.document).on('mouseup', this._onMouseup, this, {
          once: true
        });
      }
      // console.log('_onMousedown', e)
      let selData = this._selectionData;
      if (!selData) selData = this._selectionData = {};
      let targetInfo = this._getClickTargetForEvent(e);
      // console.log('target', target)
      if (!targetInfo) return

      let isRightButton = substance.domHelpers.isRightButton(e);
      if (isRightButton) {
        // console.log('IS RIGHT BUTTON')
        // this will be handled by onContextMenu
        if (targetInfo.type === 'cell') {
          let targetCell = this.props.node.get(targetInfo.id);
          let _needSetSelection = true;
          let _selData = this._getSelectionData();
          if (_selData && targetCell) {
            let { startRow, startCol, endRow, endCol } = getCellRange(this.props.node, _selData.anchorCellId, _selData.focusCellId);
            _needSetSelection = (
              targetCell.colIdx < startCol || targetCell.colIdx > endCol ||
              targetCell.rowIdx < startRow || targetCell.rowIdx > endRow
            );
          }
          if (_needSetSelection) {
            this._isSelecting = true;
            selData.anchorCellId = targetInfo.id;
            selData.focusCellId = targetInfo.id;
            this._requestSelectionChange(this._createTableSelection(selData));
          }
        }
        return
      }
      if (targetInfo.type === 'cell') {
        this._isSelecting = true;
        selData.focusCellId = targetInfo.id;
        if (!e.shiftKey) {
          selData.anchorCellId = targetInfo.id;
        }
        e.preventDefault();
        this._requestSelectionChange(this._createTableSelection(selData));
      }
    }

    _onMouseup (e) {
      e.stopPropagation();
      if (this._isSelecting) {
        e.preventDefault();
        this._isSelecting = false;
      }
    }

    _onMousemove (e) {
      if (this._isSelecting) {
        const selData = this._selectionData;
        let cellId = this._mapClientXYToCellId(e.clientX, e.clientY);
        if (cellId !== selData.focusCellId) {
          selData.focusCellId = cellId;
          this._requestSelectionChange(this._createTableSelection(selData));
        }
      }
    }

    _onDblclick (e) {
      e.preventDefault();
      e.stopPropagation();
      this._requestEditCell();
    }

    _onKeydown (e) {
      let handled = false;
      switch (e.keyCode) {
        case substance.keys.LEFT:
          this._nav(0, -1, e.shiftKey);
          handled = true;
          break
        case substance.keys.RIGHT:
          this._nav(0, 1, e.shiftKey);
          handled = true;
          break
        case substance.keys.UP:
          this._nav(-1, 0, e.shiftKey);
          handled = true;
          break
        case substance.keys.DOWN:
          this._nav(1, 0, e.shiftKey);
          handled = true;
          break
        case substance.keys.ENTER: {
          this._requestEditCell();
          handled = true;
          break
        }
        case substance.keys.TAB: {
          this._nav(0, 1);
          handled = true;
          break
        }
        case substance.keys.DELETE:
        case substance.keys.BACKSPACE: {
          this._clearSelection();
          handled = true;
          break
        }
        default:
          //
      }
      // let an optional keyboard manager handle the key
      if (!handled) {
        const keyboardManager = this.context.keyboardManager;
        if (keyboardManager) {
          handled = keyboardManager.onKeydown(e);
        }
      }
      if (handled) {
        e.preventDefault();
        e.stopPropagation();
      }
    }

    /*
      Type into cell (replacing the existing content)
    */
    _onInput () {
      const value = this.refs.keytrap.val();
      this._requestEditCell(value);
      // Clear keytrap after sending an action
      this.refs.keytrap.val('');
    }

    _onCellEnter (e) {
      e.stopPropagation();
      e.preventDefault();
      let cellEl = substance.DefaultDOMElement.wrap(e.target).getParent();
      if (e.detail.shiftKey) {
        this.context.api.getTableAPI().insertSoftBreak();
      } else {
        let cellId = _getCellId(cellEl);
        this._nav(1, 0, false, { anchorCellId: cellId, focusCellId: cellId });
      }
    }

    _onCellTab (e) {
      e.stopPropagation();
      e.preventDefault();
      let cellEl = substance.DefaultDOMElement.wrap(e.target).getParent();
      let cellId = _getCellId(cellEl);
      this._nav(0, 1, false, { anchorCellId: cellId, focusCellId: cellId });
    }

    _onCellEscape (e) {
      e.stopPropagation();
      e.preventDefault();
      let cellEl = substance.DefaultDOMElement.wrap(e.target).getParent();
      let cellId = _getCellId(cellEl);
      this._requestSelectionChange(this._createTableSelection({ anchorCellId: cellId, focusCellId: cellId }));
    }

    _onCopy (e) {
      e.preventDefault();
      e.stopPropagation();
      let clipboardData = e.clipboardData;
      this._clipboard.copy(clipboardData, this.context);
    }

    _onCut (e) {
      e.preventDefault();
      e.stopPropagation();
      let clipboardData = e.clipboardData;
      this._clipboard.cut(clipboardData, this.context);
    }

    _onPaste (e) {
      e.preventDefault();
      e.stopPropagation();
      let clipboardData = e.clipboardData;
      // TODO: allow to force plain-text paste
      this._clipboard.paste(clipboardData, this.context);
    }

    _onContextMenu (e) {
      e.preventDefault();
      e.stopPropagation();
      this._showContextMenu(e);
    }

    _onContextMenuItemClick (e) {
      e.preventDefault();
      e.stopPropagation();
      this._hideContextMenu();
    }

    _getSelection () {
      return this.context.editorSession.getSelection()
    }

    _getSelectionData () {
      let sel = this._getSelection();
      if (sel && sel.surfaceId === this.getId()) {
        return sel.data
      }
    }

    _requestEditCell (initialValue) {
      let selData = this._getSelectionData();
      if (selData) {
        // type over cell
        if (initialValue) {
          // TODO: is there a more common action to describe this?
          // seems that this is like 'typing'
          // Otherwise it is only setting the selection
          this._getTableApi().insertText(initialValue);
        } else {
          // TODO: do we have a general API to set the selection
          // into a specific editor?
          const doc = this.props.node.getDocument();
          let cell = doc.get(selData.anchorCellId);
          let path = cell.getPath();
          // TODO: we need low-level API to set the selection
          this.context.api._setSelection({
            type: 'property',
            path,
            startOffset: cell.getLength(),
            surfaceId: this.getId() + '/' + substance.getKeyForPath(path)
          });
        }
      }
    }

    _requestSelectionChange (newSel) {
      // console.log('requesting selection change', newSel)
      this.context.editorSession.setSelection(newSel);
    }

    _getClickTargetForEvent (e) {
      let target = substance.DefaultDOMElement.wrap(e.target);
      let cellEl = substance.domHelpers.findParent(target, 'td,th');
      if (cellEl) {
        let cellId = _getCellId(cellEl);
        return { type: 'cell', id: cellId }
      }
    }

    _getRowCol (cellEl) {
      let rowIdx = parseInt(cellEl.getAttribute('data-row-idx'), 10);
      let colIdx = parseInt(cellEl.getAttribute('data-col-idx'), 10);
      return [rowIdx, colIdx]
    }

    _mapClientXYToCellId (x, y) {
      // TODO: this could be optimized using bisect search
      let cellEls = this.refs.table.el.findAll('th,td');
      for (let i = 0; i < cellEls.length; i++) {
        let cellEl = cellEls[i];
        let rect = substance.domHelpers.getBoundingRect(cellEl);
        if (substance.domHelpers.isXInside(x, rect) && substance.domHelpers.isYInside(y, rect)) {
          return _getCellId(cellEl)
        }
      }
    }

    _nav (dr, dc, expand, selData) {
      selData = selData || this._getSelectionData();
      if (selData) {
        let newSelData = computeUpdatedSelection(this.props.node, selData, dr, dc, expand);
        this._requestSelectionChange(this._createTableSelection(newSelData));
      }
    }

    _getCustomResourceId () {
      return this.props.node.id
    }

    _clearSelection () {
      let selData = this._getSelectionData();
      if (selData) {
        this._getTableApi().deleteSelection();
      }
    }

    rerenderDOMSelection () {
      // console.log('SheetComponent.rerenderDOMSelection()')
      this._positionSelection(this._getSelectionData());
      // // put the native focus into the keytrap so that we
      // // receive keyboard events
      this.refs.keytrap.el.focus({ preventScroll: true });
    }

    _positionSelection (selData, focused) {
      // TODO: find a better criteria for integrity checking
      if (!selData) {
        this._hideSelection();
        return
      }
      let { anchorCellId, focusCellId } = selData;

      let anchorCellComp = this._getActualCellComp(anchorCellId);
      let anchorRect = substance.getRelativeBoundingRect(anchorCellComp.el, this.el);
      this.refs.selAnchor.css(this._getStylesForRectangle(anchorRect));

      if (!focused) {
        let rangeRect;
        if (focusCellId === anchorCellId) {
          rangeRect = anchorRect;
        } else {
          let focusCellComp = this._getActualCellComp(focusCellId);
          let focusRect = substance.getRelativeBoundingRect(focusCellComp.el, this.el);
          rangeRect = substance.domHelpers.getBoundingRectForRects(anchorRect, focusRect);
        }
        this.refs.selRange.css(this._getStylesForRectangle(rangeRect));
      } else {
        this.refs.selRange.css('visibility', 'hidden');
      }
    }

    _getActualCellComp (cellId) {
      let table = this.props.node;
      let cell = table.get(cellId);
      if (cell.shadowed) cell = cell.masterCell;
      return this.refs[cell.id]
    }

    _hideSelection () {
      this.refs.selAnchor.css('visibility', 'hidden');
      this.refs.selRange.css('visibility', 'hidden');
    }

    _hideContextMenu () {
      this.refs.contextMenu.addClass('sm-hidden');
    }

    _showContextMenu (e) {
      let contextMenu = this.refs.contextMenu;
      let offset = this.el.getOffset();
      contextMenu.css({
        display: 'block',
        top: e.clientY - offset.top,
        left: e.clientX - offset.left
      });
      contextMenu.removeClass('sm-hidden');
    }

    _getStylesForRectangle (rect) {
      let styles = { visibility: 'hidden' };
      if (rect) {
        Object.assign(styles, rect);
        if (isFinite(rect.top) && isFinite(rect.left) &&
          isFinite(rect.width) && isFinite(rect.height)) {
          styles.visibility = 'visible';
        }
      }
      return styles
    }

    _createTableSelection (selData) {
      let tableId = this.props.node.id;
      let surfaceId = this.getId();
      let sel = createTableSelection(tableId, selData, surfaceId);
      return sel
    }

    _getTableApi () {
      return this.context.api.getTableAPI()
    }

    _prevent (event) {
      event.stopPropagation();
      event.preventDefault();
    }
  }

  function _getCellId (cellEl) {
    return substance.Component.unwrap(cellEl).getId()
  }

  // TODO: do we need this anymore?
  class FootnoteEditor extends ValueComponent {
    render ($$) {
      return $$('div').addClass('sc-table-footnotes-editor').append(
        this._renderFootnotes($$)
      )
    }

    _renderFootnotes ($$) {
      const model = this.props.model;
      let items = model.getItems();
      return items.map(item => $$(FootnoteComponent, { node: item }).ref(item.id))
    }
  }

  class TableFigureComponentWithMetadata extends FigurePanelComponentWithMetadata {
    _getClassNames () {
      return `sc-table-figure-metadata`
    }

    _getPropertyEditorClass (name, value) {
      // skip 'label' here, as it is shown 'read-only' in the header instead
      if (name === 'label') {
        return null
      // special editor to pick license type
      } else if (name === 'license') {
        return LicenseEditor
      } else if (name === 'footnotes') {
        return FootnoteEditor
      } else {
        return super._getPropertyEditorClass(name, value)
      }
    }
  }

  /**
   * A TableFigure is similar to a figure but has only one panel, and a table as content.
   * Additionally it can contain footnotes.
   */
  class TableFigureComponent extends FigurePanelComponent {
    _getClassNames () {
      return `sc-table-figure`
    }

    _renderManuscriptVersion ($$) {
      const mode = this._getMode();
      const node = this.props.node;
      const SectionLabel = this.getComponent('section-label');

      let el = $$('div')
        .addClass(this._getClassNames())
        .attr('data-id', node.id)
        .addClass(`sm-${mode}`)
        .addClass();

      el.append(
        $$(SectionLabel, { label: 'label-label' }),
        $$(LabelComponent, { node }),
        // no label for the graphic
        this._renderContent($$),
        $$(SectionLabel, { label: 'title-label' }),
        this._renderValue($$, 'title', { placeholder: this.getLabel('title-placeholder') }).addClass('se-title'),
        $$(SectionLabel, { label: 'legend-label' }),
        this._renderValue($$, 'legend', { name: 'legend', placeholder: this.getLabel('legend-placeholder') }).addClass('se-legend')
      );

      // FIXME: does not react to node.footnotes changes
      if (node.footnotes.length > 0) {
        el.append(
          $$(SectionLabel, { label: 'footnotes-label' }),
          this._renderValue($$, 'footnotes').ref('footnotes').addClass('se-footnotes')
        );
      }

      return el
    }

    _renderMetadataVersion ($$) {
      return $$(TableFigureComponentWithMetadata, { node: this.props.node }).ref('metadata')
    }
  }

  class UnsupportedNodeComponent extends substance.IsolatedNodeComponent {
    _getContentClass () {
      return UnsupportedContentComponent
    }
  }

  class UnsupportedContentComponent extends substance.Component {
    render ($$) {
      const node = this.props.node;
      let data;
      if (node._isXMLNode) {
        data = node.toXML().serialize();
      } else if (node.data) {
        data = node.data;
      } else {
        data = JSON.stringify(node.toJSON());
      }
      let el = $$('div').addClass('sc-unsupported').append(
        $$('pre').text(data)
      ).attr({
        'data-id': node.id,
        'contenteditable': false
      });

      return el
    }
  }

  class UnsupportedInlineNodeComponent extends substance.Component {
    render ($$) {
      const node = this.props.node;
      let data;
      if (node._isXMLNode) {
        data = node.toXML().serialize();
      } else if (node.data) {
        data = node.data;
      } else {
        data = JSON.stringify(node.toJSON());
      }
      let el = $$('span').addClass('sc-unsupported-inline-node').append(
        $$('code').text(data)
      ).attr({
        'data-id': node.id,
        contenteditable: false
      });
      return el
    }
  }

  // left side: node type
  // right side: ref-type
  const REF_TYPES = {
    'block-formula': BlockFormula.refType,
    'figure': 'fig',
    'footnote': 'fn',
    'refererence': 'bibr',
    'table-figure': 'table',
    'supplementary-file': 'file'
  };

  // left side: ref-type
  // right side: [... node types]
  const XREF_TARGET_TYPES = Object.keys(REF_TYPES).reduce((m, type) => {
    const refType = REF_TYPES[type];
    if (!m[refType]) m[refType] = [];
    m[refType].push(type);
    return m
  }, {
    'table-fn': ['footnote']
  });

  function getXrefTargets (xref) {
    return xref.refTargets
  }

  function getXrefLabel (xref) {
    return getLabel(xref)
  }

  class XrefComponent extends NodeComponent {
    render ($$) {
      let node = this.props.node;
      let refType = node.refType;
      let label = getXrefLabel(node);
      let el = $$('span').addClass('sc-xref sm-' + refType);
      if (!label) {
        el.addClass('sm-no-label');
        el.append('?');
      } else {
        el.append(label);
      }
      return el
    }
  }

  class SupplementaryFileComponent extends NodeComponent {
    render ($$) {
      const mode = this._getMode();
      // different rendering when rendered as preview or in metadata view
      if (mode === PREVIEW_MODE) {
        return this._renderPreviewVersion($$)
      }

      const node = this.props.node;
      // HACK: ATM, we do not have a label generator for supplementary files
      // that are inside a figure legend. It has not been specified yet
      // if these should have a label at all, or what the label should look like.
      const label = getLabel(node) || this.getLabel('supplementary-file');
      const SectionLabel = this.getComponent('section-label');
      // NOTE: we need an editable href only for remote files, for local files we just need to render a file name
      const hrefSection = node.remote ? this._renderValue($$, 'href', { placeholder: this.getLabel('supplementary-file-link-placeholder') })
        .addClass('se-href') : $$('div').addClass('se-href').text(node.href);

      let el = $$('div').addClass(`sc-supplementary-file sm-${mode}`);
      el.append(
        $$('div').addClass('se-header').append(
          // FIXME: not using a dedicated component for the label means that this is not updated
          $$('div').addClass('se-label').text(label)
        )
      );
      el.append(
        $$(SectionLabel, { label: 'legend-label' }),
        this._renderValue($$, 'legend', { placeholder: this.getLabel('legend-placeholder') }),
        $$(SectionLabel, { label: node.remote ? 'file-location' : 'file-name' }),
        hrefSection
      );
      return el
    }

    _renderPreviewVersion ($$) {
      const node = this.props.node;
      let label = getLabel(node);
      // TODO: PreviewComponent should work with a model
      // FIXME: there is problem with redirected components
      // and Component as props
      return $$('div').append($$(PreviewComponent, {
        id: node.id,
        label
      }))
    }

    _getMode () {
      return this.props.mode || 'manuscript'
    }
  }

  var ManuscriptContentPackage = {
    name: 'manuscript-content',
    configure (config) {
      config.addComponent('abstract', AbstractComponent);
      config.addComponent('authors-list', AuthorsListComponent);
      config.addComponent('bold', AnnotationComponent);
      config.addComponent('block-formula', BlockFormulaComponent);
      config.addComponent('block-quote', BlockQuoteComponent);
      config.addComponent('break', BreakComponent);
      config.addComponent('custom-metadata-field', CustomMetadataFieldComponent);
      config.addComponent('external-link', ExtLinkComponent);
      config.addComponent('figure', FigureComponent);
      config.addComponent('figure-panel', FigurePanelComponent);
      config.addComponent('footnote', FootnoteComponent);
      config.addComponent('heading', HeadingComponent);
      config.addComponent('inline-formula', InlineFormulaComponent);
      config.addComponent('inline-graphic', InlineGraphicComponent);
      config.addComponent('italic', AnnotationComponent);
      config.addComponent('list', ListComponent);
      config.addComponent('list-item', ListItemComponent);
      config.addComponent('manuscript', ManuscriptComponent);
      config.addComponent('monospace', AnnotationComponent);
      config.addComponent('overline', AnnotationComponent);
      config.addComponent('paragraph', ParagraphComponent);
      config.addComponent('reference', ReferenceComponent);
      config.addComponent('reference-list', ReferenceListComponent);
      config.addComponent('section-label', SectionLabel);
      config.addComponent('small-caps', AnnotationComponent);
      config.addComponent('strike-through', AnnotationComponent);
      config.addComponent('subscript', AnnotationComponent);
      config.addComponent('superscript', AnnotationComponent);
      config.addComponent('table', TableComponent);
      config.addComponent('table-figure', TableFigureComponent);
      config.addComponent('underline', AnnotationComponent);
      config.addComponent('unsupported-node', UnsupportedNodeComponent);
      config.addComponent('unsupported-inline-node', UnsupportedInlineNodeComponent);
      config.addComponent('xref', XrefComponent);

      config.addComponent('graphic', GraphicComponent);
      config.addComponent('supplementary-file', SupplementaryFileComponent);

      // TODO: either we use DefaultNodeComponent generally, but with better control over the look-and-feel
      // or we use it only in Metadata Editor, or in popups.
      // binding to 'entity' sounds no appropriate anymore, because we do not have the concept of 'Entity' anymore
      config.addComponent('entity', DefaultNodeComponent);
      config.addComponent('model-preview', ModelPreviewComponent);

      config.addLabel('abstract-label', 'Abstract');
      config.addLabel('abstract-placeholder', 'Enter abstract');
      config.addLabel('attribution-placeholder', 'Enter attribution');
      config.addLabel('authors-label', 'Authors');
      config.addLabel('body-label', 'Main text');
      config.addLabel('body-placeholder', 'Write your article here.');
      config.addLabel('caption-label', 'Caption');
      config.addLabel('caption-placeholder', 'Enter caption');
      config.addLabel('content-placeholder', 'Enter content');
      config.addLabel('file-upload-error', 'Something goes wrong');
      config.addLabel('file-upload-placeholder', 'Drag and drop or select item');
      // Note: we are registering a substring of other label to replace it with component
      config.addLabel('file-upload-select-placeholder', 'select');
      config.addLabel('footnote-placeholder', 'Enter footnote');
      config.addLabel('footnotes-label', 'Footnotes');
      config.addLabel('label-label', 'Label');
      config.addLabel('legend-label', 'Legend');
      config.addLabel('legend-placeholder', 'Enter legend');
      config.addLabel('metadata-label', 'Metadata');
      config.addLabel('references-label', 'References');
      config.addLabel('title-label', 'Title');
      config.addLabel('title-placeholder', 'Enter title');
      config.addLabel('subtitle-label', 'Subtitle');
      config.addLabel('subtitle-placeholder', 'Enter subtitle');
      config.addLabel('supplementary-file', 'Supplementary file');
      config.addLabel('supplementary-file-workflow-title', 'Add supplementary file');
      config.addLabel('supplementary-file-upload-label', 'Upload local file');
      config.addLabel('supplementary-file-link-label', 'Or use web link to downloadable file');
      config.addLabel('supplementary-file-link-placeholder', 'Enter url');

      // Used for rendering warning in case of missing images
      config.addIcon('graphic-load-error', { 'fontawesome': 'fa-warning' });
      config.addLabel('graphic-load-error', 'We couldn\'t load an image, sorry.');
    }
  }

  class SaveCommand extends substance.Command {
    getCommandState (params, context) {
      let archive = context.archive;
      if (!archive || !archive.hasPendingChanges()) {
        return substance.Command.DISABLED
      } else {
        return {
          disabled: false
        }
      }
    }

    execute (params, context) {
      context.editor.send('save');
    }
  }

  var PersistencePackage = {
    name: 'Persistence',
    configure (config) {
      config.addCommand('save', SaveCommand, {
        commandGroup: 'persistence'
      });
      config.addIcon('save', { 'fontawesome': 'fa-save' });
      config.addLabel('save', 'Save Document');
      // TODO: enable this once we have global key handling in place
      // config.addKeyboardShortcut('CommandOrControl+S', { command: 'save' })
    }
  }

  class EditXRefTool extends ToggleTool {
    render ($$) {
      const targets = this._getAvailableTargets();

      let el = $$('div').addClass('sc-edit-xref-tool');
      // ATTENTION the targets are not models or nodes, but entries
      // created by xrefHelpers
      // TODO: use something more idiomatic
      for (let entry of targets) {
        const target = entry.node;
        if (!target) continue
        const selected = entry.selected;
        let targetPreviewEl = this._renderOption($$, target, selected);
        targetPreviewEl.on('click', this._toggleTarget.bind(this, target.id), this);
        el.append(targetPreviewEl);
      }
      return el
    }

    _renderOption ($$, target, selected) {
      let optionEl = $$('div').addClass('se-option').append(
        renderNode($$, this, target, {
          mode: PREVIEW_MODE
        })
      );
      if (selected) {
        optionEl.addClass('sm-selected');
      }
      return optionEl
    }

    _getNode () {
      let doc = this.context.editorSession.getDocument();
      let id = this.props.commandState.nodeId;
      return doc.get(id)
    }

    _getAvailableTargets () {
      let node = this._getNode();
      return this.context.api._getAvailableXrefTargets(node)
    }

    _toggleTarget (targetNodeId, e) {
      // Make sure we don't follow external links
      e.preventDefault();
      e.stopPropagation();
      let node = this._getNode();
      let targets = this.context.api._toggleXrefTarget(node, targetNodeId);
      this.setState({
        targets
      });
    }
  }

  class EditExtLinkTool extends ToggleTool {
    render ($$) {
      let Input = this.getComponent('input');
      let Button$$1 = this.getComponent('button');
      let commandState = this.props.commandState;
      let el = $$('div').addClass('sc-edit-external-link-tool');

      // GUARD: Return if tool is disabled
      if (commandState.disabled) {
        console.warn('Tried to render EditLinkTool while disabled.');
        return el
      }

      let urlPath = this._getUrlPath();

      el.append(
        $$(Input, {
          type: 'url',
          path: urlPath,
          placeholder: 'Paste or type a link url'
        // TODO: this component has always the same structure and should preserve all elements, event without ref
        }).ref('input'),
        $$(Button$$1, {
          icon: 'open-link',
          theme: this.props.theme
        }).addClass('sm-open')
          .attr('title', this.getLabel('open-link'))
          .on('click', this._openLink)
      );
      return el
    }

    _getNodeId () {
      return this.props.commandState.nodeId
    }

    _getUrlPath () {
      const nodeId = this._getNodeId();
      return [nodeId, 'href']
    }

    _getDocument () {
      return this.context.editorSession.getDocument()
    }

    _openLink () {
      let doc = this._getDocument();
      let url = doc.get(this._getUrlPath());
      // FIXME: this is not the way how it should be done
      // instead we should send up an action 'open-url'
      // and let the ApplicationChrome do it.
      window.open(url, '_blank');
    }
  }

  class TableEditingAPI {
    constructor (editorSession) {
      this.editorSession = editorSession;
    }

    isTableSelected () {
      let sel = this._getSelection();
      return (sel && !sel.isNull() && sel.customType === 'table')
    }

    deleteSelection () {
      if (!this.isTableSelected()) throw new Error('Table selection required')
      let selData = this._getSelectionData();
      let { tableId, startRow, endRow, startCol, endCol } = selData;
      this.editorSession.transaction(tx => {
        // Note: the selection remains the same
        this._clearValues(tx.get(tableId), startRow, startCol, endRow, endCol);
      }, { action: 'deleteSelection' });
    }

    copySelection () {
      if (!this.isTableSelected()) throw new Error('Table selection required')

      // create a snippet with a table containing only the selected range
      let selData = this._getSelectionData();
      let { table, startRow, endRow, startCol, endCol } = selData;
      let doc = this._getDocument();
      let matrix = getRangeFromMatrix(table.getCellMatrix(), startRow, startCol, endRow, endCol, true);
      let snippet = doc.createSnippet();
      let tableData = { type: 'table', rows: [] };
      for (let row of matrix) {
        let rowData = { type: 'table-row', cells: [] };
        for (let cell of row) {
          let ids = substance.documentHelpers.copyNode(cell).map(_node => snippet.create(_node).id);
          let cellId = ids[0];
          console.assert(cellId, 'cellId should not be nil');
          rowData.cells.push(ids[0]);
        }
        tableData.rows.push(snippet.create(rowData).id);
      }
      let tableCopy = snippet.create(tableData);
      snippet.getContainer().append(tableCopy.id);
      return snippet
    }

    cut () {
      let snippet = this.copySelection();
      this.deleteSelection();
      return snippet
    }

    paste (content, options) {
      if (!this.isTableSelected()) throw new Error('Table selection required')

      // TODO: implement paste for tables
      let snippet = content.get(substance.documentHelpers.SNIPPET_ID);
      if (!snippet) return false
      let first = snippet.getNodeAt(0);
      if (first.type !== 'table') return false
      return this._pasteTable(first)
    }

    _pasteTable (copy) {
      // TODO: extend dimension if necessary
      // and the assign cell attributes and content
      // ATTENTION: make sure that col/rowspans do not extend the table dims
      let [nrows, ncols] = copy.getDimensions();
      let selData = this._getSelectionData();
      let { tableId, startRow, startCol } = selData;
      let N = startRow + nrows;
      let M = startCol + ncols;
      // make the table larger if necessary
      this._ensureSize(tableId, N, M);

      this.editorSession.transaction(tx => {
        let table = tx.get(tableId);
        let cellMatrix = table.getCellMatrix();
        let copyCellMatrix = copy.getCellMatrix();
        for (let rowIdx = 0; rowIdx < nrows; rowIdx++) {
          for (let colIdx = 0; colIdx < ncols; colIdx++) {
            let copyCell = copyCellMatrix[rowIdx][colIdx];
            let cell = cellMatrix[startRow + rowIdx][startCol + colIdx];
            // TODO: copy annotations too
            let data = copyCell.toJSON();
            delete data.id;
            delete data.type;
            cell.assign(data);
          }
        }
      }, { action: 'paste' });

      return true
    }

    insertRows (mode, count) {
      if (!this.isTableSelected()) return

      let selData = this._getSelectionData();
      let tableId = selData.tableId;
      let pos = mode === 'below' ? selData.endRow + 1 : selData.startRow;
      this.editorSession.transaction(tx => {
        this._createRowsAt(tx.get(tableId), pos, count);
      }, { action: 'insertRows', pos, count });
    }

    insertCols (mode, count) {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      let tableId = selData.tableId;
      let pos = mode === 'right' ? selData.endCol + 1 : selData.startCol;
      this.editorSession.transaction(tx => {
        this._createColumnsAt(tx.get(tableId), pos, count);
      }, { action: 'insertCols', pos, count });
    }

    deleteRows () {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      let tableId = selData.tableId;
      let pos = selData.startRow;
      let count = selData.nrows;
      this.editorSession.transaction(tx => {
        this._deleteRows(tx.get(tableId), pos, count);
        tx.selection = null;
      }, { action: 'deleteRows', pos, count });
    }

    deleteCols () {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      let tableId = selData.tableId;
      let pos = selData.startCol;
      let count = selData.ncols;
      this.editorSession.transaction(tx => {
        this._deleteCols(tx.get(tableId), pos, pos + count - 1);
        tx.selection = null;
      }, { action: 'deleteCols', pos, count });
    }

    merge () {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      // TODO: make sure that the selection allows to do that
      const tableId = selData.tableId;
      let table = this._getDocument().get(tableId);
      let { startRow, endRow, startCol, endCol } = selData;
      let bigOne = table.getCell(startRow, startCol);
      // compute the span by walking all non-shadowed cells
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startCol; j <= endCol; j++) {
          let cell = table.getCell(i, j);
          if (cell.shadowed) continue
          let rowspan = cell.rowspan;
          let colspan = cell.colspan;
          if (rowspan > 1) {
            endRow = Math.max(endRow, i + rowspan - 1);
          }
          if (colspan > 1) {
            endCol = Math.max(endCol, j + colspan - 1);
          }
        }
      }
      // Note: spans should be >= 1, i.e. rowspan=1 means no spanning
      let rowspan = endRow - startRow + 1;
      let colspan = endCol - startCol + 1;
      if (bigOne.rowspan !== rowspan || bigOne.colspan !== colspan) {
        this.editorSession.transaction(tx => {
          let cell = tx.get(bigOne.id);
          cell.rowspan = rowspan;
          cell.colspan = colspan;
          tx.selection = createTableSelection(tableId, {
            anchorCellId: cell.id,
            focusCellId: cell.id
          }, selData.surfaceId);
        }, { action: 'mergeCells' });
      }
    }

    unmerge () {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      // TODO: make sure that the selection allows to do that
      const tableId = selData.tableId;
      let table = this._getDocument().get(tableId);
      let [N, M] = table.getDimensions();
      let { startRow, startCol, endRow, endCol } = selData;
      let cellIds = [];
      // index of focus cell after unmerging
      let newFocusRow = 0;
      let newFocusCol = 0;
      const _updateFocus = (row, col) => {
        newFocusRow = Math.min(N, Math.max(row, newFocusRow));
        newFocusCol = Math.min(M, Math.max(col, newFocusCol));
      };
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startCol; j <= endCol; j++) {
          let cell = table.getCell(i, j);
          // TODO: do not umerge shadowed cells
          let rowspan = cell.rowspan;
          let colspan = cell.colspan;
          if (rowspan > 1 || colspan > 1) {
            _updateFocus(i + rowspan - 1, j + colspan - 1);
            cellIds.push(cell.id);
          }
        }
      }
      // TODO: selData is a little bit confusing
      // at other places selData is used for the 'data' part of the CustomSelection
      let newAnchorCell = selData.anchorCell;
      let newFocusCell = table.getCell(newFocusRow, newFocusCol);
      if (cellIds.length > 0) {
        this.editorSession.transaction(tx => {
          for (let id of cellIds) {
            let cell = tx.get(id);
            cell.rowspan = 1;
            cell.colspan = 1;
          }
          tx.selection = createTableSelection(tableId, {
            anchorCellId: newAnchorCell.id,
            focusCellId: newFocusCell.id
          });
        }, { action: 'unmergeCells' });
      }
    }

    toggleHeading (cellIds) {
      if (cellIds && cellIds.length > 0) {
        this.editorSession.transaction(tx => {
          for (let id of cellIds) {
            let cell = tx.get(id);
            cell.heading = !cell.heading;
          }
        }, { action: 'toggleHeading' });
      }
    }

    insertText (newVal) {
      if (!this.isTableSelected()) return
      let selData = this._getSelectionData();
      let cellId = selData.anchorCell.id;
      this.editorSession.transaction(tx => {
        let cell = tx.get(cellId);
        let path = cell.getPath();
        cell.setText(newVal);
        tx.setSelection({
          type: 'property',
          path,
          startOffset: newVal.length,
          surfaceId: selData.surfaceId + '/' + substance.getKeyForPath(path)
        });
      }, { action: 'insertText' });
    }

    insertSoftBreak () {
      this.editorSession.transaction(tx => {
        tx.insertText('\n');
      }, { action: 'soft-break' });
    }

    _getDocument () {
      return this.editorSession.getDocument()
    }

    _getSelection () {
      return this.editorSession.getSelection()
    }

    _getSelectionData () {
      let doc = this._getDocument();
      let sel = this._getSelection();
      if (sel && sel.customType === 'table') {
        let nodeId = sel.nodeId;
        let { anchorCellId, focusCellId } = sel.data;
        let table = doc.get(nodeId);
        let anchorCell = doc.get(anchorCellId);
        let focusCell = doc.get(focusCellId);
        let { startRow, startCol, endRow, endCol } = getCellRange(table, anchorCellId, focusCellId);
        return {
          table,
          tableId: table.id,
          anchorCell,
          focusCell,
          startRow,
          endRow,
          startCol,
          endCol,
          nrows: endRow - startRow + 1,
          ncols: endCol - startCol + 1,
          surfaceId: sel.surfaceId
        }
      }
    }

    _getTable (doc, sel) {
      if (!sel || sel.isNull() || sel.customType === 'table') {
        return null
      }
    }

    _createRowsAt (table, rowIdx, n) {
      let doc = table.getDocument();
      let M = table.getColumnCount();
      const path = [table.id, 'rows'];
      let rowIds = Table.getRowsTemplate(n, M).map(data => substance.documentHelpers.createNodeFromJson(doc, data).id);
      for (let i = 0; i < n; i++) {
        substance.documentHelpers.insertAt(doc, path, rowIdx + i, rowIds[i]);
      }
    }

    _deleteRows (table, startRow, endRow) {
      let doc = table.getDocument();
      const path = [table.id, 'rows'];
      for (let rowIdx = endRow; rowIdx >= startRow; rowIdx--) {
        let id = substance.documentHelpers.removeAt(doc, path, rowIdx);
        substance.documentHelpers.deepDeleteNode(table.getDocument(), id);
      }
    }

    _deleteCols (table, startCol, endCol) {
      let doc = table.getDocument();
      let N = table.getRowCount();
      for (let rowIdx = N - 1; rowIdx >= 0; rowIdx--) {
        let row = table.getRowAt(rowIdx);
        let path = [row.id, 'cells'];
        for (let colIdx = endCol; colIdx >= startCol; colIdx--) {
          let id = substance.documentHelpers.removeAt(doc, path, colIdx);
          substance.documentHelpers.deepDeleteNode(table.getDocument(), id);
        }
      }
    }

    _createColumnsAt (table, colIdx, n) {
      let doc = table.getDocument();
      let rows = table.resolve('rows');
      for (let row of rows) {
        let path = [row.id, 'cells'];
        let cellIds = Table.getCellsTemplate(n).map(data => substance.documentHelpers.createNodeFromJson(doc, data).id);
        for (let i = 0; i < n; i++) {
          substance.documentHelpers.insertAt(doc, path, colIdx + i, cellIds[i]);
        }
      }
    }

    _clearValues (table, startRow, startCol, endRow, endCol) {
      let doc = table.getDocument();
      for (let rowIdx = startRow; rowIdx <= endRow; rowIdx++) {
        for (let colIdx = startCol; colIdx <= endCol; colIdx++) {
          let cell = table.getCell(rowIdx, colIdx);
          substance.documentHelpers.deleteTextRange(doc, { path: cell.getPath(), offset: 0 });
        }
      }
    }

    _ensureSize (tableId, nrows, ncols) {
      let table = this._getDocument().get(tableId);
      let [_nrows, _ncols] = table.getDimensions();
      if (_ncols < ncols) {
        let pos = _ncols;
        let count = ncols - _ncols;
        this.editorSession.transaction(tx => {
          this._createColumnsAt(tx.get(tableId), pos, count);
        }, { action: 'insertCols', pos, count });
      }
      if (_nrows < nrows) {
        let pos = _nrows;
        let count = nrows - _nrows;
        this.editorSession.transaction(tx => {
          this._createRowsAt(tx.get(tableId), pos, count);
        }, { action: 'insertRows', pos, count });
      }
    }
  }

  function importFigures (tx, sel, files, paths) {
    if (files.length === 0) return

    let containerPath = sel.containerPath;
    let figures = files.map((file, idx) => {
      let href = paths[idx];
      let mimeType = file.type;
      let panelTemplate = FigurePanel.getTemplate();
      panelTemplate.content.href = href;
      panelTemplate.content.mimeType = mimeType;
      let figure = substance.documentHelpers.createNodeFromJson(tx, {
        type: 'figure',
        panels: [ panelTemplate ]
      });
      // Note: this is necessary because tx.insertBlockNode()
      // selects the inserted node
      // TODO: maybe we should change the behavior of tx.insertBlockNode()
      // so that it is easier to insert multiple nodes in a row
      if (idx !== 0) {
        tx.break();
      }
      tx.insertBlockNode(figure);
      return figure
    });
    substance.selectionHelpers.selectNode(tx, substance.last(figures).id, containerPath);
  }

  function journalArticleRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }

    // We render an annotated article title here:
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '.'
      );
    }

    if (entity.editors.length > 0) {
      fragments = fragments.concat(
        ' ',
        _renderAuthors($$, entity.editors, entityDb),
        '.'
      );
    }
    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(entity.containerTitle),
        '.'
      );
    }

    let date = _renderDate($$, entity.year, entity.month, entity.day, 'short');
    if (date) {
      fragments.push(' ', date, ';');
    }

    if (entity.volume) {
      fragments.push(entity.volume);
    }
    if (entity.issue) {
      fragments.push('(', entity.issue, ')');
    }

    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(':', contentLocation, '.');
    } else {
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    if (entity.pmid) {
      fragments.push(' PMID ', entity.pmid);
    }
    return fragments
  }

  function bookRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    } else if (entity.editors.length > 0) {
      let editorLabel = entity.editors.length > 1 ? 'eds' : 'ed';
      fragments = fragments.concat(
        _renderAuthors($$, entity.editors, entityDb),
        ', ',
        editorLabel,
        '.'
      );
    }
    if (entity.translators.length) {
      fragments = fragments.concat(
        ' (',
        _renderAuthors($$, entity.translators, entityDb),
        ', trans).'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        $$('i').append(entity.title),
        '.'
      );
    }
    if (entity.volume) {
      if (/^\d+$/.test(entity.volume)) {
        fragments.push(' Vol ', entity.volume, '.');
      } else {
        fragments.push(' ', entity.volume, '.');
      }
    }
    if (entity.edition) {
      fragments.push(' ', entity.edition, '.');
    }
    if (entity.editors.length > 0 && entity.authors.length > 0) {
      let editorLabel = entity.editors.length > 1 ? 'eds' : 'ed';
      fragments = fragments.concat(
        ' (',
        _renderAuthors($$, entity.editors, entityDb),
        ', ',
        editorLabel,
        ').'
      );
    }

    fragments.push(_renderPublisherPlace($$, entity.publisherLoc, entity.publisherName));

    if (entity.series) {
      fragments.push(' (', entity.series, ')');
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
    }
    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(':', contentLocation, '.');
    } else {
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }
    return fragments
  }

  function chapterRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.translators.length) {
      fragments = fragments.concat(
        ' (',
        _renderAuthors($$, entity.translators, entityDb),
        ', trans).'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    fragments = fragments.concat('In: ');
    if (entity.editors.length > 0) {
      let editorLabel = entity.editors.length > 1 ? 'eds' : 'ed';
      fragments = fragments.concat(
        ' ',
        _renderAuthors($$, entity.editors, entityDb),
        ', ',
        editorLabel,
        '.'
      );
    }
    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(
          entity.containerTitle
        ),
        '.'
      );
    }
    if (entity.volume) {
      if (/^\d+$/.test(entity.volume)) {
        fragments.push(' ', entity.volume, '.');
      } else {
        fragments.push(' Vol ', entity.volume, '.');
      }
    }
    if (entity.edition) {
      fragments.push(' ', entity.edition, '.');
    }

    fragments.push(_renderPublisherPlace($$, entity.publisherLoc, entity.publisherName));

    if (entity.series) {
      fragments.push(' (', entity.series, ')');
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
    }
    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(':', contentLocation, '.');
    } else {
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }
    return fragments
  }

  function patentRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.inventors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.inventors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.assignee) {
      fragments.push(' ', entity.assignee, ',');
    }
    let date = _renderDate($$, entity.year, entity.month, entity.day, 'short');
    if (date) {
      fragments.push(' ', date, ';');
    }
    if (entity.patentNumber) {
      fragments.push(' ', entity.patentNumber);
    }
    if (entity.patentCountry) {
      fragments.push(' (', entity.patentCountry, ').');
    }
    return fragments
  }

  function articleRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    // We render an annotated article title here:
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '.'
      );
    }

    if (entity.editors.length > 0) {
      fragments = fragments.concat(
        ' ',
        _renderAuthors($$, entity.editors, entityDb),
        '.'
      );
    }
    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(entity.containerTitle),
        '.'
      );
    }

    let date = _renderDate($$, entity.year, entity.month, entity.day, 'short');
    if (date) {
      fragments.push(' ', date, ';');
    }

    if (entity.issue) {
      fragments.push('(', entity.issue, ')');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    if (entity.pmid) {
      fragments.push(' PMID ', entity.pmid);
    }
    return fragments
  }

  function dataPublicationRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(entity.containerTitle),
        '.'
      );
    }
    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
      fragments.push('.');
    }
    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }
    if (entity.arkId) {
      fragments.push(' ', entity.arkId);
    }
    if (entity.archiveId) {
      fragments.push(' ', entity.archiveId);
    }
    if (entity.accessionId) {
      fragments.push(' ', entity.accessionId);
    }
    return fragments
  }

  function magazineArticleRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(entity.containerTitle),
        ','
      );
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
    }

    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(':', contentLocation, '.');
    } else {
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    return fragments
  }

  function newspaperArticleRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.containerTitle) {
      fragments.push(
        ' ',
        $$('i').append(entity.containerTitle),
        ','
      );
      if (entity.edition) {
        fragments.push(
          ' ',
          $$('i').append(entity.edition),
          ','
        );
      }
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
    }

    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(':', contentLocation);
    }
    if (entity.partTitle) {
      fragments.push(' (', entity.partTitle, ')');
    }
    fragments.push('.');

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    return fragments
  }

  function reportRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];
    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '. '
      );
    }

    if (entity.sponsors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.sponsors, entityDb),
        ', sponsors. '
      );
    }

    if (entity.title) {
      fragments.push(
        $$('i').append(entity.title),
        '.'
      );
    }

    fragments.push(_renderPublisherPlace($$, entity.publisherLoc, entity.publisherName));

    if (entity.series) {
      fragments.push(' (', entity.series, ')');
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    return fragments
  }

  function conferencePaperRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.containerTitle) {
      fragments.push(' ', $$('i').append(entity.containerTitle), '.');
    }

    if (entity.confName && entity.confLoc) {
      fragments.push(' ', entity.confName, '; ', entity.confLoc, '.');
    } else if (entity.confName) {
      fragments.push(' ', entity.confName, '.');
    } else if (entity.confLoc) {
      fragments.push(' ', entity.confLoc, '.');
    }

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
    }

    let contentLocation = _renderLocation($$, entity.fpage, entity.lpage, entity.pageRange, entity.elocationId);
    if (contentLocation) {
      fragments.push(', ', contentLocation, '.');
    } else {
      fragments.push('.');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }
    return fragments
  }

  function softwareRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        ' ',
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '.'
      );
    }
    if (entity.version) {
      fragments.push(' Version ', entity.version);
    }
    fragments.push('.');

    fragments.push(_renderPublisherPlace($$, entity.publisherLoc, entity.publisherName));

    let date = _renderDate($$, entity.year, entity.month, entity.day, 'short');
    if (date) {
      fragments.push(' ', date, ';');
    }

    if (entity.doi) {
      fragments.push(
        ' ',
        _renderDOI($$, entity.doi)
      );
    }

    return fragments
  }

  function thesisRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    fragments.push(_renderPublisherPlace($$, entity.publisherLoc, entity.publisherName));

    if (entity.year) {
      fragments.push(' ', entity.year);
      if (entity.month) {
        fragments.push(' ', _renderMonth(entity.month, 'short'));
      }
      fragments.push('.');
    }

    return fragments
  }

  function webpageRenderer ($$, entityId, entityDb, exporter) {
    let entity = entityDb.get(entityId);
    let fragments = [];

    if (entity.authors.length > 0) {
      fragments = fragments.concat(
        _renderAuthors($$, entity.authors, entityDb),
        '.'
      );
    }
    if (entity.title) {
      fragments.push(
        ' ',
        ...exporter.annotatedText([entity.id, 'title'], entityDb, $$),
        '. '
      );
    }

    if (entity.publisherLoc) {
      fragments.push(' ', entity.publisherLoc);
    }

    if (entity.uri) {
      fragments.push(
        ' ',
        $$('a').attr({
          href: entity.uri,
          target: '_blank'
        }).append(
          entity.uri
        )
      );
    }

    if (entity.year) {
      let dateFormatted = _renderDate($$, entity.year, entity.month, entity.day, 'long');
      fragments.push('. Accessed ', dateFormatted, '.');
    }

    return fragments
  }

  /* This is used for authors and editors */
  function personRenderer ($$, entityId, entityDb, options = {}) {
    let { prefix, suffix, givenNames, surname } = entityDb.get(entityId);
    if (options.short) {
      givenNames = _getInitials(givenNames);
    }
    let result = [];
    if (prefix) {
      result.push(prefix, ' ');
    }
    result.push(
      givenNames,
      ' ',
      surname
    );
    if (suffix) {
      result.push(' (', suffix, ')');
    }
    return result
  }

  function groupRenderer ($$, entityId, entityDb) {
    let { name } = entityDb.get(entityId);
    return [ name ]
  }

  // function personRenderer($$, entityId, entityDb, options = {}) {
  //   let { prefix, suffix, givenNames, surname } = entityDb.get(entityId)
  function refContribRenderer ($$, entityId, entityDb, options = {}) {
    let { givenNames, name } = entityDb.get(entityId);

    let result = [
      name
    ];

    if (givenNames) {
      if (options.short) {
        givenNames = _getInitials(givenNames);
      }

      result.push(
        ' ',
        givenNames
      );
    }
    return result
  }

  function organisationRenderer ($$, entityId, entityDb, options = {}) {
    let org = entityDb.get(entityId);
    return org.render(options)
  }

  function funderRenderer ($$, entityId, entityDb, options = {}) {
    let { awardId, institution } = entityDb.get(entityId);
    let result = [ institution ];
    if (!options.short) {
      if (awardId) {
        result.push(', ', awardId);
      }
    }
    return result
  }

  function keywordRenderer ($$, entityId, entityDb, options = {}) {
    let { category, name } = entityDb.get(entityId);
    let result = [ name ];
    if (!options.short) {
      if (category) {
        result.push(', ', category);
      }
    }
    return result
  }

  function subjectRenderer ($$, entityId, entityDb, options = {}) {
    let { category, name } = entityDb.get(entityId);
    let result = [ name ];
    if (!options.short) {
      if (category) {
        result.push(', ', category);
      }
    }
    return result
  }

  /*
    Exports
  */
  var entityRenderers = {
    'article-ref': _delegate(articleRenderer),
    'person': _delegate(personRenderer),
    'group': _delegate(groupRenderer),
    'book-ref': _delegate(bookRenderer),
    'chapter-ref': _delegate(chapterRenderer),
    'journal-article-ref': _delegate(journalArticleRenderer),
    'conference-paper-ref': _delegate(conferencePaperRenderer),
    'report-ref': _delegate(reportRenderer),
    'organisation': _delegate(organisationRenderer),
    'funder': _delegate(funderRenderer),
    'data-publication-ref': _delegate(dataPublicationRenderer),
    'magazine-article-ref': _delegate(magazineArticleRenderer),
    'newspaper-article-ref': _delegate(newspaperArticleRenderer),
    'software-ref': _delegate(softwareRenderer),
    'thesis-ref': _delegate(thesisRenderer),
    'webpage-ref': _delegate(webpageRenderer),
    'keyword': _delegate(keywordRenderer),
    'ref-contrib': _delegate(refContribRenderer),
    'patent-ref': _delegate(patentRenderer),
    'subject': _delegate(subjectRenderer)
  }

  /*
    Helpers
  */
  function _renderAuthors ($$, authors, entityDb) {
    let fragments = [];
    authors.forEach((refContribId, i) => {
      fragments = fragments.concat(
        refContribRenderer($$, refContribId, entityDb, { short: true })
      );
      if (i < authors.length - 1) {
        fragments.push(', ');
      }
    });
    return fragments
  }

  function _renderDate ($$, year, month, day, format) {
    if (year) {
      if (month) {
        if (day) {
          return year + ' ' + _renderMonth(month, format) + ' ' + day
        } else {
          return year + ' ' + _renderMonth(month, format)
        }
      } else {
        return year
      }
    }
  }

  function _renderMonth (month, format) {
    let monthNames;
    if (format === 'long') {
      monthNames = [null, 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    } else {
      monthNames = [null, 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    }
    if (month) {
      return monthNames[month] || month
    }
  }

  function _renderDOI ($$, doi) {
    return $$('a').attr({
      href: `https://doi.org/${doi}`,
      target: '_blank'
    }).append(
      'https://doi.org/',
      doi
    )
  }

  function _renderLocation ($$, fpage, lpage, pageRange, elocationId) {
    if (pageRange) {
      // Give up to three page ranges, then use passim for more, see
      // https://www.ncbi.nlm.nih.gov/books/NBK7282/box/A33679/?report=objectonly
      let parts = pageRange.split(',');
      if (parts.length > 3) {
        return parts.slice(0, 3).join(',') + ' passim'
      } else {
        return pageRange
      }
    } else if (fpage) {
      if (lpage) {
        // Do not repeat page numbers unless they are followed by a letter
        // e.g. 211-218 => 211-8 but 211A-218A stays
        if (fpage.length === lpage.length && /^\d+$/.test(fpage) && /^\d+$/.test(lpage)) {
          let i;
          for (i = 0; i < fpage.length; i++) {
            if (fpage[i] !== lpage[i]) break
          }
          return fpage + '-' + lpage.substring(i)
        }
        return fpage + '-' + lpage
      } else {
        return fpage
      }
    } else if (elocationId) {
      return elocationId
    }
  }

  function _renderPublisherPlace ($$, place, publisher) {
    if (place && publisher) {
      return ' ' + place + ': ' + publisher + '; '
    } else if (place) {
      return ' ' + place + '; '
    } else if (publisher) {
      return ' ' + publisher + '; '
    } else {
      return ''
    }
  }

  function _getInitials (givenNames) {
    return givenNames.split(' ').map(part => {
      return part[0] ? part[0].toUpperCase() : ''
    }).join('')
  }

  function _delegate (fn) {
    return function (entityId, db, exporter, options) {
      let el = _createElement();
      let $$ = el.createElement.bind(el);
      let fragments = fn($$, entityId, db, exporter, options);
      el.append(fragments);
      return el.innerHTML
    }
  }

  function _createElement () {
    return substance.DefaultDOMElement.parseSnippet('<div>', 'html')
  }

  // TODO: rethink this.
  // The fact that it needs an exporter makes it not very useful.
  // In general I think that these renderers should not depend on an HTML exporter
  function renderEntity (entity, exporter, options = {}) {
    if (entity) {
      const type = entity.type;
      let renderer = entityRenderers[type];
      if (renderer) {
        let doc = entity.getDocument();
        return renderer(entity.id, doc, exporter, options)
      } else {
        console.error(`No renderer available for type '${type}'`);
      }
    }
    return ''
  }

  class ArticleAPI {
    constructor (editorSession, archive, config, articleSession, contextProvider) {
      this.editorSession = editorSession;
      this.config = config;
      this.archive = archive;
      this._contextProvider = contextProvider;
      this._document = editorSession.getDocument();
      // TODO: do we really need this?
      this._articleSession = articleSession;
      // TODO: rethink this
      this._tableApi = new TableEditingAPI(editorSession);
    }

    getDocument () {
      return this._document
    }

    getEditorSession () {
      return this.editorSession
    }

    getSelection () {
      return this.editorSession.getSelection()
    }

    /**
     * Provides a sub-api for editing tables.
     */
    getTableAPI () {
      return this._tableApi
    }

    // TODO: how are we using this?
    // This could be part of an Editor API
    copy () {
      if (this._tableApi.isTableSelected()) {
        return this._tableApi.copySelection()
      } else {
        const sel = this.getSelection();
        const doc = this.getDocument();
        if (sel && !sel.isNull() && !sel.isCollapsed()) {
          return substance.copySelection(doc, sel)
        }
      }
    }

    cut () {
      if (this._tableApi.isTableSelected()) {
        return this._tableApi.cut()
      } else {
        const sel = this.getSelection();
        if (sel && !sel.isNull() && !sel.isCollapsed()) {
          let snippet = this.copy();
          this.deleteSelection();
          return snippet
        }
      }
    }

    deleteSelection (options) {
      const sel = this.getSelection();
      if (sel && !sel.isNull() && !sel.isCollapsed()) {
        this.editorSession.transaction(tx => {
          tx.deleteSelection(options);
        }, { action: 'deleteSelection' });
      }
    }

    insertText (text) {
      if (this._tableApi.isTableSelected()) {
        this._tableApi.insertText(text);
      } else {
        const sel = this.getSelection();
        if (sel && !sel.isNull()) {
          this.editorSession.transaction(tx => {
            tx.insertText(text);
          }, { action: 'insertText' });
        }
      }
    }

    paste (content, options) {
      if (this._tableApi.isTableSelected()) {
        return this._tableApi.paste(content, options)
      } else {
        this.editorSession.transaction(tx => {
          tx.paste(content, options);
        }, { action: 'paste' });
        return true
      }
    }

    // EXPERIMENTAL: in the MetadataEditor we want to be able to select a full card
    // I do not want to introduce a 'card' selection as this is not an internal concept
    // and instead opting for 'model' selection.
    // TODO: could we use NodeSelection instead?
    selectModel (nodeId) {
      this._setSelection(this._createModelSelection(nodeId));
    }

    selectNode (nodeId) {
      const editorSession = this.editorSession;
      const doc = editorSession.getDocument();
      const node = doc.get(nodeId);
      if (node) {
        const sel = editorSession.getSelection();
        const containerPath = this._getContainerPathForNode(node);
        const surface = editorSession.surfaceManager._getSurfaceForProperty(containerPath);
        const surfaceId = surface ? surface.getId() : (sel ? sel.surfaceId : null);
        editorSession.setSelection({
          type: 'node',
          nodeId: node.id,
          containerPath,
          // TODO: we need a way to look up surfaceIds by path
          surfaceId
        });
      }
    }

    // EXPERIMENTAL need to figure out if we really need this
    // This is used by ManyRelationshipComponent (which is kind of weird)
    selectValue (path) {
      this._setSelection(this._createValueSelection(path));
    }

    selectFirstRequiredPropertyOfMetadataCard (nodeId) {
      this._setSelection(this._selectFirstRequiredPropertyOfMetadataCard(nodeId));
    }

    _appendChild (collectionPath, data) {
      this.editorSession.transaction(tx => {
        let node = tx.create(data);
        substance.documentHelpers.append(tx, collectionPath, node.id);
      });
    }

    _deleteChild (collectionPath, child, txHook) {
      this.editorSession.transaction(tx => {
        substance.documentHelpers.remove(tx, collectionPath, child.id);
        substance.documentHelpers.deepDeleteNode(tx, child);
        if (txHook) {
          txHook(tx);
        }
      });
    }

    _getAppState () {
      return this._getContext().appState
    }

    _getContext () {
      return this._contextProvider.getContext()
    }

    // TODO: we need a better way to update settings
    _loadSettings (settings) {
      let appState = this._getContext().appState;
      appState.settings.load(settings);
      appState._setDirty('settings');
      appState.propagateUpdates();
    }

    _moveChild (collectionPath, child, shift, txHook) {
      this.editorSession.transaction(tx => {
        let ids = tx.get(collectionPath);
        let pos = ids.indexOf(child.id);
        if (pos === -1) return
        substance.documentHelpers.removeAt(tx, collectionPath, pos);
        substance.documentHelpers.insertAt(tx, collectionPath, pos + shift, child.id);
        if (txHook) {
          txHook(tx);
        }
      });
    }

    _replaceFile (hrefPath, file) {
      const articleSession = this.editorSession;
      const path = this.archive.addAsset(file);
      articleSession.transaction(tx => {
        tx.set(hrefPath, path);
      });
    }

    _addReference (refData) {
      this._addReferences([refData]);
    }

    _addReferences (refsData) {
      this.editorSession.transaction(tx => {
        let refNodes = refsData.map(refData => substance.documentHelpers.createNodeFromJson(tx, refData));
        refNodes.forEach(ref => {
          substance.documentHelpers.append(tx, ['article', 'references'], ref.id);
        });
        if (refNodes.length > 0) {
          let newSelection = this._selectFirstRequiredPropertyOfMetadataCard(refNodes[0]);
          tx.setSelection(newSelection);
        }
      });
    }

    // This method is used to cleanup xref targets
    // during footnote or reference removing
    _removeCorrespondingXrefs (tx, node) {
      let manager;
      if (INTERNAL_BIBR_TYPES.indexOf(node.type) > -1) {
        manager = this._articleSession.getReferenceManager();
      } else if (node.type === 'footnote') {
        manager = this._articleSession.getFootnoteManager();
      } else {
        return
      }
      manager._getXrefs().forEach(xref => {
        const index = xref.refTargets.indexOf(node.id);
        if (index > -1) {
          tx.update([xref.id, 'refTargets'], { type: 'delete', pos: index });
        }
      });
    }

    _createModelSelection (modelId) {
      return {
        type: 'custom',
        customType: 'model',
        nodeId: modelId,
        data: {
          modelId
        }
      }
    }

    _createValueSelection (path) {
      return {
        type: 'custom',
        customType: 'value',
        nodeId: path[0],
        data: {
          path,
          propertyName: path[1]
        },
        surfaceId: path[0]
      }
    }

    // TODO: how could we make this extensible via plugins?
    _getAvailableXrefTargets (xref) {
      let refType = xref.refType;
      let manager;
      switch (refType) {
        case BlockFormula.refType: {
          manager = this._articleSession.getFormulaManager();
          break
        }
        case 'fig': {
          manager = this._articleSession.getFigureManager();
          break
        }
        case 'fn': {
          // FIXME: bring back table-footnotes
          // EXPERIMENTAL:
          // the above mechanism does not work for table-footnotes
          // there we need access to the current TableFigure and get its TableFootnoteManager
          let tableFigure = findParentByType(xref, 'table-figure');
          if (tableFigure) {
            manager = tableFigure.getFootnoteManager();
          } else {
            manager = this._articleSession.getFootnoteManager();
          }
          break
        }
        case 'table-fn': {
          let tableFigure = findParentByType(xref, 'table-figure');
          if (tableFigure) {
            manager = tableFigure.getFootnoteManager();
          }
          break
        }
        case 'bibr': {
          manager = this._articleSession.getReferenceManager();
          break
        }
        case 'table': {
          manager = this._articleSession.getTableManager();
          break
        }
        case 'file': {
          manager = this._articleSession.getSupplementaryManager();
          break
        }
        default:
          throw new Error('Unsupported xref type: ' + refType)
      }
      if (!manager) return []

      let selectedTargets = xref.resolve('refTargets');
      // retrieve all possible nodes that this
      // xref could potentially point to,
      // so that we can let the user select from a list.
      let availableTargets = manager.getSortedCitables();
      let targets = availableTargets.map(target => {
        // ATTENTION: targets are not just nodes
        // but entries with some information
        return {
          selected: substance.includes(selectedTargets, target),
          node: target,
          id: target.id
        }
      });
      // Determine broken targets (such that don't exist in the document)
      let brokenTargets = substance.without(selectedTargets, ...availableTargets);
      if (brokenTargets.length > 0) {
        targets = targets.concat(brokenTargets.map(id => {
          return { selected: true, id }
        }));
      }
      // Makes the selected targets go to top
      targets = substance.orderBy(targets, ['selected'], ['desc']);
      return targets
    }

    // EXPERIMENTAL
    // this is called by ManyRelationshipComponent and SingleRelationshipComponent to get
    // options for the selection
    // TODO: I am not sure if it is the right approach, trying to generalize this
    // Instead we could use dedicated Components derived from the ones from the kit
    // and use specific API to accomplish this
    _getAvailableOptions (model) {
      // HACK only suppor
      let targetTypes = Array.from(model._targetTypes);
      if (targetTypes.length !== 1) {
        throw new Error('Unsupported relationship. Expected to find one targetType')
      }
      let doc = this.getDocument();
      let targetType = targetTypes[0];
      switch (targetType) {
        case 'funder': {
          return doc.get('metadata').resolve('funders')
        }
        case 'organisation': {
          return doc.get('metadata').resolve('organisations')
        }
        case 'group': {
          return doc.get('metadata').resolve('groups')
        }
        default:
          throw new Error('Unsupported relationship: ' + targetType)
      }
    }

    _toggleRelationship (path, id) {
      this.editorSession.transaction(tx => {
        let ids = tx.get(path);
        let idx = ids.indexOf(id);
        if (idx === -1) {
          tx.update(path, { type: 'insert', pos: ids.length, value: id });
        } else {
          tx.update(path, { type: 'delete', pos: idx, value: id });
        }
        tx.setSelection(this._createValueSelection(path));
      });
    }

    _toggleXrefTarget (xref, targetId) {
      let targetIds = xref.refTargets;
      let index = targetIds.indexOf(targetId);
      if (index >= 0) {
        this.editorSession.transaction(tx => {
          tx.update([xref.id, 'refTargets'], { type: 'delete', pos: index });
        });
      } else {
        this.editorSession.transaction(tx => {
          tx.update([xref.id, 'refTargets'], { type: 'insert', pos: targetIds.length, value: targetId });
        });
      }
    }

    _isFieldRequired (path) {
      // ATTENTION: this API is experimental
      let settings = this._getAppState().settings;
      let valueSettings = settings.getSettingsForValue(path);
      return Boolean(valueSettings['required'])
    }

    _getFirstRequiredPropertyName (node) {
      // NOTE: still not sure if this is the right approach
      // For now, we find the first required text field, otherwise we take the first one
      let schema = node.getSchema();
      let propName = null;
      let firstText = null;
      for (let p of schema) {
        if (p.type === 'text' || p.type === 'string') {
          if (!firstText) {
            firstText = p;
          }
          if (this._isFieldRequired([node.type, p.name])) {
            propName = p.name;
            break
          }
        }
      }
      if (!propName && firstText) {
        propName = firstText.name;
      }
      return propName
    }

    // ATTENTION: this only works for meta-data cards, thus the special naming
    _selectFirstRequiredPropertyOfMetadataCard (node) {
      if (substance.isString(node)) {
        node = this.getDocument().get(node);
      }
      let propName = this._getFirstRequiredPropertyName(node);
      if (propName) {
        let path = [node.id, propName];
        return {
          type: 'property',
          path,
          startOffset: 0,
          // HACK: this does only work within the meta-data view
          surfaceId: `${path.join('.')}`
        }
      } else {
        return this._createModelSelection(node.id)
      }
    }

    _setSelection (sel) {
      this.editorSession.setSelection(sel);
    }

    // TODO: can we improve this?
    // Here we would need a transaction on archive level, creating assets, plus placing them inside the article body.
    _insertFigures (files) {
      const articleSession = this.editorSession;
      let paths = files.map(file => {
        return this.archive.addAsset(file)
      });
      let sel = articleSession.getSelection();
      if (!sel || !sel.containerPath) return
      articleSession.transaction(tx => {
        importFigures(tx, sel, files, paths);
      });
    }

    _insertSupplementaryFile (file, url) {
      const articleSession = this.editorSession;
      if (file) url = this.archive.addAsset(file);
      let sel = articleSession.getSelection();
      articleSession.transaction(tx => {
        let containerPath = sel.containerPath;
        let nodeData = SupplementaryFile.getTemplate();
        nodeData.mimetype = file ? file.type : '';
        nodeData.href = url;
        nodeData.remote = !file;
        let supplementaryFile = substance.documentHelpers.createNodeFromJson(tx, nodeData);
        tx.insertBlockNode(supplementaryFile);
        substance.selectionHelpers.selectNode(tx, supplementaryFile.id, containerPath);
      });
    }

    _replaceSupplementaryFile (file, supplementaryFile) {
      const articleSession = this.editorSession;
      const path = this.archive.addAsset(file);
      articleSession.transaction(tx => {
        const mimeData = file.type.split('/');
        tx.set([supplementaryFile.id, 'mime-subtype'], mimeData[1]);
        tx.set([supplementaryFile.id, 'mimetype'], mimeData[0]);
        tx.set([supplementaryFile.id, 'href'], path);
      });
    }

    _insertInlineGraphic (file) {
      const articleSession = this.editorSession;
      const href = this.archive.addAsset(file);
      const mimeType = file.type;
      const sel = articleSession.getSelection();
      if (!sel) return
      articleSession.transaction(tx => {
        const node = tx.create({
          type: 'inline-graphic',
          mimeType,
          href
        });
        tx.insertInlineNode(node);
        tx.setSelection(node.getSelection());
      });
    }

    _renderEntity (entity, options) {
      let exporter = this.config.getExporter('html');
      return renderEntity(entity, exporter)
    }

    // Internal API where I do not have a better solution yet

    _addFigurePanel (figureId, file) {
      const doc = this.getDocument();
      const figure = doc.get(figureId);
      const pos = figure.getCurrentPanelIndex();
      const href = this.archive.addAsset(file);
      const insertPos = pos + 1;
      // NOTE: with this method we are getting the structure of the active panel
      // to replicate it, currently only for metadata fields
      const panelTemplate = figure.getTemplateFromCurrentPanel();
      this.editorSession.transaction(tx => {
        let template = FigurePanel.getTemplate();
        template.content.href = href;
        template.content.mimeType = file.type;
        Object.assign(template, panelTemplate);
        let node = substance.documentHelpers.createNodeFromJson(tx, template);
        substance.documentHelpers.insertAt(tx, [figure.id, 'panels'], insertPos, node.id);
        tx.set([figure.id, 'state', 'currentPanelIndex'], insertPos);
      });
    }

    _switchFigurePanel (figure, newPanelIndex) {
      const editorSession = this.editorSession;
      let sel = editorSession.getSelection();
      if (!sel.isNodeSelection() || sel.getNodeId() !== figure.id) {
        this.selectNode(figure.id);
      }
      editorSession.updateNodeStates([[figure.id, { currentPanelIndex: newPanelIndex }]], { propagate: true });
    }

    _getContainerPathForNode (node) {
      let last = node.getXpath();
      let prop = last.property;
      let prev = last.prev;
      if (prev && prop) {
        return [prev.id, prop]
      }
    }

    // HACK: determining proper surfaceId in a hard-coded way.
    // Using templates for different node types and view modes,
    // before template rendering computes ids of specified parent nodes.
    _getSurfaceId (node, path, viewName) {
      const tpl = (strings, ...keys) => args => {
        let result = [strings[0]];
        keys.forEach((key, i) => {
          result.push(args[key], strings[i + 1]);
        });
        return result.join('')
      };

      const surfaceIdTypes = {
        'custom-metadata-field': [{
          ids: ['figure'],
          parts: tpl`body/${'figure'}/${'path'}`,
          view: 'manuscript'
        }, {
          ids: [],
          parts: tpl`${'path'}`,
          view: 'metadata'
        }]
      };

      const nodeType = node.type;
      const selectedSpec = surfaceIdTypes[nodeType].find(s => s.view === viewName);
      const args = selectedSpec.ids.reduce((args, type) => {
        args[type] = findParentByType(node, type).id;
        return args
      }, {
        path: path.join('.')
      });

      return selectedSpec.parts.call(this, args)
    }
  }

  // Base-class for Manuscript- and MetadataEditor to reduced code-redundancy
  class EditorPanel extends substance.Component {
    constructor (...args) {
      super(...args);

      this._initialize(this.props);
    }

    getActionHandlers () {
      return {
        executeCommand: this._executeCommand,
        toggleOverlay: this._toggleOverlay,
        startWorkflow: this._startWorkflow,
        closeModal: this._closeModal,
        scrollElementIntoView: this._scrollElementIntoView,
        scrollTo: this._scrollTo
      }
    }

    // EXPERIMENTAL: Editor interface to be able to access the root element of editable content
    getContentPanel () {
      return this.refs.contentPanel
    }

    // TODO: shouldn't we react on willReceiveProps?
    _initialize (props) {
      const { articleSession, config, archive, editorState, viewName } = props;

      // TODO: I want to refactor how EditorSessions are created
      // particularly I want to work on the multi-view/user sessions
      const editorSession = new EditorSession(viewName, articleSession, config, this, editorState);
      const api = new ArticleAPI(editorSession, archive, config, articleSession, { getContext: () => this.context });

      // ATTENTION: augmenting the default context with editor stuff and api etc.
      // TODO: try to find a more idiomatic approach, without needing to hack the context
      // This should be solvable by sharing things like 'api' on the ArticlePanel level
      // and adding other things to getChildContext()
      const context = Object.assign(this.context, createEditorContext(config, editorSession, this), {
        api,
        archive,
        editor: this,
        urlResolver: archive,
        editable: true
      });

      this.api = api;
      this.appState = context.appState;
      this.context = context;
      this.editorSession = editorSession;

      this.editorSession.initialize();
      this.appState.addObserver(['workflowId'], this.rerender, this, { stage: 'render' });
      this.appState.addObserver(['settings'], this._onSettingsUpdate, this, { stage: 'render' });

      // HACK: ATM there is no better way than to listen to an archive
      // event and forcing the CommandManager to update commandStates
      // and propagating the changes
      archive.on('archive:saved', () => {
        // HACK: alternatively we could trigger the commandManager directly
        // but setting the selection dirty, also makes sure the DOM selection gets rerendered
        // this.editorSession.commandManager.reduce()
        this.appState._setDirty('selection');
        this.appState.propagateUpdates();
      });

      // HACK: resetting the app state here, because things might get 'dirty' during initialization
      // TODO: find out if there is a better way to do this
      this.appState._reset();
    }

    _restoreViewport () {
      if (this.props.viewport) {
        // console.log('Restoring viewport', this.props.viewport)
        this.refs.contentPanel.setScrollPosition(this.props.viewport.x);
      }
    }

    dispose () {
      const appState = this.context.appState;
      const articleSession = this.props.articleSession;
      const editorSession = this.editorSession;
      articleSession.off(this);
      editorSession.dispose();
      appState.removeObserver(this);
      this.props.archive.off(this);
    }

    getComponentRegistry () {
      return this.props.config.getComponentRegistry()
    }

    _closeModal () {
      const appState = this.context.appState;
      appState.workflowId = null;
      appState.overlayId = null;
      appState.propagateUpdates();
    }

    _executeCommand (name, params) {
      this.editorSession.executeCommand(name, params);
    }

    _getConfigurator () {
      return this.props.config
    }

    _getContentPanel () {
      /* istanbul ignore next */
      throw new Error('This method is abstract')
    }

    _getDocument () {
      return this.props.articleSession.getDocument()
    }

    _getTheme () {
      // TODO: this should come from app settings
      return 'light'
    }

    _onKeydown (e) {
      // console.log('EditorPanel._onKeydown', e)
      let handled = false;
      const appState = this.context.appState;
      switch (e.keyCode) {
        case substance.keys.ESCAPE: {
          if (appState.findAndReplace.enabled) {
            this.context.findAndReplaceManager.closeDialog();
            handled = true;
          }
          break
        }
        default:
          //
      }
      if (!handled) {
        handled = this.context.keyboardManager.onKeydown(e, this.context);
      }
      if (handled) {
        e.stopPropagation();
        e.preventDefault();
      }
      return handled
    }

    _onSettingsUpdate () {
      // FIXME: there is a BUG in Component.js leading to undisposed surfaces
      // HACK: instead of doing an incremental DOM update force disposal by wiping the content
      // ATTENTION: removing the following line leads to the BUG
      this.empty();
      this.rerender();
    }

    _startWorkflow (workflowId) {
      const appState = this.context.appState;
      appState.workflowId = workflowId;
      appState.overlayId = workflowId;
      appState.propagateUpdates();
    }

    _renderWorkflow ($$, workflowId) {
      let Modal = this.getComponent('modal');
      let WorkflowComponent = this.getComponent(workflowId);
      return $$(Modal, {
        width: WorkflowComponent.desiredWidth
      }).addClass('se-workflow-modal sm-workflow-' + workflowId).append(
        $$(WorkflowComponent).ref('workflow')
      )
    }

    _toggleOverlay (overlayId) {
      const appState = this.context.appState;
      if (appState.overlayId === overlayId) {
        appState.overlayId = null;
      } else {
        appState.overlayId = overlayId;
      }
      appState.propagateUpdates();
    }

    _scrollElementIntoView (el, force) {
      this._getContentPanel().scrollElementIntoView(el, !force);
    }

    // used for scrolling when clicking on TOC entries
    _scrollTo (params) {
      let selector;
      if (params.nodeId) {
        selector = `[data-id="${params.nodeId}"]`;
      } else if (params.section) {
        selector = `[data-section="${params.section}"]`;
      } else {
        throw new Error('Illegal argument')
      }
      let comp = this.refs.contentPanel.find(selector);
      if (comp) {
        this._scrollElementIntoView(comp.el, true);
      }
      let router = this.context.router;
      // ATTENTION: do not change the route when running tests otherwise the test url get's lost
      if (router && !substance.platform.test) {
        router.writeRoute(Object.assign({ viewName: this.props.viewName }, params));
      }
    }
  }

  // TODO: this needs to be redesigned
  // TODO: we should follow the same approach as in Metadata, i.e. having a model which is a list of sections
  class ManuscriptTOC extends substance.Component {
    render ($$) {
      let el = $$('div').addClass('sc-toc');
      let manuscriptModel = this.props.model;

      let tocEntries = $$('div')
        .addClass('se-toc-entries')
        .ref('tocEntries')
        .on('click', substance.domHelpers.stop);

      tocEntries.append(
        $$(SectionTOCEntry, {
          label: this.getLabel('title'),
          section: 'title'
        })
      );

      tocEntries.append(
        $$(SectionTOCEntry, {
          label: this.getLabel('abstract'),
          section: 'abstract'
        })
      );

      tocEntries.append(
        $$(BodyTOCEntry, {
          label: this.getLabel('body'),
          model: manuscriptModel.getBody()
        })
      );

      tocEntries.append(
        $$(DynamicTOCEntry, {
          label: this.getLabel('footnotes-label'),
          model: manuscriptModel.getFootnotes(),
          section: 'footnotes'
        })
      );

      tocEntries.append(
        $$(DynamicTOCEntry, {
          label: this.getLabel('references-label'),
          model: manuscriptModel.getReferences(),
          section: 'references'
        })
      );

      el.append(tocEntries);

      return el
    }

    onTOCUpdated () {
      this.rerender();
    }
  }

  class SectionTOCEntry extends substance.Component {
    render ($$) {
      const { label, section } = this.props;
      let el = $$('a')
        .addClass('sc-toc-entry sm-level-1')
        .attr({ 'data-section': section })
        .on('click', this._onClick)
        .append(label);
      return el
    }

    _onClick (event) {
      event.preventDefault();
      event.stopPropagation();
      this.send('scrollTo', { section: this.props.section });
    }
  }

  class BodyTOCEntry extends ValueComponent {
    render ($$) {
      const api = this.context.api;
      let items = this.props.model.getItems();
      let headings = items.filter(node => node.type === 'heading');
      return $$('div').addClass('sc-toc-entry').append(
        headings.map(heading => {
          let el = $$('div').ref(heading.id)
            .addClass(`sc-toc-entry sm-level-${heading.level}`)
            .attr({ 'data-id': heading.id })
            .on('click', this._onClick);
          el.append(
            renderModel($$, this, createValueModel(api, heading.getPath()), { readOnly: true })
          );
          return el
        })
      )
    }

    _onClick (event) {
      let target = substance.DefaultDOMElement.wrap(event.currentTarget);
      let nodeId = target.attr('data-id');
      event.preventDefault();
      event.stopPropagation();
      this.send('scrollTo', { nodeId });
    }
  }

  // only visible when collection not empty
  class DynamicTOCEntry extends ValueComponent {
    render ($$) {
      let { label, model, section } = this.props;
      let el = $$('div')
        .addClass('sc-toc-entry sm-level-1')
        .attr({ 'data-section': section })
        .on('click', this._onClick)
        .append(label);
      if (model.length === 0) {
        el.addClass('sm-hidden');
      }
      return el
    }

    _onClick (event) {
      event.preventDefault();
      event.stopPropagation();
      this.send('scrollTo', { section: this.props.section });
    }
  }

  /**
   * A view on parts of an Article used for the manuscript view.
   */
  class ManuscriptModel {
    constructor (api, doc) {
      this._title = createValueModel(api, ['article', 'title']);
      this._subTitle = createValueModel(api, ['article', 'subTitle']);
      this._abstract = createValueModel(api, ['article', 'abstract']);
      this._authors = createValueModel(api, ['metadata', 'authors']);
      this._body = createValueModel(api, ['body', 'content']);
      this._footnotes = createValueModel(api, ['article', 'footnotes']);
      this._references = createValueModel(api, ['article', 'references']);
    }

    getAbstract () {
      return this._abstract
    }

    getAuthors () {
      return this._authors
    }

    hasAuthors () {
      return this._authors.length > 0
    }

    getBody () {
      return this._body
    }

    getFootnotes () {
      return this._footnotes
    }

    hasFootnotes () {
      return this._footnotes.length > 0
    }

    getReferences () {
      return this._references
    }

    hasReferences () {
      return this._references.length > 0
    }

    getTitle () {
      return this._title
    }

    getSubTitle () {
      return this._subTitle
    }
  }

  class ManuscriptEditor extends EditorPanel {
    _initialize (props) {
      super._initialize(props);

      this._model = new ManuscriptModel(this.context.api, this._getDocument());
    }

    didMount () {
      super.didMount();

      this._showHideTOC();
      this._restoreViewport();

      substance.DefaultDOMElement.getBrowserWindow().on('resize', this._showHideTOC, this);
    }

    didUpdate () {
      super.didUpdate();

      this._showHideTOC();
      this._restoreViewport();
    }

    dispose () {
      super.dispose();

      substance.DefaultDOMElement.getBrowserWindow().off(this);
    }

    render ($$) {
      let el = $$('div').addClass('sc-manuscript-editor')
        // sharing styles with sc-article-reader
        .addClass('sc-manuscript-view');
      el.append(
        this._renderMainSection($$),
        this._renderContextPane($$)
      );
      el.on('keydown', this._onKeydown);
      return el
    }

    _renderMainSection ($$) {
      const appState = this.context.appState;
      let mainSection = $$('div').addClass('se-main-section');
      mainSection.append(
        this._renderToolbar($$),
        $$('div').addClass('se-content-section').append(
          this._renderTOCPane($$),
          this._renderContentPanel($$)
        // TODO: this component has always the same structure and should preserve all elements, event without ref
        ).ref('contentSection'),
        this._renderFooterPane($$)
      );

      if (appState.workflowId) {
        mainSection.append(
          this._renderWorkflow($$, appState.workflowId)
        );
      }

      return mainSection
    }

    _renderTOCPane ($$) {
      let el = $$('div').addClass('se-toc-pane').ref('tocPane');
      el.append(
        $$('div').addClass('se-context-pane-content').append(
          $$(ManuscriptTOC, { model: this._model })
        )
      );
      return el
    }

    _renderToolbar ($$) {
      const Toolbar$$1 = this.getComponent('toolbar');
      const configurator = this._getConfigurator();
      const items = configurator.getToolPanel('toolbar', true);
      return $$('div').addClass('se-toolbar-wrapper').append(
        $$(Managed(Toolbar$$1), {
          items,
          bindings: ['commandStates']
        }).ref('toolbar')
      )
    }

    _renderContentPanel ($$) {
      const ScrollPane$$1 = this.getComponent('scroll-pane');
      const ManuscriptComponent = this.getComponent('manuscript');
      const Dropzones = this.getComponent('dropzones');

      let contentPanel = $$(ScrollPane$$1, {
        contextMenu: 'custom',
        scrollbarPosition: 'right'
      // NOTE: this ref is needed to access the root element of the editable content
      }).ref('contentPanel');

      contentPanel.append(
        $$(ManuscriptComponent, {
          model: this._model,
          disabled: this.props.disabled
        }).ref('article'),
        this._renderMainOverlay($$),
        this._renderContextMenu($$),
        $$(Dropzones)
      );
      return contentPanel
    }

    _renderMainOverlay ($$) {
      const Overlay$$1 = this.getComponent('overlay');
      const configurator = this._getConfigurator();
      const items = configurator.getToolPanel('main-overlay');
      return $$(Managed(Overlay$$1), {
        items,
        theme: this._getTheme(),
        bindings: ['commandStates']
      })
    }

    _renderContextMenu ($$) {
      const configurator = this._getConfigurator();
      const ContextMenu$$1 = this.getComponent('context-menu');
      const items = configurator.getToolPanel('context-menu');
      return $$(Managed(ContextMenu$$1), {
        items,
        theme: this._getTheme(),
        bindings: ['commandStates']
      })
    }

    _renderFooterPane ($$) {
      const FindAndReplaceDialog = this.getComponent('find-and-replace-dialog');
      let el = $$('div').addClass('se-footer-pane');
      el.append(
        $$(FindAndReplaceDialog, {
          theme: this._getTheme(),
          viewName: 'manuscript'
        }).ref('findAndReplace')
      );
      return el
    }

    _renderContextPane ($$) {
      // TODO: we need to revisit this
      // We have introduced this to be able to inject a shared context panel
      // in Stencila. However, ATM we try to keep the component
      // as modular as possible, and avoid these kind of things.
      if (this.props.contextComponent) {
        let el = $$('div').addClass('se-context-pane');
        el.append(
          $$('div').addClass('se-context-pane-content').append(
            this.props.contextComponent
          )
        );
        return el
      }
    }

    _getContentPanel () {
      return this.refs.contentPanel
    }

    getViewport () {
      return {
        x: this.refs.contentPanel.getScrollPosition()
      }
    }

    _showHideTOC () {
      let contentSectionWidth = this.refs.contentSection.el.width;
      if (contentSectionWidth < 960) {
        this.el.addClass('sm-compact');
      } else {
        this.el.removeClass('sm-compact');
      }
    }
  }

  /*
    This is a proto component which allows you to render a file uploader
    with possible drop fuctionaluty.
    To use it you'll need to inherit this component as a parent and override
    handleUploadedFiles method to implement your own file handling strategy.
  */
  class FileUploadComponent extends substance.Component {
    get acceptedFiles () {
      return false
    }

    render ($$) {
      const el = $$('div').addClass('sc-file-upload');

      const selectInput = $$('input').attr({
        type: 'file'
      }).on('click', this._supressClickPropagation)
        .on('change', this._selectFile)
        .ref('input');

      if (this.acceptedFiles) {
        selectInput.attr({ accept: this.acceptedFiles });
      }

      // HACK: to place a link inside label we will use
      // another placeholder with a substring of first one
      const placeholder = this.getLabel('file-upload-placeholder');
      const selectPlaceholder = this.getLabel('file-upload-select-placeholder');
      const placeholderParts = placeholder.split(selectPlaceholder);

      const dropZone = $$('div').addClass('se-drop-import').append(
        placeholderParts[0],
        $$('span').addClass('se-select-trigger')
          .append(selectPlaceholder)
          .on('click', this._onClick),
        placeholderParts[1],
        selectInput
      ).on('drop', this._handleDrop)
        .on('dragstart', this._onDrag)
        .on('dragenter', this._onDrag)
        .on('dragend', this._onDrag);

      el.append(dropZone);

      if (this.state.error) {
        el.append(
          $$('div').addClass('se-error-popup').append(this.renderErrorsList($$))
        );
      }

      return el
    }

    renderErrorsList ($$) {
      return $$('ul').addClass('se-error-list').append(this.getLabel('file-upload-error'))
    }

    handleUploadedFiles (files) {
      throw new Error('This method is abstract')
    }

    _onClick () {
      this.refs.input.click();
    }

    _supressClickPropagation (e) {
      e.stopPropagation();
    }

    _selectFile (e) {
      const files = e.currentTarget.files;
      this.handleUploadedFiles(files);
    }

    _handleDrop (e) {
      const files = e.dataTransfer.files;
      this.handleUploadedFiles(files);
    }

    _onDrag (e) {
      // Stop event propagation for the dragstart and dragenter
      // events, to avoid editor drag manager errors
      e.stopPropagation();
    }
  }

  class SupplementaryFileUploadComponent extends FileUploadComponent {
    // NOTE: we are sending uploaded files up to the workflow component
    handleUploadedFiles (files) {
      if (files) {
        this.send('importFile', files);
      }
    }
  }

  class AddSupplementaryFileWorkflow extends substance.Component {
    static get desiredWidth () {
      return 'medium'
    }

    didMount () {
      super.didMount();

      this.handleActions({
        'importFile': this._onFileImport
      });
    }

    render ($$) {
      let el = $$('div').addClass('sc-add-supplementary-file sm-workflow');

      let Input = this.getComponent('input');
      let Button$$1 = this.getComponent('button');

      const title = $$('div').addClass('se-title').append(
        this.getLabel('supplementary-file-workflow-title')
      );

      const urlInput = $$(InputWithButton, {
        input: $$(Input, {
          placeholder: this.getLabel('supplementary-file-link-placeholder') }
        ).ref('urlInput'),
        button: $$(Button$$1).append(
          this.getLabel('add-action')
        ).on('click', this._onExternalFileImport)
      });

      el.append(
        title,
        $$(DialogSectionComponent, { label: this.getLabel('supplementary-file-upload-label') })
          .append($$(SupplementaryFileUploadComponent)),
        $$(DialogSectionComponent, { label: this.getLabel('supplementary-file-link-label') })
          .append(urlInput)
      );

      return el
    }

    _onExternalFileImport () {
      const url = this.refs.urlInput.val();
      let api = this.context.api;
      api._insertSupplementaryFile(null, url);
      this.send('closeModal');
    }

    _onFileImport (files) {
      let api = this.context.api;
      api._insertSupplementaryFile(files[0]);
      this.send('closeModal');
    }
  }

  class BasicFigurePanelCommand extends substance.Command {
    getCommandState (params, context) {
      return {
        disabled: this.isDisabled(params, context)
      }
    }

    isDisabled (params) {
      const xpath = params.selectionState.xpath;
      return !xpath.find(n => n.type === 'figure')
    }

    _getFigure (params, context) {
      const sel = params.selection;
      const doc = params.editorSession.getDocument();
      let nodeId = sel.getNodeId();
      const selectedNode = doc.get(nodeId);
      if (selectedNode.type !== 'figure') {
        const node = findParentByType(selectedNode, 'figure');
        nodeId = node.id;
      }
      return doc.get(nodeId)
    }

    _getFigurePanel (params, context) {
      const figure = this._getFigure(params, context);
      const currentIndex = figure.getCurrentPanelIndex();
      const doc = figure.getDocument();
      return doc.get(figure.panels[currentIndex])
    }

    _matchSelection (params, context) {
      const xpath = params.selectionState.xpath;
      const isInFigure = xpath.find(n => n.type === 'figure');
      return isInFigure
    }
  }

  class AddFigurePanelCommand extends BasicFigurePanelCommand {
    execute (params, context) {
      const files = params.files;
      // TODO: why only one file? we could also add multiple panels at once
      if (files.length > 0) {
        const file = files[0];
        const figure = this._getFigure(params, context);
        context.api._addFigurePanel(figure.id, file);
      }
    }
  }

  class ReplaceFigurePanelImageCommand extends BasicFigurePanelCommand {
    execute (params, context) {
      const figurePanel = this._getFigurePanel(params, context);
      const files = params.files;
      if (files.length > 0) {
        let graphic = figurePanel.getContent();
        context.api._replaceFile([graphic.id, 'href'], files[0]);
      }
    }

    isDisabled (params, context) {
      const matchSelection = this._matchSelection(params, context);
      if (matchSelection) return false
      return true
    }
  }

  class RemoveFigurePanelCommand extends BasicFigurePanelCommand {
    execute (params, context) {
      const api = context.api;
      const figure = this._getFigure(params, context);
      const figurePanel = this._getFigurePanel(params, context);
      // TODO: this shows that generic API does not work without additional steps
      api._deleteChild([figure.id, 'panels'], figurePanel, tx => {
        tx.selection = null;
      });
    }

    isDisabled (params, context) {
      const matchSelection = this._matchSelection(params, context);
      if (matchSelection) {
        const figure = this._getFigure(params, context);
        if (figure.panels.length > 1) {
          return false
        }
      }
      return true
    }
  }

  class MoveFigurePanelCommand extends BasicFigurePanelCommand {
    execute (params, context) {
      const direction = this.config.direction;
      const figure = this._getFigure(params, context);
      const figurePanel = this._getFigurePanel(params, context);
      const pos = figurePanel.getPosition();
      const shift = direction === 'up' ? -1 : 1;
      context.api._moveChild([figure.id, 'panels'], figurePanel, shift, tx => {
        tx.set([figure.id, 'state', 'currentPanelIndex'], pos + shift);
      });
    }

    isDisabled (params, context) {
      const matchSelection = this._matchSelection(params, context);
      if (matchSelection) {
        const figure = this._getFigure(params, context);
        const currentIndex = figure.getCurrentPanelIndex();
        const direction = this.config.direction;
        if (figure.panels.length > 1) {
          if ((direction === 'up' && currentIndex > 0) || (direction === 'down' && currentIndex < figure.panels.length - 1)) {
            return false
          }
        }
      }
      return true
    }
  }

  class OpenFigurePanelImageCommand extends BasicFigurePanelCommand {
    // We are using this command only for state computation.
    // Actual implementation of opening sub-figure is done inside OpenSubFigureSourceTool.
    execute () {
    }
  }

  class DecreaseHeadingLevelCommand extends substance.Command {
    getCommandState (params) {
      let doc = params.editorSession.getDocument();
      let sel = params.selection;
      let isBlurred = params.editorSession.isBlurred();

      let commandState = {
        disabled: false
      };

      if (sel.isPropertySelection() && !isBlurred) {
        let path = sel.getPath();
        let node = doc.get(path[0]);
        if (node &&
          node.isBlock() &&
          node.type === 'heading') {
          commandState.active = true;
        } else {
          commandState.disabled = true;
        }
      } else {
        commandState.disabled = true;
      }

      return commandState
    }

    execute (params) {
      let sel = params.selection;
      let editorSession = params.editorSession;
      let doc = editorSession.getDocument();
      let path = sel.getPath();
      let node = doc.get(path[0]);
      if (node.getAttribute('level') > 1) {
        editorSession.transaction((txDoc) => {
          let node = txDoc.get(path[0]);
          node.setAttribute('level', String(parseInt(node.level, 10) - 1));
        });
      }
    }
  }

  /*
    We are using this command only for state computation.
    Actual implementation of file downloading is done inside DownloadSupplementaryFileTool
  */
  class DownloadSupplementaryFileCommand extends substance.Command {
    getCommandState (params, context) {
      const selectionState = params.selectionState;
      const xpath = selectionState.xpath;
      if (xpath.length > 0) {
        const selectedType = xpath[xpath.length - 1].type;
        if (selectedType === 'supplementary-file') {
          return {
            disabled: false,
            // leaving the node, so that the tool can apply different
            // strategies for local vs remote files
            node: selectionState.node
          }
        }
      }
      return { disabled: true }
    }

    execute (params, context) {
      // Nothing: downloading is implemented via native download hooks
    }
  }

  class DownloadSupplementaryFileTool extends Tool {
    render ($$) {
      let el = super.render($$);
      let link = $$('a').ref('link')
        // ATTENTION: stop propagation, otherwise infinite loop
        .on('click', substance.domHelpers.stop);

      // Downloading is a bit involved:
      // In electron, everything can be done with one solution,
      // handling a 'will-download' event, which is triggered when the `download`
      // attribute is present.
      // For the browser, the `download` attribute works only for files from the same
      // origin. For remote files the best we can do at the moment, is opening
      // a new tab, and let the browser deal with it.
      // TODO: if this feature is important, one idea is that the DAR server could
      // provide an end-point to provide download-urls, and act as a proxy to
      // cirvumvent the CORS problem.
      const isLocal = this._isLocal();
      if (substance.platform.inElectron || isLocal) {
        link.attr('download', '');
      } else {
        link.attr('target', '_blank');
      }

      el.append(link);
      return el
    }

    getClassNames () {
      return 'sc-download-supplementary-file-tool sc-tool'
    }

    _onClick (e) {
      e.stopPropagation();
      e.preventDefault();
      this._triggerDownload();
    }

    _triggerDownload () {
      const archive = this.context.archive;
      const node = this._getNode();
      const isLocal = this._isLocal();
      let url = node.href;
      if (isLocal) {
        url = archive.getDownloadLink(node.href);
      }
      if (url) {
        this.refs.link.el.attr({
          'href': url
        });
        this.refs.link.el.click();
      }
    }

    _getNode () {
      return this.props.commandState.node
    }

    _isLocal () {
      let node = this._getNode();
      return (!node || !node.remote)
    }
  }

  var DropFigure = {
    type: 'drop-asset',
    match (params) {
      // Mime-type starts with 'image/'
      let isImage = params.file.type.indexOf('image/') === 0;
      return params.type === 'file' && isImage
    },
    drop (tx, params, context) {
      let api = context.api;
      api._insertFigures([params.file]);
    }
  }

  class EditBlockFormulaCommand extends substance.Command {
    getCommandState (params, context) {
      let sel = params.selection;
      let newState = {
        disabled: true,
        active: false
      };

      if (sel.isNodeSelection()) {
        const selectionState = params.selectionState;
        const node = selectionState.node;
        if (node.type === 'block-formula') {
          newState.disabled = false;
          newState.nodeId = node.id;
        }
      }

      return newState
    }

    execute (params, context) { } // eslint-disable-line no-unused
  }

  const COMMAND_OR_CONTROL_ENTER = substance.parseKeyEvent(substance.parseKeyCombo('CommandOrControl+Enter'));

  /*
    Tool to edit math markup.
  */
  class EditDispFormulaTool extends ToggleTool {
    render ($$) {
      let TextArea = this.getComponent('text-area');
      let commandState = this.props.commandState;
      let el = $$('div').addClass('sc-edit-math-tool');

      // GUARD: Return if tool is disabled
      if (commandState.disabled) {
        console.warn('Tried to render EditMathTool while disabled.');
        return el
      }
      let nodeId = this.getNodeId();
      el.append(
        $$(TextArea, {
          path: [nodeId, 'content'],
          placeholder: 'Enter TeX',
          rows: 10,
          cols: 80,
          retainFocus: true
        }).addClass('sm-big-input')
          // ATTENTION have a ref on it, otherwise the input will get rerendered on every change
          // TODO: this component has always the same structure and should preserve all elements, event without ref
          .ref('input')
          // stopping keydown events so that the input field is not distracted by other editor keyboard handler
          // TODO: maybe let 'Save' through...
          .on('keydown', this._onInputKeydown)
      );
      return el
    }

    getNodeId () {
      return this.props.commandState.nodeId
    }

    _onInputKeydown (event) {
      // in any case we do not want to let any keydowns bubble up when the cursor is inside the input
      // TODO: is that so?
      event.stopPropagation();
      let combo = substance.parseKeyEvent(event);
      switch (combo) {
        case COMMAND_OR_CONTROL_ENTER: {
          this.refs.input._onChange();
          break
        }
        default:
          // nothing
      }
    }
  }

  /*
    This command intended to switch view and scroll to the selected node.
    Command state becoming active only for certain type of custom selection,
    e.g. if you want to use it, provide config with selectionType property.
  */
  class EditEntityCommand extends substance.Command {
    getCommandState (params, context) {
      let sel = params.selection;
      let newState = {
        disabled: true
      };

      if (sel.isCustomSelection()) {
        if (sel.customType === this.config.selectionType) {
          newState.disabled = false;
          newState.nodeId = sel.nodeId;
        }
      }

      return newState
    }

    execute (params, context) {
      const appState = context.appState;
      const viewName = appState.get('viewName');
      if (viewName !== 'metadata') {
        const sel = params.selection;
        const nodeId = sel.nodeId;
        context.editor.send('updateViewName', 'metadata');
        // HACK: using the ArticlePanel instance to get to the current editor
        // so that we can dispatch 'executeCommand'
        let editor = context.articlePanel.refs.content;
        editor.send('scrollTo', { nodeId });
        // HACK: this is a mess because context.api is a different instance after
        // switching to metadata view
        // TODO: we should extend ArticleAPI to allow for this
        editor.api.selectFirstRequiredPropertyOfMetadataCard(nodeId);
      }
    }
  }

  class EditInlineFormulaCommand extends substance.EditInlineNodeCommand {}

  /**
   * Tool to edit the markup of an InlineFormula.
   */
  class EditInlineFormulaTool extends ToggleTool {
    render ($$) {
      const { disabled, nodeId } = this.props.commandState;
      const Input = this.getComponent('input');
      let el = $$('div').addClass('sc-edit-math-tool');

      // GUARD: Return if tool is disabled
      if (disabled) {
        console.warn('Tried to render EditMathTool while disabled.');
        return el
      }
      el.append(
        $$(Input, {
          type: 'text',
          path: [nodeId, 'content'],
          // TODO: use this.getLabel()
          placeholder: 'Enter TeX'
        })
          // TODO: this component has always the same structure and should preserve all elements, event without ref
          .ref('input')
          // stopping keydown events so that the input field is not distracted by other editor keyboard handler
          // TODO: maybe let write through?
          .on('keydown', substance.domHelpers.stop)
      );
      return el
    }
  }

  class EditXrefCommand extends substance.EditInlineNodeCommand {}

  class IncreaseHeadingLevelCommand extends substance.Command {
    getCommandState (params) {
      let doc = params.editorSession.getDocument();
      let sel = params.selection;
      let isBlurred = params.editorSession.isBlurred();

      let commandState = {
        disabled: false
      };

      if (sel.isPropertySelection() && !isBlurred) {
        let path = sel.getPath();
        let node = doc.get(path[0]);
        if (node &&
          node.isBlock() &&
          node.type === 'heading') {
          commandState.active = true;
        } else {
          commandState.disabled = true;
        }
      } else {
        commandState.disabled = true;
      }

      return commandState
    }

    execute (params) {
      let sel = params.selection;
      let editorSession = params.editorSession;
      let doc = editorSession.getDocument();
      let path = sel.getPath();
      let node = doc.get(path[0]);
      if (node.getAttribute('level') < 3) {
        editorSession.transaction((txDoc) => {
          let node = txDoc.get(path[0]);
          node.setAttribute('level', String(parseInt(node.level, 10) + 1));
        });
      }
    }
  }

  /**
    Reusable command implementation for inserting inline nodes.

    @example

    Define a custom command.

    ```
    class AddXRefCommand extends InsertInlineNodeCommand {
      _createNode(tx) {
        let refType = this.config.refType
        let xref = tx.createElement('xref').attr('publication-type', 'journal')
        xref.attr('ref-type', refType)
        xref.attr('rid', '')
        return xref
      }
    }
    ```

    Register it in your app using the configurator.

    ```
    config.addCommand('add-xref', AddXRefCommand, { nodeType: 'xref' })
    ```
  */

  class InsertInlineNodeCommand extends substance.InsertInlineNodeCommand {
    getType () {
      throw new Error('This method is abstract')
    }

    /**
      Insert new inline node at the current selection
    */
    execute (params, context) {
      let state = this.getCommandState(params, context);
      if (!state.disabled) {
        this._execute(params, context);
      }
    }

    isDisabled (params) {
      const sel = params.selection;
      const selectionState = params.editorSession.getSelectionState();
      // We allow inserting an inline node only if
      // 1. the selection is a property selection
      // 2. and there is no inline node already
      // Note: if a child command should only be active if collapsed, then it should
      // override isDisabled() and return super.isDisabled || sel.isCollapsed()
      return (!sel || !sel.isPropertySelection() || selectionState.isInlineNodeSelection)
    }

    /*
      Default implementation starts a transaction, and let's the command implementation create a node.
      This node gets inserted at the current cursor position and after that the inline node gets selected.
    */
    _execute (params, context) {
      // TODO: use API
      let editorSession = context.editorSession;
      editorSession.transaction(tx => {
        let node = this._createNode(tx, params, context);
        tx.insertInlineNode(node);
        this._setSelection(tx, node);
      });
    }

    _setSelection (tx, inlineNode) {
      // Note: selecting the inlineNode will typically result in opening a popup for editing
      tx.selection = {
        type: 'property',
        path: inlineNode.getPath(),
        startOffset: inlineNode.start.offset,
        endOffset: inlineNode.end.offset
      };
    }

    _createNode (tx, params, context) { // eslint-disable-line no-unused-vars
      throw new Error('This method is abstract')
    }
  }

  class InsertCrossReferenceCommand extends InsertInlineNodeCommand {
    getType () {
      return 'xref'
    }

    isDisabled (params, context) {
      // cross-references should only be inserted with collapsed selection
      const sel = params.selection;
      return (super.isDisabled(params, context) || !sel.isCollapsed())
    }

    _getRefType (params, context) { // eslint-disable-line
      return this.config.refType
    }

    _createNode (tx, params, context) {
      return tx.create({
        type: 'xref',
        refType: this._getRefType(params, context)
      })
    }
  }

  class InsertNodeCommand extends substance.InsertNodeCommand {
    execute (params, context) {
      let state = params.commandState;
      if (state.disabled) return
      let editorSession = context.editorSession;
      editorSession.transaction((tx) => {
        let node = this.createNode(tx, params, context);
        tx.insertBlockNode(node);
        this.setSelection(tx, node);
      });
    }

    createNode(tx) { // eslint-disable-line
      throw new Error('This method is abstract')
    }
  }

  class InsertDispFormulaCommand extends InsertNodeCommand {
    createNode (tx) {
      return tx.create({ type: 'block-formula' })
    }
  }

  class InsertBlockQuoteCommand extends InsertNodeCommand {
    createNode (tx, params, context) {
      return substance.documentHelpers.createNodeFromJson(tx, BlockQuote.getTemplate())
    }
  }

  class InsertExtLinkCommand extends substance.AnnotationCommand {
    executeCreate (params, context) {
      let result = super.executeCreate(params);
      let editorSession = context.editorSession;
      editorSession.transaction((tx) => {
        tx.setSelection(tx.selection.collapse());
      });
      return result
    }
  }

  // TODO: this is kind of surprising, because it actually allows to insert multiple figures at once
  class InsertFigureCommand extends InsertNodeCommand {
    execute (params, context) {
      const state = params.commandState;
      const files = params.files;
      if (state.disabled) return
      let api = context.api;
      if (files.length > 0) {
        api._insertFigures(files);
      }
    }
  }

  class UploadTool extends Tool {
    // In addition to the regular button a file input is rendered
    // which is used to trigger the browser's file dialog.
    render ($$) {
      let el = super.render($$);

      const isMultiple = this.canUploadMultiple;
      const input = $$('input').attr({
        'type': 'file'
      }).ref('input')
        .on('change', this.onFileSelect)
        // ATTENTION: it is important to stop click events on the input
        // as otherwise Tools click handler will be triggered again
        .on('click', substance.domHelpers.stop);
      if (!this.doesAcceptAllFileTypes) {
        const fileType = this.getFileType();
        input.attr({ 'accept': fileType });
      }
      if (isMultiple) {
        input.attr({
          'multiple': 'multiple'
        });
      }
      el.append(input);
      return el
    }

    getClassNames () {
      return 'sc-upload-tool'
    }

    getFileType () {
      throw new Error('This method is abstract')
    }

    get canUploadMultiple () {
      return false
    }

    get doesAcceptAllFileTypes () {
      return false
    }

    _onClick (e) {
      e.stopPropagation();
      e.preventDefault();
      this.refs.input.el.val(null);
      this.refs.input.el.click();
    }

    onFileSelect (e) {
      let files = e.currentTarget.files;
      this.executeCommand({
        files: Array.prototype.slice.call(files)
      });
    }
  }

  class InsertFigureTool extends UploadTool {
    getClassNames () {
      return 'sc-insert-figure-tool sc-upload-tool sc-tool'
    }

    getFileType () {
      return 'image/*'
    }

    get canUploadMultiple () {
      return true
    }
  }

  // This is a base class for tools that upload a file
  class UploadSingleImageTool extends UploadTool {
    getFileType () {
      return 'image/*'
    }

    get canUploadMultiple () {
      return false
    }
  }

  class InsertFigurePanelTool extends UploadSingleImageTool {
    getClassNames () {
      return 'sc-insert-figure-panel-tool sc-upload-tool sc-tool'
    }
  }

  class InsertFootnoteCommand extends AddEntityCommand {
    detectScope (params) {
      const xpath = params.selectionState.xpath;
      return xpath.find(n => n.type === 'table-figure') ? 'table-figure' : 'default'
    }

    _getCollectionPath (params, context) {
      const scope = this.detectScope(params);
      if (scope === 'default') {
        return ['article', 'footnotes']
      } else {
        const doc = params.editorSession.getDocument();
        const nodeId = params.selection.getNodeId();
        const node = doc.get(nodeId);
        let tableNodeId = node.id;
        // check if we are already selected table-figure
        if (node.type !== 'table-figure') {
          const parentTable = findParentByType(node, 'table-figure');
          tableNodeId = parentTable.id;
        }
        return [tableNodeId, 'footnotes']
      }
    }

    _addItemToCollection (params, context) {
      let collectionPath = this._getCollectionPath(params, context);
      context.editorSession.transaction(tx => {
        let node = substance.documentHelpers.createNodeFromJson(tx, Footnote.getTemplate());
        substance.documentHelpers.append(tx, collectionPath, node.id);
        let p = tx.get(node.content[0]);
        tx.setSelection({
          type: 'property',
          path: p.getPath(),
          startOffset: 0,
          // TODO: adapt ArticleAPI._getSurfaceId()
          surfaceId: `${node.id}.content`,
          containerPath: [node.id, 'content']
        });
      });
    }
  }

  class InsertFootnoteCrossReferenceCommand extends InsertCrossReferenceCommand {
    getCommandState (params, context) {
      let sel = params.selection;
      let scope = this.detectScope(params, context);
      let newState = {
        disabled: this.isDisabled(params, scope),
        showInContext: this.showInContext(sel, params, context),
        scope
      };
      return newState
    }

    detectScope (params, context) {
      // Note: ATM we only consider two scopes: 'default', 'table-figure'
      // In table-figures we will only allow to cross-reference to table-footnotes
      const xpath = params.selectionState.xpath;
      return xpath.find(n => n.type === 'table-figure') ? 'table-figure' : 'default'
    }

    _getRefType (params, context) {
      let commandState = params.commandState;
      if (commandState.scope === 'table-figure') {
        return 'table-fn'
      } else {
        return 'fn'
      }
    }
  }

  class InsertInlineFormulaCommand extends InsertInlineNodeCommand {
    getType () {
      return 'inline-formula'
    }

    _createNode (tx, params, context) {
      const sel = tx.selection;
      const doc = tx.getDocument();
      // Note: the user can select text and turn it into a formula
      const initialContent = substance.documentHelpers.getTextForSelection(doc, sel);
      const inlineFormula = tx.create({
        type: 'inline-formula',
        contentType: 'math/tex',
        content: initialContent
      });
      return inlineFormula
    }
  }

  class InsertInlineGraphicCommand extends InsertInlineNodeCommand {
    getType () {
      return 'inline-graphic'
    }

    getCommandState (...args) {
      let commandState = super.getCommandState(...args);
      return commandState
    }

    // Overridden as we are using API code here
    _execute (params, context) {
      const files = params.files;
      let api = context.api;
      if (files.length > 0) {
        api._insertInlineGraphic(files[0]);
      }
    }
  }

  class InsertInlineGraphicTool extends UploadTool {
    getClassNames () {
      return 'sc-insert-inline-graphic-tool sc-upload-tool sc-tool'
    }

    getFileType () {
      return 'image/*'
    }
  }

  // turns the current text node into a list
  class CreateListCommand extends substance.Command {
    isSwitchTypeCommand () { return true }

    // TODO: do we want to generalize this to other list types?
    getType () {
      return 'list'
    }

    getCommandState (params) {
      let editorSession = params.editorSession;
      let doc = editorSession.getDocument();
      let sel = editorSession.getSelection();
      if (sel && sel.isPropertySelection()) {
        let path = sel.path;
        let node = doc.get(path[0]);
        if (node) {
          if (node.isText()) {
            return {
              disabled: false
            }
          }
        }
      }
      return { disabled: true }
    }

    execute (params) {
      let commandState = params.commandState;
      const { disabled } = commandState;
      if (disabled) return
      let editorSession = params.editorSession;
      editorSession.transaction(tx => {
        tx.toggleList({ listType: this.config.spec.listType });
      }, { action: 'toggleList' });
    }
  }

  class ChangeListTypeCommand extends substance.Command {
    getCommandState (params) {
      let editorSession = params.editorSession;
      let doc = editorSession.getDocument();
      let sel = editorSession.getSelection();
      if (sel && sel.isPropertySelection()) {
        let path = sel.path;
        let node = doc.get(path[0]);
        if (node) {
          if (node.isListItem()) {
            let level = node.getLevel();
            let list = node.getParent();
            let listType = list.getListType(level);
            let active = listType === this.config.spec.listType;
            let action = active ? 'toggleList' : 'setListType';
            let listId = list.id;
            return {
              disabled: false,
              active,
              action,
              listId,
              level
            }
          }
        }
      }
      return { disabled: true }
    }

    execute (params) {
      let commandState = params.commandState;
      const { disabled, action } = commandState;
      if (disabled) return

      let editorSession = params.editorSession;
      switch (action) {
        case 'toggleList': {
          editorSession.transaction((tx) => {
            tx.toggleList();
          }, { action: 'toggleList' });
          break
        }
        case 'setListType': {
          const { listId, level } = commandState;
          editorSession.transaction((tx) => {
            let list = tx.get(listId);
            list.setListType(level, this.config.spec.listType);
          }, { action: 'setListType' });
          break
        }
        default:
        //
      }
    }
  }

  /*
    This command is opening a workflow when it is possible to insert a node.
    Use it when you want to insert a node after additional workflow step.
  */
  class InsertNodeFromWorkflowCommand extends InsertNodeCommand {
    execute (params, context) {
      const workflow = this.config.workflow;
      context.editor.send('startWorkflow', workflow);
    }
  }

  const DISABLED$2 = { disabled: true };

  class InsertTableCommand extends InsertNodeCommand {
    createNode (tx, params, context) {
      return substance.documentHelpers.createNodeFromJson(tx, TableFigure.getTemplate())
    }
  }

  class BasicTableCommand extends substance.Command {
    getCommandState (params, context) { // eslint-disable-line no-unused-vars
      const tableApi = context.api.getTableAPI();
      if (!tableApi.isTableSelected()) return DISABLED$2
      const selData = tableApi._getSelectionData();
      return Object.assign({ disabled: false }, selData)
    }

    execute (params, context) { // eslint-disable-line no-unused-vars
      const commandState = params.commandState;
      if (commandState.disabled) return

      const tableApi = context.api.getTableAPI();
      return this._execute(tableApi, commandState)
    }
  }

  class InsertCellsCommand extends BasicTableCommand {
    _execute (tableApi, { ncols, nrows }) {
      const mode = this.config.spec.pos;
      const dim = this.config.spec.dim;
      if (dim === 'row') {
        tableApi.insertRows(mode, nrows);
      } else {
        tableApi.insertCols(mode, ncols);
      }
      return true
    }
  }

  class DeleteCellsCommand extends BasicTableCommand {
    _execute (tableApi, { startRow, startCol, nrows, ncols }) {
      const dim = this.config.spec.dim;
      if (dim === 'row') {
        tableApi.deleteRows();
      } else {
        tableApi.deleteCols();
      }
      return true
    }
  }

  class TableSelectAllCommand extends BasicTableCommand {
    _execute (tableApi) {
      tableApi.selectAll();
      return true
    }
  }

  class ToggleCellHeadingCommand extends BasicTableCommand {
    getCommandState (params, context) { // eslint-disable-line no-unused-vars
      let commandState = super.getCommandState(params, context);
      if (commandState.disabled) return commandState

      let { table, startRow, endRow, startCol, endCol } = commandState;
      let cells = substance.getRangeFromMatrix(table.getCellMatrix(), startRow, startCol, endRow, endCol, true);
      cells = substance.flatten(cells).filter(c => !c.shadowed);
      let onlyHeadings = true;
      for (let i = 0; i < cells.length; i++) {
        if (!cells[i].heading) {
          onlyHeadings = false;
          break
        }
      }
      return Object.assign(commandState, {
        active: onlyHeadings,
        cellIds: cells.map(c => c.id)
      })
    }

    _execute (tableApi, { cellIds, heading }) {
      tableApi.toggleHeading(cellIds);
      return true
    }
  }

  class ToggleCellMergeCommand extends BasicTableCommand {
    getCommandState (params, context) { // eslint-disable-line no-unused-vars
      let commandState = super.getCommandState(params, context);
      if (commandState.disabled) return commandState

      let { table, nrows, ncols, startRow, startCol } = commandState;
      let cell = table.getCell(startRow, startCol);
      let rowspan = cell.rowspan;
      let colspan = cell.colspan;
      // ATTENTION: at the moment the selection is expressed in absolute
      // rows and cols, not considering colspans and rowspans
      // If a single cell with row- or colspan is selected, then
      // nrows=rowspan and ncols=colspan
      if (nrows > 1 || ncols > 1) {
        if (rowspan < nrows || colspan < ncols) {
          commandState.merge = true;
        } else {
          commandState.active = true;
          commandState.unmerge = true;
        }
      }
      // only enable if one merge option is enabled
      // TODO: if table commands are enabled this command should
      // be shown even if disabled
      if (!commandState.merge && !commandState.unmerge) {
        return DISABLED$2
      }
      return commandState
    }

    _execute (tableApi, { merge, unmerge }) {
      if (merge) {
        tableApi.merge();
      } else if (unmerge) {
        tableApi.unmerge();
      }
      return true
    }
  }

  class InsertTableTool extends Tool {
    getClassNames () {
      return 'sc-insert-table-tool sc-tool'
    }

    onClick () {
      const rows = 3;
      const columns = 5;
      this.executeCommand({
        rows: rows,
        columns: columns
      });
    }
  }

  class OpenFigurePanelImageTool extends Tool {
    render ($$) {
      let el = super.render($$);
      el.append(
        $$('a').ref('link')
          .attr('target', '_blank')
          // ATTENTION: stop propagation, otherwise infinite loop
          .on('click', substance.domHelpers.stop)
      );
      return el
    }

    getClassNames () {
      return 'sc-open-figure-panel-source-tool sc-tool'
    }

    _onClick (e) {
      e.stopPropagation();
      e.preventDefault();
      this._generateLink();
    }

    _generateLink () {
      const urlResolver = this.context.urlResolver;
      const editorSession = this.context.editorSession;
      const selectionState = editorSession.getSelectionState();
      const node = selectionState.node;
      let currentPanel = node;
      if (node.type === 'figure') {
        const panels = node.getPanels();
        const currentIndex = node.getCurrentPanelIndex();
        currentPanel = panels[currentIndex];
      }
      const graphic = currentPanel.resolve('content');
      const url = urlResolver.resolveUrl(graphic.href);
      if (url) {
        this.refs.link.el.attr({
          'href': url
        });
        this.refs.link.el.click();
      }
    }
  }

  class RemoveItemCommand extends substance.Command {
    getCommandState (params, context) {
      return { disabled: this.isDisabled(params, context) }
    }

    isDisabled (params, context) {
      const nodeType = this.config.nodeType;
      const xpath = params.selectionState.xpath;
      return !xpath.find(n => n.type === nodeType)
    }

    execute (params, context) {
      const api = context.api;
      const node = this._getNode(params);
      const path = this._getPath(context, node);
      const editorSession = context.editorSession;
      editorSession.transaction(tx => {
        substance.documentHelpers.remove(tx, path, node.id);
        api._removeCorrespondingXrefs(tx, node);
        substance.documentHelpers.deepDeleteNode(tx, node.id);
        tx.selection = null;
      });
    }

    _getNode (params) {
      const nodeType = this.config.nodeType;
      const sel = params.selection;
      const doc = params.editorSession.getDocument();
      const nodeId = sel.getNodeId();
      const selectedNode = doc.get(nodeId);
      if (selectedNode.type === nodeType) return selectedNode
      return findParentByType(selectedNode, nodeType)
    }

    _getPath (context, node) {
      const parent = node.getParent();
      const propName = node.getXpath().property;
      return [parent.id, propName]
    }
  }

  class ReplaceFigurePanelTool extends UploadSingleImageTool {
    getClassNames () {
      return 'sc-replace-figure-panel-tool sc-upload-tool sc-tool'
    }
  }

  class ReplaceSupplementaryFileCommand extends substance.Command {
    getCommandState (params, context) {
      const xpath = params.selectionState.xpath;
      if (xpath.length > 0) {
        const selectedType = xpath[xpath.length - 1].type;
        if (selectedType === 'supplementary-file') {
          const node = params.selectionState.node;
          if (!node.remote) {
            return { disabled: false }
          }
        }
      }
      return { disabled: true }
    }

    execute (params, context) {
      const state = params.commandState;
      if (state.disabled) return
      const files = params.files;
      const supplementaryFileNode = params.selectionState.node;
      let api = context.api;
      if (files.length > 0) {
        api._replaceSupplementaryFile(files[0], supplementaryFileNode);
      }
    }
  }

  class ReplaceSupplementaryFileTool extends UploadTool {
    getClassNames () {
      return 'sc-replace-supplementary-file-tool sc-upload-tool sc-tool'
    }
    get doesAcceptAllFileTypes () {
      return true
    }

    get canUploadMultiple () {
      return false
    }
  }

  class BasicCustomMetadataFieldCommand extends substance.Command {
    get contextType () {
      return 'custom-metadata-field'
    }

    getCommandState (params, context) {
      return {
        disabled: this.isDisabled(params, context)
      }
    }

    isDisabled (params) {
      const xpath = params.selectionState.xpath;
      return !xpath.find(n => n.type === this.contextType)
    }

    _getCollectionPath (params, context) {
      const doc = params.editorSession.getDocument();
      const nodeId = params.selection.getNodeId();
      const node = doc.get(nodeId);
      let figurePanelId = node.id;
      if (params.selection.type === 'node' && this.contextType === 'figure') {
        const currentIndex = node.getCurrentPanelIndex();
        figurePanelId = node.panels[currentIndex];
      } else if (node.type !== 'figure-panel') {
        const parentFigurePanel = findParentByType(node, 'figure-panel');
        figurePanelId = parentFigurePanel.id;
      }
      return [figurePanelId, 'metadata']
    }
  }

  class AddCustomMetadataFieldCommand extends BasicCustomMetadataFieldCommand {
    get contextType () {
      return 'figure'
    }

    execute (params, context) {
      const collectionPath = this._getCollectionPath(params, context);
      context.editorSession.transaction(tx => {
        let node = substance.documentHelpers.createNodeFromJson(tx, CustomMetadataField.getTemplate());
        substance.documentHelpers.append(tx, collectionPath, node.id);
        const path = [node.id, 'name'];
        const viewName = context.appState.viewName;
        const surfaceId = context.api._getSurfaceId(node, path, viewName);
        tx.setSelection({
          type: 'property',
          path,
          surfaceId,
          startOffset: 0
        });
      });
    }
  }

  class RemoveCustomMetadataFieldCommand extends BasicCustomMetadataFieldCommand {
    execute (params, context) {
      const collectionPath = this._getCollectionPath(params, context);
      context.editorSession.transaction(tx => {
        const nodeId = tx.selection.getNodeId();
        substance.documentHelpers.remove(tx, collectionPath, nodeId);
        tx.selection = null;
      });
    }
  }

  class MoveCustomMetadataFieldCommand extends BasicCustomMetadataFieldCommand {
    execute (params, context) {
      const direction = this.config.direction;
      const collectionPath = this._getCollectionPath(params, context);
      const nodeId = params.selection.getNodeId();
      const doc = context.editorSession.getDocument();
      const customField = doc.get(nodeId);
      const shift = direction === 'up' ? -1 : 1;
      context.api._moveChild(collectionPath, customField, shift);
    }

    isDisabled (params, context) {
      const matchSelection = !super.isDisabled(params);
      if (matchSelection) {
        const direction = this.config.direction;
        const collectionPath = this._getCollectionPath(params, context);
        const nodeId = params.selection.getNodeId();
        const doc = context.editorSession.getDocument();
        const customFieldsIndex = doc.get(collectionPath);
        const currentIndex = customFieldsIndex.indexOf(nodeId);
        if (customFieldsIndex.length > 0) {
          if ((direction === 'up' && currentIndex > 0) || (direction === 'down' && currentIndex < customFieldsIndex.length - 1)) {
            return false
          }
        }
      }
      return true
    }
  }

  class SwitchViewCommand extends substance.Command {
    getCommandState (params, context) {
      let state = context.appState;
      if (!state) {
        return substance.Command.DISABLED
      }
      let viewName = state.viewName;
      let active = (viewName === this.config.viewName);
      return {
        disabled: false,
        active
      }
    }

    execute (params, context) {
      // Note: switch from using app state to simple action
      // because we do not yet have a good way to 'inherit' app state
      // i.e. the correct app state would be that of ArticlePanel, but
      // here we have ManuscriptEditor or MetadataEditor
      if (context.editor) {
        context.editor.send('updateViewName', this.config.viewName);
      }
    }
  }

  /* eslint-disable no-template-curly-in-string */

  var EditorPackage = {
    name: 'ManuscriptEditor',
    configure (config) {
      config.import(BasePackage);
      config.import(EditorBasePackage);
      config.import(ModelComponentPackage);
      config.import(ManuscriptContentPackage);
      config.import(substance.MultiSelectPackage);
      config.import(EntityLabelsPackage);
      config.import(ArticleToolbarPackage);
      config.import(PersistencePackage);
      config.import(FindAndReplacePackage);

      // EXPERIMENTAL:
      // a CommandManager that uses the xmlSchema to inhibit commands
      // which would generate disallowed content
      config.setCommandManagerClass(substance.SchemaDrivenCommandManager);

      config.addComponent('add-supplementary-file', AddSupplementaryFileWorkflow);
      config.addComponent('figure', FigureComponent, true);
      config.addComponent('figure-panel', FigurePanelComponent, true);
      config.addComponent('table-figure', TableFigureComponent, true);
      config.addComponent('footnote', FootnoteComponent, true);
      config.addComponent('reference', ReferenceComponent, true);
      config.addComponent('reference-list', ReferenceListComponent, true);
      config.addComponent('toc', ManuscriptTOC, true);

      config.addCommand('add-metadata-field', AddCustomMetadataFieldCommand, {
        commandGroup: 'custom-metadata-fields'
      });
      config.addCommand('add-figure-panel', AddFigurePanelCommand, {
        commandGroup: 'figure-panel'
      });
      config.addCommand('create-external-link', InsertExtLinkCommand, {
        nodeType: 'external-link',
        accelerator: 'CommandOrControl+K',
        commandGroup: 'formatting'
      });
      config.addCommand('decrease-heading-level', DecreaseHeadingLevelCommand, {
        commandGroup: 'text-level'
      });
      config.addCommand('dedent-list', substance.ListPackage.IndentListCommand, {
        spec: { action: 'dedent' },
        commandGroup: 'list'
      });
      config.addCommand('delete-columns', DeleteCellsCommand, {
        spec: { dim: 'col' },
        commandGroup: 'table-delete'
      });
      config.addCommand('delete-rows', DeleteCellsCommand, {
        spec: { dim: 'row' },
        commandGroup: 'table-delete'
      });
      config.addCommand('download-file', DownloadSupplementaryFileCommand, {
        commandGroup: 'file'
      });
      config.addCommand('edit-author', EditEntityCommand, {
        selectionType: 'author',
        commandGroup: 'author'
      });
      config.addCommand('edit-block-formula', EditBlockFormulaCommand, {
        commandGroup: 'prompt'
      });
      config.addCommand('edit-external-link', substance.EditAnnotationCommand, {
        nodeType: 'external-link',
        commandGroup: 'prompt'
      });
      config.addCommand('edit-formula', EditInlineFormulaCommand, {
        nodeType: 'inline-formula',
        commandGroup: 'prompt'
      });
      config.addCommand('edit-reference', EditEntityCommand, {
        selectionType: 'reference',
        commandGroup: 'reference'
      });
      config.addCommand('edit-xref', EditXrefCommand, {
        nodeType: 'xref',
        commandGroup: 'prompt'
      });
      config.addCommand('increase-heading-level', IncreaseHeadingLevelCommand, {
        commandGroup: 'text-level'
      });
      config.addCommand('indent-list', substance.ListPackage.IndentListCommand, {
        spec: { action: 'indent' },
        commandGroup: 'list'
      });
      config.addCommand('insert-block-formula', InsertDispFormulaCommand, {
        nodeType: 'block-formula',
        commandGroup: 'insert'
      });
      config.addCommand('insert-block-quote', InsertBlockQuoteCommand, {
        nodeType: 'block-quote',
        commandGroup: 'insert'
      });
      config.addCommand('insert-columns-left', InsertCellsCommand, {
        spec: { dim: 'col', pos: 'left' },
        commandGroup: 'table-insert'
      });
      config.addCommand('insert-columns-right', InsertCellsCommand, {
        spec: { dim: 'col', pos: 'right' },
        commandGroup: 'table-insert'
      });
      config.addCommand('insert-figure', InsertFigureCommand, {
        nodeType: 'figure',
        commandGroup: 'insert'
      });
      config.addCommand('insert-file', InsertNodeFromWorkflowCommand, {
        workflow: 'add-supplementary-file',
        nodeType: 'supplementary-file',
        commandGroup: 'insert'
      });
      config.addCommand('insert-footnote', InsertFootnoteCommand, {
        commandGroup: 'insert'
      });
      config.addCommand('insert-inline-formula', InsertInlineFormulaCommand, {
        commandGroup: 'insert'
      });
      config.addCommand('insert-inline-graphic', InsertInlineGraphicCommand, {
        nodeType: 'inline-graphic',
        commandGroup: 'insert'
      });
      config.addCommand('insert-rows-above', InsertCellsCommand, {
        spec: { dim: 'row', pos: 'above' },
        commandGroup: 'table-insert'
      });
      config.addCommand('insert-rows-below', InsertCellsCommand, {
        spec: { dim: 'row', pos: 'below' },
        commandGroup: 'table-insert'
      });
      config.addCommand('insert-table', InsertTableCommand, {
        nodeType: 'table-figure',
        commandGroup: 'insert'
      });
      config.addCommand('insert-xref-bibr', InsertCrossReferenceCommand, {
        refType: 'bibr',
        commandGroup: 'insert-xref'
      });
      config.addCommand('insert-xref-figure', InsertCrossReferenceCommand, {
        refType: 'fig',
        commandGroup: 'insert-xref'
      });
      config.addCommand('insert-xref-file', InsertCrossReferenceCommand, {
        refType: 'file',
        commandGroup: 'insert-xref'
      });
      // Note: footnote cross-references are special, because they take the current scope into account
      // i.e. whether to create a footnote on article level, or inside a table-figure
      config.addCommand('insert-xref-footnote', InsertFootnoteCrossReferenceCommand, {
        commandGroup: 'insert-xref'
      });
      config.addCommand('insert-xref-formula', InsertCrossReferenceCommand, {
        refType: BlockFormula.refType,
        commandGroup: 'insert-xref'
      });
      config.addCommand('insert-xref-table', InsertCrossReferenceCommand, {
        refType: 'table',
        commandGroup: 'insert-xref'
      });
      config.addCommand('move-down-metadata-field', MoveCustomMetadataFieldCommand, {
        direction: 'down',
        commandGroup: 'custom-metadata-fields'
      });
      config.addCommand('move-down-figure-panel', MoveFigurePanelCommand, {
        direction: 'down',
        commandGroup: 'figure-panel'
      });
      config.addCommand('move-up-metadata-field', MoveCustomMetadataFieldCommand, {
        direction: 'up',
        commandGroup: 'custom-metadata-fields'
      });
      config.addCommand('move-up-figure-panel', MoveFigurePanelCommand, {
        direction: 'up',
        commandGroup: 'figure-panel'
      });
      config.addCommand('open-figure-panel-image', OpenFigurePanelImageCommand, {
        commandGroup: 'figure-panel'
      });
      config.addCommand('open-manuscript', SwitchViewCommand, {
        viewName: 'manuscript',
        commandGroup: 'switch-view'
      });
      config.addCommand('open-metadata', SwitchViewCommand, {
        viewName: 'metadata',
        commandGroup: 'switch-view'
      });
      config.addCommand('remove-metadata-field', RemoveCustomMetadataFieldCommand, {
        commandGroup: 'custom-metadata-fields'
      });
      config.addCommand('remove-figure-panel', RemoveFigurePanelCommand, {
        commandGroup: 'figure-panel'
      });
      config.addCommand('remove-footnote', RemoveItemCommand, {
        nodeType: 'footnote',
        commandGroup: 'footnote'
      });
      config.addCommand('replace-figure-panel-image', ReplaceFigurePanelImageCommand, {
        commandGroup: 'figure-panel'
      });
      config.addCommand('replace-file', ReplaceSupplementaryFileCommand, {
        commandGroup: 'file'
      });
      config.addCommand('table:select-all', TableSelectAllCommand);
      config.addCommand('toggle-bold', substance.AnnotationCommand, {
        nodeType: 'bold',
        accelerator: 'CommandOrControl+B',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-cell-heading', ToggleCellHeadingCommand, {
        commandGroup: 'table'
      });
      config.addCommand('toggle-cell-merge', ToggleCellMergeCommand, {
        commandGroup: 'table'
      });
      config.addCommand('toggle-italic', substance.AnnotationCommand, {
        nodeType: 'italic',
        accelerator: 'CommandOrControl+I',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-monospace', substance.AnnotationCommand, {
        nodeType: 'monospace',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-ordered-list', ChangeListTypeCommand, {
        spec: { listType: 'order' },
        commandGroup: 'list'
      });
      config.addCommand('toggle-overline', substance.AnnotationCommand, {
        nodeType: 'overline',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-small-caps', substance.AnnotationCommand, {
        nodeType: 'small-caps',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-strike-through', substance.AnnotationCommand, {
        nodeType: 'strike-through',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-subscript', substance.AnnotationCommand, {
        nodeType: 'subscript',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-superscript', substance.AnnotationCommand, {
        nodeType: 'superscript',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-underline', substance.AnnotationCommand, {
        nodeType: 'underline',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-unordered-list', ChangeListTypeCommand, {
        spec: { listType: 'bullet' },
        commandGroup: 'list'
      });

      // Labels
      config.addLabel('add-ref', 'Add Reference');
      config.addLabel('article-info', 'Article Information');
      config.addLabel('article-record', 'Article Record');
      config.addLabel('contributors', 'Authors & Contributors');
      config.addLabel('create-unordered-list', 'Bulleted list');
      config.addLabel('create-ordered-list', 'Numbered list');
      config.addLabel('edit-ref', 'Edit Reference');
      config.addLabel('file-location', 'File location');
      config.addLabel('file-name', 'File name');
      config.addLabel('manuscript-start', 'Article starts here');
      config.addLabel('manuscript-end', 'Article ends here');
      config.addLabel('no-authors', 'No Authors');
      config.addLabel('no-editors', 'No Editors');
      config.addLabel('no-references', 'No References');
      config.addLabel('no-footnotes', 'No Footnotes');
      config.addLabel('open-link', 'Open Link');
      config.addLabel('pub-data', 'Publication Data');
      config.addLabel('sig-block-start', 'Signature Block starts here');
      config.addLabel('sig-block-end', 'Signature Block ends here');
      config.addLabel('structure', 'Structure');
      config.addLabel('toc', 'Table of Contents');
      config.addLabel('translations', 'Translations');
      config.addLabel('edit-ref', 'Edit');
      config.addLabel('remove-ref', 'Remove');
      config.addLabel('toggle-unordered-list', 'Bulleted list');
      config.addLabel('toggle-ordered-list', 'Numbered list');
      config.addLabel('enter-custom-field-name', 'Enter name');
      config.addLabel('enter-custom-field-value', 'Enter value');
      config.addLabel('add-action', 'Add');
      config.addLabel('enter-url-placeholder', 'Enter url');

      // Icons
      config.addIcon('create-unordered-list', { 'fontawesome': 'fa-list-ul' });
      config.addIcon('create-ordered-list', { 'fontawesome': 'fa-list-ol' });
      config.addIcon('open-link', { 'fontawesome': 'fa-external-link' });
      config.addIcon('pencil', { 'fontawesome': 'fa-pencil' });
      config.addIcon('toggle-unordered-list', { 'fontawesome': 'fa-list-ul' });
      config.addIcon('toggle-ordered-list', { 'fontawesome': 'fa-list-ol' });
      config.addIcon('trash', { 'fontawesome': 'fa-trash' });
      config.addIcon('input-loading', { 'fontawesome': 'fa-spinner fa-spin' });
      config.addIcon('input-error', { 'fontawesome': 'fa-exclamation-circle' });
      config.addIcon('left-control', { 'fontawesome': 'fa-chevron-left' });
      config.addIcon('right-control', { 'fontawesome': 'fa-chevron-right' });

      // Tools
      config.addComponent('add-figure-panel', InsertFigurePanelTool);
      config.addComponent('download-file', DownloadSupplementaryFileTool);
      config.addComponent('edit-block-formula', EditDispFormulaTool);
      config.addComponent('edit-external-link', EditExtLinkTool);
      config.addComponent('edit-formula', EditInlineFormulaTool);
      config.addComponent('edit-xref', EditXRefTool);
      config.addComponent('insert-figure', InsertFigureTool);
      config.addComponent('insert-inline-graphic', InsertInlineGraphicTool);
      config.addComponent('open-figure-panel-image', OpenFigurePanelImageTool);
      config.addComponent('replace-figure-panel-image', ReplaceFigurePanelTool);
      config.addComponent('replace-file', ReplaceSupplementaryFileTool);
      config.addComponent('insert-table', InsertTableTool);

      // DropDownHandler
      config.addDropHandler(DropFigure);

      // SwitchTextTypes
      config.addTextTypeTool({
        name: 'switch-to-heading1',
        commandGroup: 'text-types',
        nodeSpec: {
          type: 'heading',
          level: 1
        },
        icon: 'fa-header',
        label: 'Heading 1',
        accelerator: 'CommandOrControl+Alt+1'
      });
      config.addTextTypeTool({
        name: 'switch-to-heading2',
        commandGroup: 'text-types',
        nodeSpec: {
          type: 'heading',
          level: 2
        },
        icon: 'fa-header',
        label: 'Heading 2',
        accelerator: 'CommandOrControl+Alt+2'
      });
      config.addTextTypeTool({
        name: 'switch-to-heading3',
        commandGroup: 'text-types',
        nodeSpec: {
          type: 'heading',
          level: 3
        },
        icon: 'fa-header',
        label: 'Heading 3',
        accelerator: 'CommandOrControl+Alt+3'
      });
      config.addTextTypeTool({
        name: 'switch-to-paragraph',
        commandGroup: 'text-types',
        nodeSpec: {
          type: 'paragraph'
        },
        icon: 'fa-paragraph',
        label: 'Paragraph',
        accelerator: 'CommandOrControl+Alt+0'
      });
      config.addCommand('create-unordered-list', CreateListCommand, {
        spec: { listType: 'bullet' },
        commandGroup: 'text-types'
      });
      config.addCommand('create-ordered-list', CreateListCommand, {
        spec: { listType: 'order' },
        commandGroup: 'text-types'
      });
      config.addTextTypeTool({
        name: 'switch-to-preformat',
        commandGroup: 'text-types',
        nodeSpec: {
          type: 'preformat'
        },
        icon: 'fa-font',
        label: 'Preformat',
        accelerator: 'CommandOrControl+E'
      });

      // Toolpanels
      config.addToolPanel('main-overlay', [
        {
          name: 'prompt',
          type: 'prompt',
          style: 'minimal',
          hideDisabled: true,
          items: [
            { type: 'command-group', name: 'prompt' }
          ]
        }
      ]);

      config.addToolPanel('workflow', [
        {
          name: 'workflow',
          type: 'group',
          items: [
            { type: 'command-group', name: 'workflows' }
          ]
        }
      ]);

      // KeyboardShortcuts
      config.addKeyboardShortcut('shift+tab', { command: 'decrease-heading-level' });
      config.addKeyboardShortcut('tab', { command: 'increase-heading-level' });
      config.addKeyboardShortcut('CommandOrControl+a', { command: 'table:select-all' });

      // Register commands and keyboard shortcuts for collections
      registerCollectionCommand(config, 'author', ['metadata', 'authors'], { keyboardShortcut: 'CommandOrControl+Alt+A', nodeType: 'person' });
      registerCollectionCommand(config, 'funder', ['metadata', 'funders'], { keyboardShortcut: 'CommandOrControl+Alt+Y' });
      registerCollectionCommand(config, 'editor', ['metadata', 'editors'], { keyboardShortcut: 'CommandOrControl+Alt+E', nodeType: 'person' });
      registerCollectionCommand(config, 'group', ['metadata', 'groups'], { keyboardShortcut: 'CommandOrControl+Alt+G' });
      registerCollectionCommand(config, 'keyword', ['metadata', 'keywords'], { keyboardShortcut: 'CommandOrControl+Alt+K' });
      registerCollectionCommand(config, 'organisation', ['metadata', 'organisations'], { keyboardShortcut: 'CommandOrControl+Alt+O' });
      registerCollectionCommand(config, 'subject', ['metadata', 'subjects']);
    },
    ManuscriptEditor,
    // legacy
    Editor: ManuscriptEditor
  }

  // For now we just switch view and do the same action as in metadata editor
  // TODO: later we will probably have just one set of commands for register collection
  function registerCollectionCommand (config, itemType, collectionPath, options = {}) {
    let nodeType = options.nodeType || itemType;
    config.addCommand(`insert-${itemType}`, AddEntityCommand, {
      type: nodeType,
      collection: collectionPath,
      commandGroup: 'add-entity',
      metadataOnly: true
    });
    if (options.keyboardShortcut) {
      config.addKeyboardShortcut(options.keyboardShortcut, { command: `add-${itemType}` });
    }
  }

  class SaveHandler {
    constructor (context) {
      this.context = context;
    }

    saveDocument ({ editorSession }) {
      return new Promise((resolve) => {
        let exporter = this.context.exporter;
        let doc = editorSession.getDocument();
        let dom = doc.toXML();
        let result = exporter.export(dom);
        if (result.hasErrored) {
          console.error(result.errors);
          throw new Error('Could not export JATS document')
        }
        console.info(result.dom.getNativeElement());
        // let xml = result.dom.serialize()
        resolve();
      })
    }
  }

  class FigureLabelGenerator {
    constructor (config = {}) {
      /*
        - name: type name as in 'Figure'
        - plural: type name in plural as in 'Figures'
        - and: string used to join groups, such as ', '
        - to: conjunction in groups such as '-' in 'Figure 1-3'
      */
      this.config = Object.assign({
        singular: 'Figure $',
        plural: 'Figures $',
        join: ', ',
        and: ', and ',
        to: '‒',
        invalid: '???'
      }, config);
    }

    getLabel (...defs) {
      if (defs.length === 0) return this.config.invalid
      // Note: normalizing args so that every def is a tuple
      defs = defs.map(d => {
        if (!substance.isArray(d)) return [d]
        else return d
      });
      if (defs.length === 1) return this.getSingleLabel(defs[0])
      return this.getCombinedLabel(defs)
    }

    getSingleLabel (def) {
      if (!def) return this.config.invalid
      return this._replaceAll(this.config.singular, this._getSingleCounter(def))
    }

    getCombinedLabel (defs) {
      if (defs.length < 2) return this.getSingleLabel(defs[0])

      // sort the records
      defs.sort((a, b) => {
        let a1 = a[0].pos;
        let b1 = b[0].pos;
        if (a1 < b1) return -1
        if (a1 > b1) return 1
        // TODO: here we will need to sort by the panel type
        return a[1].pos - b[1].pos
      });
      // do a segmentation
      let group = [defs[0]];
      let groups = [];
      for (let idx = 0; idx < defs.length; idx++) {
        if (idx === 0) continue
        // a sequence is stopped when
        // - an item has a different level than the previous one
        // - an item on the first level has pos larger than +1 of the previous one
        // - an item on the second level has different type, or a pos larger +1 of the previous one
        let def = defs[idx];
        let prev = defs[idx - 1];
        if (
          (prev.length !== def.length) ||
          (def.length === 1 && def[0].pos > prev[0].pos + 1) ||
          (def.length === 2 && (def[1].type !== prev[1].type || def[0].pos !== prev[0].pos || def[1].pos > prev[1].pos + 1))
        ) {
          groups.push(group);
          group = [def];
        } else {
          group.push(def);
        }
      }
      groups.push(group);

      // and finally compute a label for each group
      let fragments = [];
      for (let group of groups) {
        if (group.length === 1) {
          fragments.push(this._getSingleCounter(group[0]));
        } else {
          fragments.push(this._getGroupCounter(group[0], substance.last(group)));
        }
      }

      // join the fragments
      let combined;
      if (fragments.length > 1) {
        combined = fragments.slice(0, fragments.length - 1).join(this.config.join) + this.config.and + substance.last(fragments);
      } else {
        combined = fragments[0];
      }

      // and return a combined label
      return this._replaceAll(this.config.plural, combined)
    }

    _getSingleCounter (def) {
      if (def.length === 1) {
        return String(def[0].pos)
      } else {
        let figCounter = def[0].pos;
        // TODO: we should think about some way to make this configurable
        return `${figCounter}${this._getPanelLabel(def)}`
      }
    }

    _getPanelLabel (def) {
      let panelCounter = def[1].pos;
      return `${LATIN_LETTERS_UPPER_CASE[panelCounter - 1]}`
    }

    _getGroupCounter (first, last) {
      // ATTENTION: assuming that first and last have the same level (according to our implementation)
      if (first.length === 1) {
        return `${this._getSingleCounter(first)}${this.config.to}${this._getSingleCounter(last)}`
      } else {
        return `${this._getSingleCounter(first)}${this.config.to}${this._getPanelLabel(last)}`
      }
    }

    _replaceAll (t, $) {
      return t.slice(0).replace(/[$]/g, $)
    }
  }

  class AbstractCitationManager {
    constructor (documentSession, refType, targetTypes, labelGenerator) {
      this.documentSession = documentSession;
      this.refType = refType;
      this.targetTypes = new Set(targetTypes);
      this.labelGenerator = labelGenerator;

      documentSession.on('change', this._onDocumentChange, this);
    }

    dispose () {
      this.documentSession.off(this);
    }

    hasCitables () {
      return this.getCitables().length > 0
    }

    getCitables () {
      return []
    }

    getSortedCitables () {
      return this.getCitables().sort((a, b) => {
        return getPos(a) - getPos(b)
      })
    }

    // TODO: how could this be generalized so that it is less dependent on the internal model?
    _onDocumentChange (change) {
      // HACK: do not react on node state updates
      if (change.info.action === 'node-state-update') return

      const ops = change.ops;
      for (var i = 0; i < ops.length; i++) {
        let op = ops[i];
        if (op.isNOP()) continue
        // 1. xref has been added or removed
        // 2. citable has been add or removed
        if (this._detectAddRemoveXref(op) || this._detectAddRemoveCitable(op, change)) {
          return this._updateLabels()
        // 3. xref targets have been changed
        // 4. refType of an xref has been changed (TODO: do we really need this?)
        } else if (this._detectChangeRefTarget(op) || this._detectChangeRefType(op)) {
          return this._updateLabels()
        }
      }
    }

    _detectAddRemoveXref (op) {
      return (op.val && op.val.type === 'xref' && op.val.refType === this.refType)
    }

    _detectAddRemoveCitable (op, change) {
      return (op.val && this.targetTypes.has(op.val.type))
    }

    _detectChangeRefTarget (op) {
      if (op.path[1] === 'refTargets') {
        let doc = this._getDocument();
        let node = doc.get(op.path[0]);
        return (node && node.refType === this.refType)
      } else {
        return false
      }
    }

    _detectChangeRefType (op) {
      return (op.path[1] === 'refType' && (op.val === this.refType || op.original === this.refType))
    }

    /*
      Label of bibliographic entries are determined
      by the order of their citations in the document.
      I.e. typically you pick all citations (`<xref>`) as they
      occur in the document, and provide the ids of the entries
      they refer to. This forms a list of tuples, such as:
      ```
        [
          { id: 'cite1', refs: [AB06, Mac10] },
          { id: 'cite2', refs: [FW15] },
          { id: 'cite3', refs: [Mac10, AB06, AB07] }
        ]
      ```

      @param {Array<Object>} a list of citation entries.
    */
    _updateLabels (silent) {
      let xrefs = this._getXrefs();
      let refs = this.getCitables();
      let refsById = refs.reduce((m, ref) => {
        m[ref.id] = ref;
        return m
      }, {});

      let stateUpdates = [];

      let pos = 1;
      let order = {};
      let refLabels = {};
      let xrefLabels = {};
      xrefs.forEach((xref) => {
        let isInvalid = false;
        let numbers = [];
        let targetIds = xref.refTargets;
        for (let id of targetIds) {
          // fail if there is an unknown id
          if (!refsById[id]) {
            isInvalid = true;
            continue
          }
          if (!order.hasOwnProperty(id)) {
            order[id] = pos;
            refLabels[id] = this.labelGenerator.getLabel(pos);
            pos++;
          }
          numbers.push(order[id]);
        }
        // invalid labels shall be the same as empty ones
        if (isInvalid) {
          // HACK: we just signal invalid references with a ?
          numbers.push('?');
          console.warn(`invalid label detected for ${xref.id}`);
        }
        xrefLabels[xref.id] = this.labelGenerator.getLabel(numbers);
      });

      // HACK
      // Now update the node state of all affected xref[ref-type='bibr']
      // TODO: solve this properly
      xrefs.forEach(xref => {
        const label = xrefLabels[xref.id];
        const state = { label };
        stateUpdates.push([xref.id, state]);
      });
      refs.forEach((ref, index) => {
        const label = refLabels[ref.id] || '';
        const state = { label };
        if (order[ref.id]) {
          state.pos = order[ref.id];
        } else {
          state.pos = pos + index;
        }
        stateUpdates.push([ref.id, state]);
      });

      // FIXME: here we also made the 'collection' dirty originally

      this.documentSession.updateNodeStates(stateUpdates, { silent });
    }

    _getDocument () {
      return this.documentSession.getDocument()
    }

    _getXrefs () {
      // TODO: is it really a good idea to tie this implementation to 'article' here?
      const article = this._getDocument().get('article');
      let refs = article.findAll(`xref[refType='${this.refType}']`);
      return refs
    }

    _getLabelGenerator () {
      return this.labelGenerator
    }
  }

  /*
    A base class for FigureManager and TableManager. In contrast to citables like references or footnotes,
    the citable content is part of the content itself, and has a fixed order defined by the occurrence in the document.
    E.g. a reference is sorted and labeled according to the order of citations, but a figure is labeled according
    to the occurence in the content.
  */
  class CitableContentManager extends AbstractCitationManager {
    hasCitables () {
      return Boolean(this._getContentElement().find(this._getItemSelector()))
    }

    getCitables () {
      return this._getContentElement().findAll(this._getItemSelector())
    }

    getSortedCitables () {
      return this.getCitables()
    }

    _getItemSelector () {
      return XREF_TARGET_TYPES[this.refType].join(',')
    }

    _getXrefs () {
      return this._getDocument().findAll(`xref[refType='${this.refType}']`)
    }

    _detectAddRemoveCitable (op, change) {
      if (op.isUpdate()) {
        const contentPath = this._getContentPath();
        if (substance.isArrayEqual(op.path, contentPath)) {
          const doc = this._getDocument();
          let id = op.diff.val;
          let node = doc.get(id) || change.hasDeleted(id);
          return (node && this.targetTypes.has(node.type))
        }
      }
      return false
    }

    _getContentPath () {
      return this._getContentElement().getContentPath()
    }

    _getContentElement () {
      return this._getDocument().get('body')
    }

    _updateLabels (silent) {
      let targetUpdates = this._computeTargetUpdates();
      let xrefUpdates = this._computeXrefUpdates(targetUpdates);
      let stateUpdates = substance.map(targetUpdates, this._stateUpdate).concat(substance.map(xrefUpdates, this._stateUpdate));
      // HACK: do not propagate change initially
      this.documentSession.updateNodeStates(stateUpdates, { silent });
    }

    _stateUpdate (record) {
      return [record.id, { label: record.label }]
    }

    _computeTargetUpdates () {
      let resources = this.getCitables();
      let pos = 1;
      let targetUpdates = {};
      for (let res of resources) {
        let id = res.id;
        let label = this.labelGenerator.getLabel([pos]);
        // Note: pos is needed to create order specific labels
        targetUpdates[id] = { id, label, pos };
        pos++;
      }
      return targetUpdates
    }

    _computeXrefUpdates (targetUpdates) {
      const targetIds = new Set(Object.keys(targetUpdates));
      let xrefs = this._getXrefs();
      let xrefUpdates = {};
      for (let xref of xrefs) {
        // ATTENTION: this might not always be numbers, but could also be something like this: [{pos: 1}, {pos: 2}]
        // if citables are nested
        // TODO: find a better name
        let numbers = [];
        // NOTE: if there are rids that can not be resolved as a valid target these will be ignored
        // TODO: in future there should be a IssueManager checking for the validity of these refs
        for (let targetId of xref.refTargets) {
          if (targetIds.has(targetId)) {
            numbers.push(targetUpdates[targetId].pos);
          }
        }
        // invalid labels shall be the same as empty ones
        let id = xref.id;
        let label = this.labelGenerator.getCombinedLabel(numbers);
        xrefUpdates[id] = { id, label };
      }
      return xrefUpdates
    }
  }

  class FigureManager extends CitableContentManager {
    constructor (documentSession, config) {
      super(documentSession, 'fig', ['figure-panel'], new FigureLabelGenerator(config));
      this._updateLabels('initial');
    }

    _detectAddRemoveCitable (op, change) {
      // in addition to figure add/remove the labels are affected when panels are added/removed or reordered
      return super._detectAddRemoveCitable(op, change) || (op.val && op.val.type === 'figure-panel') || (op.path && op.path[1] === 'panels')
    }

    _getItemSelector () {
      return 'figure-panel'
    }

    _computeTargetUpdates () {
      let doc = this._getDocument();
      let figures = this._getContentElement().findAll('figure');
      let records = {};
      // Iterate through all figures and their panels
      // and generate a record for every item that should be updated
      // leave any information necessary to control the label generator
      let figureCounter = 1;
      for (let figure of figures) {
        let id = figure.id;
        let pos = [{ pos: figureCounter }];
        let label = this.labelGenerator.getSingleLabel(pos);
        records[id] = { id, pos, label };
        // ATTENTION: ATM we do not support any special label generation, such as Figure 1-figure supplement 2, which is controlled via attributes (@specific-use)
        // TODO: to support eLife's 'Figure Supplement' labeling scheme we would use a different counter and some type of encoding
        // e.g. [1, { pos: 1, type: 'supplement' }], we would then
        let panels = substance.documentHelpers.getNodesForIds(doc, figure.panels);
        let panelCounter = 1;
        // processing sub-figures
        if (panels.length > 1) {
          for (let panel of panels) {
            let id = panel.id;
            let pos = [{ pos: figureCounter }, { pos: panelCounter, type: 'default' }];
            let label = this.labelGenerator.getSingleLabel(pos);
            records[id] = { id, pos, label };
            panelCounter++;
          }
        // edge-case: figure-groups with just a single panel get a simple label
        } else {
          let panel = panels[0];
          let id = panel.id;
          let pos = [{ pos: figureCounter }];
          let label = this.labelGenerator.getSingleLabel(pos);
          records[id] = { id, pos, label };
        }
        figureCounter++;
      }
      return records
    }
  }

  class FootnoteManager extends AbstractCitationManager {
    constructor (documentSession, labelGenerator) {
      super(documentSession, 'fn', ['footnote'], labelGenerator);
      // compute initial labels
      this._updateLabels('initial');
    }

    getCitables () {
      let doc = this._getDocument();
      return substance.documentHelpers.getNodesForPath(doc, ['article', 'footnotes'])
    }
  }

  /*
    TODO: discuss

    There is a sophisticated cross-referencing package for latex
    that we took as inspiration: http://mirror.easyname.at/ctan/macros/latex/contrib/cleveref/cleveref.pdf

    This generator needs a set of configurations:

    - name: e.g. 'Figure'
    - plural: e.g. 'Figures'
    - and: e.g, ", ", or " and "
    - to: e.g, "--", or " to "
    - template: outer template, e.g. "[$]" could be used to generate "[1-3,4]"
    - groupTemplate: inner template, e.g. "[$]" could be used to generate "[1-3],[4]"

  */
  const HYPHEN = '‒';

  class NumberedLabelGenerator {
    constructor (config = {}) {
      // for labels with a type name such as 'Figure 1'
      this.name = config.name;
      // for labels with type name, with multiple refs, such as 'Figures 1-3'
      this.plural = config.plural;
      // used to join found groups
      this.and = config.and || ',';
      // used to render a single group
      this.to = config.to || HYPHEN;
      // a string where '$' will be replaced
      // this can be used to wrap the generated string,
      // e.g. "[$]" could be used to generate "[1-3,4]"
      this.template = config.template;
      // a string where '$' will be replaced
      // e.g "[$]" could be used to generate "[1-3],[4]"
      this.groupTemplate = config.groupTemplate;
      this.invalid = config.invalid || '???';
    }

    // TODO: consolidate label generator interface
    getLabel (numbers) {
      if (!numbers) return this.invalid
      if (!substance.isArray(numbers)) numbers = [numbers];
      return this.getCombinedLabel(numbers)
    }

    getCombinedLabel (numbers) {
      if (numbers.length === 0) return this.invalid

      const L = numbers.length;
      // ATTENTION: Array.sort() is sorting lexically!
      numbers.sort((a, b) => a - b);

      let frags = [];
      if (this.name) {
        if (L === 1) {
          frags.push(this.name);
        } else {
          frags.push(this.plural || this.name);
        }
        frags.push(' ');
      }

      // detect groups such as [1,2,3], [6], [8,9]
      let groups = [];
      let group = null;
      const _pushBlock = (g) => {
        if (!substance.isArray(g)) g = [g];
        let str;
        if (g.length === 1) {
          str = String(g[0]);
        } else if (g.length === 2) {
          _pushBlock(g[0]);
          _pushBlock(g[1]);
          return
        } else {
          // join with the 'to' operator, i.e. [1,2,3] => "1 to 3"
          str = String(g[0]) + this.to + String(substance.last(g));
        }
        if (this.groupTemplate) {
          str = this.groupTemplate.slice(0).replace(/[$]/g, str);
        }
        groups.push(str);
      };
      for (let i = 0; i < L; i++) {
        let n = numbers[i];
        if (n === numbers[i - 1] + 1) {
          group.push(n);
        } else {
          if (group) {
            _pushBlock(group);
          }
          group = [n];
        }
      }
      _pushBlock(group);

      // join all groups with the 'and' operator
      // such as ["1-3", "5"] => "1-3, 4"
      frags.push(groups.join(this.and));

      let res = frags.join('');
      if (this.template) {
        res = this.template.slice(0).replace(/[$]/g, res);
      }
      return res
    }
  }

  class ReferenceManager extends AbstractCitationManager {
    constructor (documentSession, config) {
      super(documentSession, 'bibr', ['reference'], new NumberedLabelGenerator(config));
      // compute initial labels
      this._updateLabels('initial');
    }

    getBibliography () {
      return this.getSortedCitables()
    }

    hasCitables () {
      let refIds = this._getRefIds();
      return refIds.length > 0
    }

    getCitables () {
      return substance.documentHelpers.getNodesForIds(this._getDocument(), this._getRefIds())
    }

    _getRefIds () {
      let doc = this._getDocument();
      let article = doc.get('article');
      return article.references
    }

    // overriding because 'reference' is just an abstract parent type
    _detectAddRemoveCitable (op, change) {
      if (op.isCreate() || op.isDelete()) {
        // TODO: it would be nice to have real node instances in change
        // to inspect the class/prototype
        let doc = this._getDocument();
        let schema = doc.getSchema();
        return schema.isInstanceOf(op.val.type, 'reference')
      } else {
        return false
      }
    }
  }

  const UNDEFINED = '?';

  class TableFootnoteManager extends AbstractCitationManager {
    constructor (documentSession, tableFigure) {
      super(documentSession, 'table-fn', ['fn'], new SymbolSetLabelGenerator(SYMBOLS));

      this.tableFigure = tableFigure;

      this._updateLabels('silent');
    }

    _getContentElement () {
      return this.tableFigure
    }

    hasCitables () {
      return (this.tableFigure.footnotes && this.tableFigure.footnotes.length > 0)
    }

    getCitables () {
      let doc = this._getDocument();
      let footnotes = this.tableFigure.footnotes;
      if (footnotes) {
        // NOTE: in case of table removing there might be already no footnotes
        // in the document, so we need to filter out undefined values
        // TODO: can we solve it differently?
        return footnotes.map(id => doc.get(id)).filter(Boolean)
      } else {
        return []
      }
    }

    _detectAddRemoveCitable (op, change) {
      const contentPath = [this.tableFigure.id, 'footnotes'];
      if (substance.isArrayEqual(op.path, contentPath)) {
        const doc = this._getDocument();
        let id = op.diff.val;
        let node = doc.get(id) || change.hasDeleted(id);
        return (node && this.targetTypes.has(node.type))
      } else {
        return false
      }
    }
  }

  class SymbolSetLabelGenerator {
    constructor (symbols) {
      this.symbols = Array.from(symbols);
    }

    getLabel (pos) {
      if (substance.isArray(pos)) {
        pos.sort((a, b) => a - b);
        return pos.map(p => this._getSymbolForPos(p)).join(', ')
      } else {
        return this._getSymbolForPos(pos)
      }
    }

    _getSymbolForPos (pos) {
      return this.symbols[pos - 1] || UNDEFINED
    }
  }

  class TableManager extends CitableContentManager {
    constructor (documentSession, labelGenerator) {
      super(documentSession, 'table', ['table-figure'], labelGenerator);

      this._updateLabels('initial');

      this._initializeTableFootnoteManagers();
    }

    // EXPERIMENTAL:
    // watching changes and creating a TableFootnoteManager whenever a TableFigure is created
    // We should find a better location, or think about a framework to register such managers in general
    // TableManager does actually not have anything to do with table footnotes.
    _onDocumentChange (change) {
      super._onDocumentChange(change);
      this._checkForNewTableFigures(change);
    }

    // EXPERIMENTAL:
    // ... managers should have hooks to do such stuff
    _initializeTableFootnoteManagers () {
      let doc = this._getDocument();
      let tableFigures = doc.getIndex('type').get('table-figure');
      substance.forEach(tableFigures, tableFigure => {
        tableFigure.setFootnoteManager(new TableFootnoteManager(this.documentSession, tableFigure));
      });
    }

    _checkForNewTableFigures (change) {
      let doc = this._getDocument();
      // whenever a table-figure is created we attach a TableFootnoteManager
      for (let op of change.ops) {
        if (op.isCreate()) {
          let node = doc.get(op.getValue().id);
          if (node && node.type === 'table-figure') {
            node.setFootnoteManager(new TableFootnoteManager(this.documentSession, node));
          }
        }
      }
    }
  }

  function updateEntityChildArray (tx, nodeId, tagName, attribute, oldEntityIds, newEntityIds) {
    let node = tx.get(nodeId);
    let addedEntityIds = substance.without(newEntityIds, ...oldEntityIds);
    let removedEntityIds = substance.without(oldEntityIds, ...newEntityIds);

    // Remove old entities
    removedEntityIds.forEach(entityId => {
      let entityRefNode = node.find(`${tagName}[${attribute}=${entityId}]`);
      node.removeChild(entityRefNode);
      // Remove it completely
      tx.delete(entityRefNode.id);
    });

    // Create new entities
    addedEntityIds.forEach(entityId => {
      let entityRefNode = node.find(`${tagName}[${attribute}=${entityId}]`);
      if (!entityRefNode) {
        let opts = {};
        if (attribute === 'id') {
          opts = { id: entityId };
        }
        entityRefNode = tx.createElement(tagName, opts);
        if (attribute !== 'id') {
          entityRefNode.setAttribute(attribute, entityId);
        }
      }
      node.appendChild(entityRefNode);
    });

    // Sort entities in order of newEntityIds array
    let map = {};
    let refs = tx.findAll(`${tagName}`);
    refs.forEach(ref => {
      const rid = ref.getAttribute('rid');
      map[rid] = ref;
    });
    node.children.forEach(child => {
      node.removeChild(child);
    });
    newEntityIds.forEach(entityId => {
      node.appendChild(map[entityId]);
    });

    tx.setSelection(null);
  }

  class TextureConfigurator extends substance.Configurator {
    constructor () {
      super();

      this.config.configurations = {};
      this.config.availableLanguages = {};
      this.config.propertyEditors = [];
      this._compiledToolPanels = {};
    }

    static createFrom (parentConfig) {
      let ConfiguratorClass = this;
      let config = new ConfiguratorClass();
      substance.merge(config, parentConfig);
      return config
    }

    createScope (name) {
      let ConfiguratorClass = this.constructor;
      let scope = new ConfiguratorClass();
      this.setConfiguration(name, scope);
      return scope
    }

    setConfiguration (name, config) {
      this.config.configurations[name] = config;

      config._name = this._name ? this._name + '/' + name : name;
    }

    getConfiguration (name) {
      return this.config.configurations[name]
    }

    getComponentRegistry () {
      if (!this.componentRegistry) {
        this.componentRegistry = super.getComponentRegistry();
      }
      return this.componentRegistry
    }

    getComponent (name) {
      return this.getComponentRegistry().get(name, 'strict')
    }

    addCommand (name, CommandClass, opts = {}) {
      super.addCommand(name, CommandClass, opts);
      if (opts.accelerator) {
        this.addKeyboardShortcut(opts.accelerator, { command: name });
      }
    }

    addTool (name, ToolClass) {
      throw new Error('This has been removed. Use addComponent(<command-name>, ToolClass) instead')
    }

    getToolRegistry () {
      let result = new Map();
      substance.forEach(this.config.tools, (ToolClass, name) => {
        result.set(name, ToolClass);
      });
      return result
    }

    getToolClass (name) {
      return this.config.tools[name]
    }

    addToolPanel (name, spec) {
      this.config.toolPanels[name] = spec;
    }

    getToolPanel (name, strict) {
      let toolPanelSpec = this.config.toolPanels[name];
      if (toolPanelSpec) {
        // return cache compiled tool-panels
        if (this._compiledToolPanels[name]) return this._compiledToolPanels[name]
        let toolPanel = toolPanelSpec.map(itemSpec => this._compileToolPanelItem(itemSpec));
        this._compiledToolPanels[name] = toolPanel;
        return toolPanel
      } else if (strict) {
        throw new Error(`No toolpanel configured with name ${name}`)
      }
    }

    getCommands () {
      let commands = new Map();
      substance.forEach(this.config.commands, (item, name) => {
        const Command = item.CommandClass;
        let command = new Command(Object.assign({ name }, item.options));
        commands.set(name, command);
      });
      return commands
    }

    getCommandGroup (name) {
      let commandGroup = this.config.commandGroups[name];
      if (!commandGroup) {
        // console.warn('No command group registered by this name: ' + name)
        commandGroup = [];
      }
      return commandGroup
    }

    registerLanguage (code, name) {
      this.config.availableLanguages[code] = name;
    }

    getAvailableLanguages () {
      return this.config.availableLanguages
    }

    getConverters (type) {
      let registry = new substance.Registry();
      substance.forEach(this.config.converters[type], (Converter, type) => {
        registry.add(type, Converter);
      });
      return registry
    }

    _compileToolPanelItem (itemSpec) {
      let item = Object.assign({}, itemSpec);
      let type = itemSpec.type;
      switch (type) {
        case 'command': {
          if (!itemSpec.name) throw new Error("'name' is required for type 'command'")
          break
        }
        case 'command-group':
          return this.getCommandGroup(itemSpec.name).map(commandName => {
            return {
              type: 'command',
              name: commandName
            }
          })
        case 'switcher':
        case 'prompt':
        case 'group':
        case 'dropdown':
          item.items = substance.flatten(itemSpec.items.map(itemSpec => this._compileToolPanelItem(itemSpec)));
          break
        case 'separator':
        case 'spacer':
          break
        default:
          throw new Error('Unsupported tool panel item type: ' + type)
      }
      return item
    }
  }

  class ArticleHTMLExporter extends substance.HTMLExporter {
    constructor (configurator) {
      super({
        converters: _getConverters(configurator),
        idAttribute: 'data-id',
        elementFactory: substance.DefaultDOMElement.createDocument('html')
      });
    }

    /*
      Customised annotatedText method, that takes a document and $$ to be
      compatible with other rendering contexts
    */
    annotatedText (path, doc, $$) {
      if (doc) {
        this.state.doc = doc;
      }
      if ($$) {
        this.$$ = $$;
      }
      return super.annotatedText(path)
    }
  }

  // TODO: we should improve the configurators internal format, e.g. use Map instead of {}
  function _getConverters (configurator) {
    return configurator.getConverters('html')
  }

  class ArticleHTMLImporter extends substance.HTMLImporter {
    constructor (configurator) {
      super({
        schema: InternalArticleSchema,
        // HACK: in contrast to DOMExporter, DOMImporter takes an array of converters, instead of a Registry
        converters: _getConverters$1(configurator),
        idAttribute: 'data-id'
      });

      // disabling warnings about default importers
      this.IGNORE_DEFAULT_WARNINGS = true;
    }

    // TODO: it is necessary to set the document instance so that the importer is creating nodes for this document
    setDocument (doc) {
      this.reset();
      this.state.doc = doc;
    }

    _getConverterForElement (el, mode) {
      let converter = super._getConverterForElement(el, mode);
      // apply a fallback
      if (!converter) {
        if (mode !== 'inline') {
          return UnsupportedElementImporter
        }
      }
      return converter
    }
  }

  // TODO: we should improve the configurators internal format, e.g. use Map instead of {}
  function _getConverters$1 (configurator) {
    return configurator.getConverters('html').values()
  }

  const UnsupportedElementImporter = {
    type: 'paragraph',
    import (el, node, converter) {
      node.content = converter.annotatedText(el, [node.id, 'content'], { preserveWhitespace: true });
    }
  };

  class ArticlePlainTextExporter {
    export (article) {
      console.error('TODO: implement full article to plain-text conversion');
    }

    exportNode (node) {
      if (node.isContainer()) {
        return this._exportContainer(node)
      } else if (node.isText()) {
        return this._exportText(node.getDocument(), node.getPath())
      } else {
        switch (node.type) {
          case 'figure':
            return this._exportFigure(node)
          case 'table':
            return this._exportTable(node)
          case 'table-figure':
            return this._exportTableFigure(node)
          default:
            //
        }
      }

      if (node._isXMLNode) {
        return node.toXML().textContent || ''
      } else {
        console.error('TODO: implement node -> plain-text conversion for node type', node.type);
        return ''
      }
    }

    _exportContainer (node) {
      if (!node) return ''
      return node.getNodes().map(node => {
        return this.exportNode(node)
      }).join('\n\n')
    }

    _exportText (doc, path) {
      return doc.get(path) || ''
    }

    _exportTable (node) {
      if (!node) return ''
      return node.getCellMatrix().map(row => {
        return row.map(cell => {
          if (cell.isShadowed()) {
            return ''
          } else {
            return cell.getText()
          }
        }).join('\t')
      }).join('\n')
    }

    _exportFigure (node) {
      if (!node) return ''
      let doc = node.getDocument();
      let result = [];
      result.push(getLabel(node) + ': ' + this._exportText(doc, [node.id, 'title']));
      result.push(this._exportContainer(node.getCaption()));
      return result.join('\n')
    }

    _exportTableFigure (node) {
      if (!node) return ''
      let doc = node.getDocument();
      let result = [];
      result.push(getLabel(node) + ': ' + this._exportText(doc, [node.id, 'title']));
      result.push(this._exportTable(node.getContent()));
      result.push(this._exportContainer(node.getCaption()));
      return result.join('\n')
    }
  }

  class ArticleConfigurator extends TextureConfigurator {
    constructor () {
      super();

      this.config.models = new Map();
      this.schema = InternalArticleSchema;
    }

    // TODO: We gonna have plugins that will add nodes
    addNode () {
      throw new Error('Texture Article Schema is final and can no be extended.')
    }

    getModelRegistry () {
      return this.config.models
    }

    addAnnotationTool (spec) {
      let Command = spec.command || substance.AnnotationCommand;
      this.addCommand(spec.name, Command, {
        nodeType: spec.nodeType,
        commandGroup: spec.commandGroup
      });
      this.addIcon(spec.name, { 'fontawesome': spec.icon });
      this.addLabel(spec.name, spec.label);
      if (spec.accelerator) {
        this.addKeyboardShortcut(spec.accelerator, { command: spec.name });
      }
    }

    addTextTypeTool (spec) {
      this.addCommand(spec.name, SwitchTextTypeCommand, {
        spec: spec.nodeSpec,
        commandGroup: 'text-types'
      });
      this.addIcon(spec.name, { 'fontawesome': spec.icon });
      this.addLabel(spec.name, spec.label);
      if (spec.accelerator) {
        this.addKeyboardShortcut(spec.accelerator, { command: spec.name });
      }
    }

    setPanelsSpec (panelsSpec) {
      this.config.panelsSpec = panelsSpec;
    }

    getPanelsSpec () {
      return this.config.panelsSpec
    }

    setLabelGenerator (resourceType, LabelGeneratorClass, config) {
      if (!this.config.labelGenerator) {
        this.config.labelGenerator = {};
      }
      this.config.labelGenerator[resourceType] = {
        LabelGeneratorClass,
        config
      };
    }

    getLabelGenerator (resourceType) {
      let spec = this.config.labelGenerator[resourceType];
      if (!spec) throw new Error(`No LabelGenerator specified for resource type ${resourceType}`)
      const LabelGenerator = spec.LabelGeneratorClass;
      return new LabelGenerator(spec.config)
    }

    getKeyboardShortcuts () {
      return this.config.keyboardShortcuts
    }

    /*
      Allows lookup of a keyboard shortcut by command name
    */
    getKeyboardShortcutsByCommandName (commandName) {
      let keyboardShortcuts = {};
      this.config.keyboardShortcuts.forEach((entry) => {
        if (entry.spec.command) {
          let shortcut = entry.key.toUpperCase();

          if (substance.platform.isMac) {
            shortcut = shortcut.replace(/CommandOrControl/i, '⌘');
            shortcut = shortcut.replace(/Ctrl/i, '^');
            shortcut = shortcut.replace(/Shift/i, '⇧');
            shortcut = shortcut.replace(/Enter/i, '↵');
            shortcut = shortcut.replace(/Alt/i, '⌥');
            shortcut = shortcut.replace(/\+/g, '');
          } else {
            shortcut = shortcut.replace(/CommandOrControl/i, 'Ctrl');
          }

          keyboardShortcuts[entry.spec.command] = shortcut;
        }
      });
      return keyboardShortcuts[commandName]
    }

    getExporter (type) {
      switch (type) {
        case 'text': {
          if (!this._textExporter) {
            this._textExporter = new ArticlePlainTextExporter();
          }
          return this._textExporter
        }
        case 'html': {
          if (!this._htmlExporter) {
            this._htmlExporter = new ArticleHTMLExporter(this);
          }
          return this._htmlExporter
        }
      }
    }

    getImporter (type) {
      switch (type) {
        case 'html': {
          if (!this._htmlImporter) {
            this._htmlImporter = new ArticleHTMLImporter(this);
          }
          return this._htmlImporter
        }
      }
    }
  }

  var BoldConverter$1 = {
    type: 'bold',
    tagName: 'b',
    matchElement (el) {
      return (el.is('b')) ||
        (el.is('span') && el.getStyle('font-weight') === '700')
    }
  }

  var ExtLinkConverter = {
    type: 'external-link',
    tagName: 'a',
    import (el, node) {
      let href = el.getAttribute('href');
      if (href) {
        node.href = href;
      }
    },
    export (node, el) {
      el.setAttribute('href', node.href);
    }
  }

  var PreformatConverter$1 = {
    type: 'preformat',
    tagName: 'pre',
    import (el, node, converter) {
      node.content = converter.annotatedText(el, [node.id, 'content'], { preserveWhitespace: true });
    },
    export (node, el, converter) {
      el.append(
        converter.annotatedText([node.id, 'content'])
      );
    }
  }

  var HeadingConverter = {
    type: 'heading',

    matchElement (el) {
      return /^h\d$/.exec(el.tagName)
    },

    import (el, node, converter) {
      node.content = converter.annotatedText(el, [node.id, 'content'], { preserveWhitespace: true });
    },

    export (node, el, converter) {
      el.tagName = `h${node.level}`;
      el.append(converter.annotatedText([node.id, 'content']));
    }
  }

  var ItalicConverter$1 = {
    type: 'italic',
    tagName: 'i',
    matchElement (el) {
      return (el.is('i')) ||
        (el.is('span') && el.getStyle('font-style') === 'italic')
    }
  }

  class ListHTMLConverter {
    get type () { return 'list' }

    matchElement (el) {
      return el.is('ul') || el.is('ol')
    }

    import (el, node, converter) {
      this._santizeNestedLists(el);

      let items = [];
      let config = [];
      substance.domHelpers.walk(el, (el, level) => {
        if (!el.isElementNode()) return
        if (el.is('li')) {
          items.push({ el, level });
        } else if (!config[level]) {
          if (el.is('ul')) config[level] = 'bullet';
          else if (el.is('ol')) config[level] = 'order';
        }
      });
      this._createListItems(converter, node, items, config);
    }

    _createListItems (converter, node, items, levelTypes) {
      node.items = items.map(d => {
        let listItem = converter.convertElement(d.el);
        listItem.level = d.level;
        return listItem.id
      });
      node.listType = levelTypes.join(',');
    }

    export (node, el, converter) {
      let $$ = converter.$$;
      let _createElement = function (arg) {
        if (substance.isString(arg)) {
          return $$(arg)
        } else {
          let item = arg;
          let path = item.getPath();
          return $$('li').append(converter.annotatedText(path))
        }
      };
      let _el = substance.renderListNode(node, _createElement);
      el.tagName = _el.tagName;
      el.attr(_el.getAttributes());
      el.append(_el.getChildNodes());
      return el
    }

    _santizeNestedLists (root) {
      // pulling out uls from <li> to simplify the problem
      /*
        E.g.
        `<ul><li>Foo:<ul>...</ul></li>`
        Is turned into:
        `<ul><li>Foo:</li><ul>...</ul></ul>`
      */
      let nestedLists = root.findAll('ol,ul');
      nestedLists.forEach((el) => {
        while (!el.parentNode.is('ol,ul')) {
          let parent = el.parentNode;
          let grandParent = parent.parentNode;
          let pos = grandParent.getChildIndex(parent);
          grandParent.insertAt(pos + 1, el);
        }
      });
    }
  }

  var ParagraphConverter$1 = {
    type: 'paragraph',
    tagName: 'p',
    import (el, node, converter) {
      node.content = converter.annotatedText(el, [node.id, 'content']);
    },
    export (node, el, converter) {
      el.append(converter.annotatedText([node.id, 'content']));
    }
  }

  var StrikeConverter = {
    type: 'strike-through',
    tagName: 's',
    matchElement (el) {
      return el.is('s') || el.is('strike') || el.getStyle('text-decoration') === 'line-through'
    },
    export (node, el) {
      el.setStyle('text-decoration', 'line-through');
    }
  }

  var SubConverter = {
    type: 'subscript',
    tagName: 'sub',
    matchElement (el) {
      return (el.is('sub')) || (el.is('span') && el.getStyle('vertical-align') === 'sub')
    }
  }

  var SupConverter = {
    type: 'superscript',
    tagName: 'sup',
    matchElement (el) {
      return (el.is('sup')) || (el.is('span') && el.getStyle('vertical-align') === 'super')
    }
  }

  var UnderlineConverter$1 = {
    type: 'underline',
    tagName: 'u',
    matchElement (el) {
      return el.is('u') || el.getStyle('text-decoration') === 'underline'
    },
    export (node, el) {
      el.setStyle('text-decoration', 'underline');
    }
  }

  var ArticleHTMLConverters = [
    BoldConverter$1,
    PreformatConverter$1,
    ExtLinkConverter,
    HeadingConverter,
    ItalicConverter$1,
    ListHTMLConverter,
    substance.ListPackage.ListItemHTMLConverter,
    ParagraphConverter$1,
    StrikeConverter,
    SubConverter,
    SupConverter,
    new TableConverter(),
    UnderlineConverter$1
  ]

  var LanguagesPackage = {
    name: 'Languages',
    configure (config) {
      config.registerLanguage('en', 'English');
      config.registerLanguage('es', 'Spanish');
      config.registerLanguage('pt', 'Portugese');
      config.registerLanguage('fr', 'French');
    }
  }

  var ArticleModelPackage = {
    name: 'TextureArticle',
    configure (config) {
      config.import(EntityLabelsPackage);

      // enable rich-text support for clipboard
      ArticleHTMLConverters.forEach(converter => {
        config.addConverter('html', converter);
      });

      // Registry of available languages
      config.import(LanguagesPackage);

      // ATTENTION: FigureLabelGenerator works a bit differently
      // TODO: consolidate LabelGenerators and configuration
      // e.g. it does not make sense to say 'setLabelGenerator' but then only provide a configuration for 'NumberedLabelGenerator'
      config.setLabelGenerator('figures', FigureLabelGenerator, {
        singular: 'Figure $',
        plural: 'Figures $',
        and: ',',
        to: '-'
      });
      config.setLabelGenerator('footnotes', NumberedLabelGenerator, {
        template: '$',
        and: ',',
        to: '-'
      });
      config.setLabelGenerator('formulas', NumberedLabelGenerator, {
        template: '($)',
        and: ',',
        to: '-'
      });
      config.setLabelGenerator('references', NumberedLabelGenerator, {
        template: '[$]',
        and: ',',
        to: '-'
      });
      config.setLabelGenerator('supplementaries', NumberedLabelGenerator, {
        name: 'Supplementary File',
        plural: 'Supplementary Files',
        and: ',',
        to: '-'
      });
      config.setLabelGenerator('tables', NumberedLabelGenerator, {
        name: 'Table',
        plural: 'Tables',
        and: ',',
        to: '-'
      });
    }
  }

  class FormulaManager extends CitableContentManager {
    constructor (documentSession, labelGenerator) {
      super(documentSession, BlockFormula.refType, [BlockFormula.type], labelGenerator);
      this._updateLabels('initial');
    }
  }

  class SupplementaryManager extends CitableContentManager {
    constructor (documentSession, labelGenerator) {
      super(documentSession, 'file', ['supplementary-file'], labelGenerator);
      this._updateLabels('initial');
    }

    // ATTENTION: for now we consider only supplementary files that are direct children of the body
    // TODO: we need to specify how this should be extended to supplementary files in figure panels
    getCitables () {
      return this._getContentElement().resolve('content').filter(child => child.type === 'supplementary-file')
    }
  }

  class ArticleSession extends substance.DocumentSession {
    constructor (doc, config) {
      super(doc);

      this.figureManager = new FigureManager(this, config.getLabelGenerator('figures'));
      this.footnoteManager = new FootnoteManager(this, config.getLabelGenerator('footnotes'));
      this.formulaManager = new FormulaManager(this, config.getLabelGenerator('formulas'));
      this.referenceManager = new ReferenceManager(this, config.getLabelGenerator('references'));
      this.supplementaryManager = new SupplementaryManager(this, config.getLabelGenerator('supplementaries'));
      this.tableManager = new TableManager(this, config.getLabelGenerator('tables'));
    }

    getFigureManager () {
      return this.figureManager
    }

    getFootnoteManager () {
      return this.footnoteManager
    }

    getFormulaManager () {
      return this.formulaManager
    }

    getReferenceManager () {
      return this.referenceManager
    }

    getTableManager () {
      return this.tableManager
    }

    getSupplementaryManager () {
      return this.supplementaryManager
    }
  }

  var ArticleLoader = {
    load (xml) {
      let configurator = new ArticleConfigurator();
      configurator.import(ArticleModelPackage);
      let jatsImporter = new JATSImporter();
      let importOptions = {
        allowNotImplemented: true
      };
      let result = jatsImporter.import(xml, importOptions);
      if (result.hasErrored) {
        let err = new Error('JATS import failed');
        err.type = 'jats-import-error';
        err.detail = new ImporterErrorReport(result.errors);
        throw err
      }
      let doc = result.doc;
      return new ArticleSession(doc, configurator)
    }
  }

  class ImporterErrorReport {
    constructor (jatsImporterErrors) {
      let failedStages = [];
      substance.forEach(jatsImporterErrors, (errors, stage) => {
        if (errors && errors.length > 0) {
          failedStages.push({ name: stage, errors });
        }
      });
      this._errors = failedStages;
    }

    toString () {
      let frags = this._errors.reduce((frags, stage) => {
        frags.push(`Errors during stage ${stage.name}:`);
        frags = frags.concat(stage.errors.map(err => {
          return _indentMsg(err.msg, '  ') + '\n'
        }));
        return frags
      }, []);
      return frags.join('\n')
    }
  }

  function _indentMsg (msg, indent) {
    return msg.split('\n').map(line => indent + line).join('\n')
  }

  /*
    Converts a CSLJSON record to our internal format.
    See EntityDatabase for schemas.
  */

  function convertCSLJSON (source) {
    let bibType = source.type;
    let result;

    // CSL types: http://docs.citationstyles.org/en/stable/specification.html#appendix-iii-types
    let typeMapping = {
      'article': ARTICLE_REF,
      'article-magazine': MAGAZINE_ARTICLE_REF,
      'article-newspaper': NEWSPAPER_ARTICLE_REF,
      'article-journal': JOURNAL_ARTICLE_REF,
      // "bill"
      'book': BOOK_REF,
      // "broadcast"
      'chapter': CHAPTER_REF,
      'dataset': DATA_PUBLICATION_REF,
      // "entry"
      'entry-dictionary': BOOK_REF,
      'entry-encyclopedia': BOOK_REF,
      // "figure"
      // "graphic"
      // "interview"
      // "legislation"
      // "legal_case"
      // "manuscript"
      // "map"
      // "motion_picture"
      // "musical_score"
      // "pamphlet"
      'paper-conference': CONFERENCE_PAPER_REF,
      'patent': PATENT_REF,
      // "post"
      // "post-weblog"
      // "personal_communication"
      'report': REPORT_REF,
      // "review"
      // "review-book"
      // "song"
      // "speech"
      'thesis': THESIS_REF,
      // "treaty"
      'webpage': WEBPAGE_REF
      // NA : "software"
    };

    if (typeMapping[bibType]) {
      result = _convertFromCSLJSON(source, typeMapping[bibType]);
    } else {
      throw new Error(`Bib type ${bibType} not yet supported`)
    }
    return result
  }

  function _convertFromCSLJSON (source, type) {
    const date = _extractDateFromCSLJSON(source);

    let data = {
      type: type,

      title: source.title,
      containerTitle: source['container-title'],
      volume: source.volume,
      issue: source.issue,
      pageRange: source.page,
      doi: source.DOI,
      pmid: source.PMID,

      edition: source.edition,
      publisherLoc: source['publisher-place'],
      publisherName: source.publisher,
      pageCount: source['number-of-pages'],
      partTitle: source.section,
      confName: source.event,
      confLoc: source['event-place'],
      isbn: source.ISBN,

      year: date.year,
      month: date.month,
      day: date.day,

      uri: source.URL,
      version: source.version

      /* Examples with no corresponding field:
          - abstract
          - accessed
          - composer
          - director
          - ISSN
          - language
          - number-of-volumes
          - PMCID
          - title-short
          - translator
      */
    };

    // series
    if (source['collection-title']) {
      data.series = source['collection-title'];
      if (source['collection-number']) {
        data.series += '; ' + source['collection-number'];
      }
    }

    // Authors, editors, translators, inventors
    if (source.author) {
      if (type === 'patent') {
        data.inventors = source.author.map(a => { return { name: a.family, givenNames: a.given, type: 'ref-contrib' } });
      } else {
        data.authors = source.author.map(a => { return { name: a.family, givenNames: a.given, type: 'ref-contrib' } });
      }
    }
    if (source.editor) {
      data.editors = source.editor.map(a => { return { name: a.family, givenNames: a.given, type: 'ref-contrib' } });
    }
    if (source.translator) {
      data.translators = source.translator.map(a => { return { name: a.family, givenNames: a.given, type: 'ref-contrib' } });
    }

    // Cleanup output to avoid any undefined values
    Object.keys(data).forEach(key => {
      if (data[key] === undefined) {
        delete data[key];
      }
    });

    if (!data.doi) {
      // TODO: We should not rely that the imported item has a DOI, because it can also be imported from a generic CSL JSON file.
      //  However, there are some problems in the further processing withouth a DOI at the moment...
      throw new Error(`Citation must have DOI.`)
    }

    return data
  }

  function _extractDateFromCSLJSON (source) {
    let date = {};
    if (source.issued && source.issued['date-parts']) {
      let CSLdate = source.issued['date-parts'];
      if (CSLdate.length > 0) {
        date.year = String(CSLdate[0][0]);
        if (CSLdate[0][1]) {
          date.month = CSLdate[0][1] > 9 ? String(CSLdate[0][1]) : 0 + String(CSLdate[0][1]);
        }
        if (CSLdate[0][2]) {
          date.day = CSLdate[0][2] > 9 ? String(CSLdate[0][2]) : 0 + String(CSLdate[0][2]);
        }
      }
    }
    return date
  }

  class QueryComponent extends substance.Component {
    render ($$) {
      let Input = this.getComponent('input');

      const btnEl = $$('button').addClass('se-action');

      if (this.props.loading) {
        btnEl.append(
          this._renderIcon($$, 'input-loading')
        );
      } else if (this.props.errors) {
        btnEl.append(
          this._renderIcon($$, 'input-error')
        );
      } else {
        btnEl.append(
          this.getLabel(this.props.actionLabel)
        ).on('click', this._onQuery);
      }

      let el = $$('div').addClass('sc-query').append(
        $$(InputWithButton, {
          input: $$(Input).attr({
            type: 'text',
            placeholder: this.getLabel(this.props.placeholder)
          }).ref('input').on('input', this._unblockUI),
          button: btnEl
        })
      );

      if (this.props.errors) {
        el.addClass('sm-error').append(
          $$('div').addClass('se-error-popup').append(
            $$('ul').addClass('se-error-list')
              .append(this.props.errors.map(err => $$('li').append(err)))
          )
        );
      }

      return el
    }

    _renderIcon ($$, icon) {
      return $$('div').addClass('se-icon').append(
        this.context.iconProvider.renderIcon($$, icon)
      )
    }

    _onQuery () {
      const input = this.refs.input;
      const val = input.val();
      if (val) this.send('query', val);
    }

    _unblockUI () {
      if (this.props.errors) {
        this.extendProps({ errors: undefined });
      }
    }
  }

  class DOIInputComponent extends substance.Component {
    constructor (...args) {
      super(...args);
      this.handleActions({
        'query': this._startImporting
      });
    }

    getInitialState () {
      return {
        loading: false
      }
    }

    render ($$) {
      return $$('div').addClass('sc-doi-input').append(
        $$(QueryComponent, {
          placeholder: 'enter-doi-placeholder',
          actionLabel: 'add-action',
          loading: this.state.loading,
          errors: this.state.errors
        })
      )
    }

    async _startImporting (input) {
      const dois = input.split(' ').map(v => v.trim()).filter(v => Boolean(v));
      this.extendState({ loading: true });

      try {
        const entries = await _getBibEntries(dois);
        this.send('importBib', entries);
      } catch (error) {
        const dois = error.dois;
        const errorMessage = error.message;
        let errors = [
          errorMessage
        ];
        errors = errors.concat(dois.map(d => '- ' + d));
        this.extendState({ errors, loading: false });
      }
    }
  }

  /*
    Helpers
  */
  const ENDPOINT = 'https://doi.org/';

  function _getBibEntries (dois) {
    return _fetchCSLJSONEntries(dois).then(entries => {
      let conversionErrors = [];
      let convertedEntries = [];
      entries.forEach(entry => {
        try {
          convertedEntries.push(
            convertCSLJSON(entry)
          );
        } catch (error) {
          conversionErrors.push(entry.DOI);
        }
      });
      if (conversionErrors.length > 0) {
        let error = new Error('Conversion error');
        error.dois = conversionErrors;
        return Promise.reject(error)
      } else {
        return convertedEntries
      }
    })
  }

  /*
    Fetch CSL JSON entries
  */
  function _fetchCSLJSONEntries (dois) {
    let errored = [];
    let entries = [];

    return dois.reduce((promise, doi) => {
      return promise
        .then(() => _fetchDOI(doi))
        .then(csl => entries.push(JSON.parse(csl)))
        .catch(() => errored.push(doi))
    }, Promise.resolve())
      .then(() => {
        if (errored.length > 0) {
          let err = new Error(`Could not resolve some DOI's`);
          err.dois = errored;
          throw err
        } else {
          return entries
        }
      })
  }

  /*
    Fetch single entry for DOI
  */
  function _fetchDOI (doi) {
    const url = ENDPOINT + doi;
    return substance.sendRequest({ url: url, method: 'GET', header: { 'accept': 'application/vnd.citationstyles.csl+json' } })
  }

  class ReferenceUploadComponent extends FileUploadComponent {
    get acceptedFiles () {
      return 'application/json'
    }

    renderErrorsList ($$) {
      const dois = this.state.error.dois;
      const errorsList = $$('ul').addClass('se-error-list');
      errorsList.append(
        $$('li').append(this.state.error.message)
      );
      if (dois) {
        errorsList.append(dois.map(d => $$('li').append('- ' + d)));
      }
      return errorsList
    }

    handleUploadedFiles (files) {
      Object.values(files).forEach(file => {
        const reader = new window.FileReader();
        reader.onload = this._onFileLoad.bind(this);
        reader.readAsText(file);
      });
    }

    _onFileLoad (e) {
      const res = e.target.result;
      if (res) {
        let conversionErrors = [];
        let convertedEntries = [];
        const entries = JSON.parse(res);
        entries.forEach(entry => {
          try {
            convertedEntries.push(
              convertCSLJSON(entry)
            );
          } catch (error) {
            conversionErrors.push(entry.DOI || error);
          }
        });

        if (conversionErrors.length > 0) {
          let error = new Error('Conversion error');
          error.dois = conversionErrors;
          this.extendState({ error });
        } else {
          this.send('importBib', convertedEntries);
        }
      }
    }
  }

  class AddReferenceWorkflow extends substance.Component {
    static get desiredWidth () {
      return 'large'
    }

    get supportedUploadFormats () {
      return ['CSL-JSON']
    }

    didMount () {
      super.didMount();

      this.handleActions({
        'importBib': this._onImport
      });
    }

    render ($$) {
      let el = $$('div').addClass('sc-add-reference sm-workflow');

      const title = $$('div').addClass('se-title').append(
        this.getLabel('add-reference-title')
      );

      const refTypesButtons = $$('ul').addClass('se-reftypes-list');
      INTERNAL_BIBR_TYPES.forEach(item => {
        refTypesButtons.append(
          $$('li').addClass('se-type sm-' + item).append(
            this.getLabel(item)
          ).on('click', this._onAdd.bind(this, item))
        );
      });
      const manualAddEl = $$('div').addClass('se-manual-add').append(refTypesButtons);

      el.append(
        title,
        $$(DialogSectionComponent, { label: this.getLabel('fetch-datacite') })
          .append($$(DOIInputComponent)),
        $$(DialogSectionComponent, {
          label: this.getLabel('import-refs'),
          description: this.getLabel('supported-ref-formats') + ': ' + this.supportedUploadFormats.join(', ')
        }).append($$(ReferenceUploadComponent)),
        $$(DialogSectionComponent, { label: this.getLabel('add-ref-manually') })
          .append(manualAddEl)
      );

      return el
    }

    _onAdd (type) {
      this.context.api._addReference({ type });
      this.send('closeModal');
    }

    _onImport (items) {
      this.context.api._addReferences(items);
      this.send('closeModal');
    }
  }

  class CardComponent extends substance.Component {
    didMount () {
      // Note: without a 'managed' approach every card component needs to listen to selection updates
      // TODO: consider to use a reducer that maps the selection to another variable, e.g. activeCard
      // then the cards would not be triggered on every other change
      this.context.appState.addObserver(['selection'], this._onSelectionChange, this, { stage: 'render' });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }

    render ($$) {
      const node = this.props.node;
      const nodeId = node.id;
      const children = this.props.children;
      const label = this.getLabel(this.props.label);
      const el = $$('div')
        .addClass(this._getClassNames())
        .attr('data-id', nodeId)
        .append(
          $$('div').addClass('se-label').append(label)
        );
      el.append(children);
      el.on('click', this._toggleCardSelection);
      return el
    }

    _getClassNames () {
      return `sc-card sm-${this.props.node.type}`
    }

    _toggleCardSelection () {
      const node = this.props.node;
      const api = this.context.api;
      if (node.type === 'figure-panel') {
        const figure = node.getParent();
        const panelIds = figure.panels;
        const editorSession = this.context.editorSession;
        editorSession.updateNodeStates([[figure.id, { currentPanelIndex: panelIds.indexOf(node.id) }]], { propagate: true });
      }
      api.selectModel(node.id);
    }

    _onSelectionChange (sel) {
      if (sel && sel.customType === 'model') {
        if (sel.data.modelId === this.props.node.id) {
          this.el.addClass('sm-selected');
        } else {
          this.el.removeClass('sm-selected');
        }
      } else {
        this.el.removeClass('sm-selected');
      }
    }
  }

  class ArticleInformationSectionComponent extends substance.Component {
    render ($$) {
      const model = this.props.model;
      const el = $$('div').addClass('sc-article-information-section');
      const cards = model.cards.map(card => this._renderCardEditor($$, card));
      return el.append(cards)
    }

    // NOTE: we are looking for a fake models with node inside
    // and retreiving components for those nodes,
    // for real models we are rendering model editor.
    _renderCardEditor ($$, card) {
      const model = card.model;
      let editorEl, node;
      if (model.node) {
        const EditorClass = this.getComponent(model.id);
        editorEl = $$(EditorClass, { node: model.node });
        node = model.node;
      } else {
        // HACK: for model editing (e.g. title, abstract) we are passing
        // model as node to avoid errors
        node = model;
        editorEl = renderModel($$, this, card.model, { placeholder: this.getLabel(card.placeholder) });
      }
      editorEl.ref(node.id);
      return $$(CardComponent, { label: card.name, node: node }).append(editorEl)
    }
  }

  class ArticleMetadataComponent extends DefaultNodeComponent {
    _getClassNames () {
      return `sc-article-record`
    }

    _renderHeader () {
      // no header
    }

    _getPropertyEditorClass (name, value) {
      switch (name) {
        case 'license': {
          return LicenseEditor
        }
        default:
          return super._getPropertyEditorClass(name, value)
      }
    }

    _createPropertyModels () {
      const EXCLUDED_FIELDS = new Set(['authors', 'editors', 'groups', 'organisations', 'funders', 'keywords', 'subjects', 'articleType']);
      const api = this.context.api;
      const node = this.props.node;
      const doc = node.getDocument();
      return createNodePropertyModels(api, this.props.node, (p) => {
        switch (p.name) {
          case 'permission': {
            let permission = doc.get(node.permission);
            return createNodePropertyModels(api, permission)
          }
          default:
            if (!EXCLUDED_FIELDS.has(p.name)) {
              return createValueModel(api, [node.id, p.name], p)
            }
        }
      })
    }
  }

  class BibliographicEntryEditor extends DefaultNodeComponent {
    // using a special inplace property editor for 'ref-contrib's
    _getPropertyEditorClass (name, value) {
      if (value.hasTargetType('ref-contrib')) {
        return InplaceRefContribsEditor
      } else {
        return super._getPropertyEditorClass(name, value)
      }
    }
  }

  // TODO: consolidate AddEntityCommand and RemoveItemCommand etc.

  class BasicCollectionCommand extends substance.Command {
    constructor (...args) {
      super(...args);

      // EXPERIMENTAL: 'pre-compiling' a selector for the current xpath
      // later this selector will be compiled by the CommandManager, and commands be inhibited if the selector does not match current xpath
      // for now we only support '<type>.<property>' as selector format. Later this will be extended as we need it.
      let xpathSelector = this.config.xpathSelector;
      if (xpathSelector) {
        // ATTENTION: this is not ready for any other format than '<type>.<property>'
        let [type, property] = xpathSelector.split('.');
        this._contextSelector = { type, property };
      }
    }

    getCommandState (params, context) {
      let { collectionPath, item, position } = this._detectCollection(params, context);
      return { disabled: (!collectionPath || !item), collectionPath, item, position }
    }

    _detectCollection (params, context) {
      let doc = context.editorSession.getDocument();
      let selectionState = params.selectionState;
      let xpath = selectionState.xpath;
      if (this._contextSelector && xpath.length > 0) {
        let idx = xpath.findIndex(x => x.type === this._contextSelector.type);
        let first = xpath[idx];
        let second = xpath[idx + 1];
        if (first && second && second.property === this._contextSelector.property) {
          let collectionPath = [first.id, second.property];
          let item = doc.get(second.id);
          let position = -1;
          if (item) {
            position = item.getPosition();
          }
          return { collectionPath, item, position }
        }
      }
      return {}
    }
  }

  class RemoveCollectionItemCommand extends BasicCollectionCommand {
    execute (params, context) {
      const { collectionPath, item } = params.commandState;
      let editorSession = context.editorSession;
      editorSession.transaction(tx => {
        substance.documentHelpers.remove(tx, collectionPath, item.id);
        tx.selection = null;
      });
    }
  }

  class MoveCollectionItemCommand extends BasicCollectionCommand {
    getCommandState (params, context) {
      let commandState = super.getCommandState(params, context);
      if (!commandState.disabled) {
        // check the posision
        const direction = this.config.direction;
        const { collectionPath, position } = commandState;
        let ids = context.editorSession.getDocument().get(collectionPath);
        if (
          (direction === 'up' && position === 0) ||
          (direction === 'down' && position === ids.length - 1)
        ) {
          commandState.disabled = true;
        }
      }
      return commandState
    }

    execute (params, context) {
      const direction = this.config.direction;
      const { collectionPath, item, position } = params.commandState;
      // TODO: should we really trust the commandState?
      let newPosition = direction === 'up' ? position - 1 : position + 1;
      let editorSession = context.editorSession;
      editorSession.transaction(tx => {
        substance.documentHelpers.removeAt(tx, collectionPath, position);
        substance.documentHelpers.insertAt(tx, collectionPath, newPosition, item.id);
        // TODO: what about the selection?
      });
    }
  }

  // Note: This is used for values of type 'collection'
  // where every item is rendered as a single card
  class MetadataCollectionComponent extends ModelComponent {
    render ($$) {
      const model = this.props.model;
      let items = model.getItems();
      let el = $$('div').addClass('sc-collection-editor');
      items.forEach(item => {
        let ItemEditor = this._getItemComponentClass(item);
        el.append(
          $$(CardComponent, {
            node: item,
            label: item.type
          // TODO: maybe it would be better to use an explicit prop, then the implicit one
          }).append(
            $$(ItemEditor, {
              node: item,
              mode: METADATA_MODE
            }).ref(item.id)
          )
        );
      });
      return el
    }

    // TODO: this should go into a common helper
    _getItemComponentClass (item) {
      let ItemComponent = this.getComponent(item.type, true);
      if (!ItemComponent) {
        // try to find a component registered for a parent type
        ItemComponent = this._getParentTypeComponent(item);
      }
      return ItemComponent || this.getComponent('entity')
    }

    // TODO: this should go into a common helper
    _getParentTypeComponent (node) {
      let superTypes = node.getSchema().getSuperTypes();
      for (let type of superTypes) {
        let NodeComponent$$1 = this.getComponent(type, true);
        if (NodeComponent$$1) return NodeComponent$$1
      }
    }
  }

  // NOTE: We use a special component to render Figures in the Metadata view.
  // Every Figure can be seen as a collection of sub-figure (aka panels), and
  // every panel is rendered as individual card.
  class FiguresSectionComponent extends substance.Component {
    render ($$) {
      const model = this.props.model;
      const figures = model.getItems();
      let el = $$('div').addClass('sc-figures-section sc-collection-editor');
      for (let figure of figures) {
        el.append(
          $$(FigurePanelsComponent, { model: createValueModel(this.context.api, [figure.id, 'panels']) }).ref(figure.id)
        );
      }
      return el
    }
  }

  // This component takes a collection of panels (figure.getPanels())
  // and renders every item in an individual card
  class FigurePanelsComponent extends MetadataCollectionComponent {
    render ($$) {
      const panels = this.props.model.getItems();
      let el = $$('div');
      for (let panel of panels) {
        let PanelEditor = this._getItemComponentClass(panel);
        el.append(
          $$(CardComponent, {
            node: panel,
            label: 'figure'
          }).append(
            $$(PanelEditor, {
              mode: METADATA_MODE,
              node: panel
            }).ref(panel.id)
          )
        );
      }
      return el
    }

    didMount () {
      let path = this.props.model.getPath();
      this.context.appState.addObserver(['document'], this.rerender, this, {
        stage: 'render',
        document: { path }
      });
    }

    dispose () {
      this.context.appState.removeObserver(this);
    }
  }

  class MetadataSection extends substance.Component {
    didMount () {
      addModelObserver(this.props.model, this._onModelUpdate, this);
    }

    dispose () {
      removeModelObserver(this);
    }

    render ($$) {
      const model = this.props.model;
      const name = this.props.name;
      // const label = this.getLabel(model.id)
      let el = $$('div')
        .addClass('sc-metadata-section')
        .addClass(`sm-${name}`)
        .attr({
          'data-section': name
        });
      if (model.type === 'collection') {
        let label = this.getLabel(name);
        el.append(
          $$('div').addClass('se-heading').attr('id', model.id).append(
            $$('div').addClass('se-header').append(label)
          )
        );
        el.append(
          $$(MetadataCollectionComponent, { model })
        );
      } else {
        let CustomEditor = this.getComponent(model.id);
        let label = this.getLabel(name);
        el.append(
          $$('div').addClass('se-heading').attr('id', model.id).append(
            $$('div').addClass('se-header').append(label)
          )
        );
        el.append(
          $$(CustomEditor, { model })
        );
      }
      if (model.length === 0) {
        el.addClass('sm-empty');
      }
      return el
    }

    // ATTENTION: doing incremental update manually to avoid double rerendering of child collection
    // TODO: it would be good if Substance could avoid rerendering a component twice in one run
    _onModelUpdate () {
      let model = this.props.model;
      if (model.type === 'collection') {
        if (model.length === 0) {
          this.el.addClass('sm-empty');
        } else {
          this.el.removeClass('sm-empty');
        }
      }
    }
  }

  class LanguageEditor extends ValueComponent {
    render ($$) {
      const model = this.props.model;
      const value = model.getValue();
      const languages = this._getArticleLanguages();
      let el = $$('div').addClass('sc-language-editor');

      const languageSelector = $$('select').addClass('se-select')
        .ref('input')
        .on('click', this._suppressClickPropagation)
        .on('change', this._setLanguage);

      languageSelector.append(
        $$('option').append(this.getLabel('select-language'))
      );

      Object.keys(languages).forEach(lang => {
        const option = $$('option').attr({ value: lang }).append(languages[lang]);
        if (lang === value) option.attr({ selected: 'selected' });
        languageSelector.append(option);
      });

      el.append(languageSelector);

      return el
    }

    _setLanguage () {
      const model = this.props.model;
      const input = this.refs.input;
      const value = input.getValue();
      model.setValue(value);
    }

    _getArticleLanguages () {
      const configurator = this.context.configurator;
      return configurator.getAvailableLanguages()
    }

    _suppressClickPropagation (e) {
      e.stopPropagation();
    }
  }

  class TranslatableEntryEditor extends DefaultNodeComponent {
    // using a special translatable property editor for entries with language picker
    _getPropertyEditorClass (name, value) {
      if (name === 'language') {
        return LanguageEditor
      } else {
        return super._getPropertyEditorClass(name, value)
      }
    }
  }

  class RemoveReferenceCommand extends RemoveItemCommand {
    isDisabled (params, context) {
      const node = this._getNode(params);
      const isCustomSelection = params.selection.isCustomSelection();
      if (!isCustomSelection || !node) return true
      // Every reference should be inside article references property
      return node.getXpath().property !== 'references'
    }

    _getNode (params) {
      return params.selectionState.node
    }
  }

  var MetadataPackage = {
    name: 'ArticleMetadata',
    configure (config) {
      config.import(BasePackage);
      config.import(EditorBasePackage);
      config.import(ArticleToolbarPackage);
      config.import(PersistencePackage);
      config.import(ManuscriptContentPackage);
      config.import(ModelComponentPackage);
      config.import(EntityLabelsPackage);
      config.import(FindAndReplacePackage);

      config.addComponent('add-reference', AddReferenceWorkflow);
      config.addComponent('article-metadata', ArticleMetadataComponent);
      config.addComponent('article-information', ArticleInformationSectionComponent);
      config.addComponent('bibr', BibliographicEntryEditor, true);
      config.addComponent('table-figure', TableFigureComponent, true);
      config.addComponent('subject', TranslatableEntryEditor);
      config.addComponent('keyword', TranslatableEntryEditor);
      // Note: @figures and @tables are (dynamic) collections derived from the article's content
      config.addComponent('@figures', FiguresSectionComponent);
      config.addComponent('@tables', MetadataSection);

      // Commands
      config.addCommand('add-metadata-field', AddCustomMetadataFieldCommand, {
        commandGroup: 'custom-metadata-fields'
      });
      config.addCommand('add-figure-panel', AddFigurePanelCommand, {
        commandGroup: 'figure-panel'
      });
      config.addCommand('edit-author', EditEntityCommand, {
        selectionType: 'author',
        commandGroup: 'author'
      });
      config.addCommand('edit-reference', EditEntityCommand, {
        selectionType: 'reference',
        commandGroup: 'reference'
      });
      config.addCommand('move-down-col-item', MoveCollectionItemCommand, {
        direction: 'down',
        commandGroup: 'collection'
      });
      config.addCommand('move-down-metadata-field', MoveCustomMetadataFieldCommand, {
        direction: 'down',
        commandGroup: 'custom-metadata-fields'
      });
      config.addCommand('move-down-figure-panel', MoveFigurePanelCommand, {
        direction: 'down',
        commandGroup: 'figure-panel'
      });
      config.addCommand('move-up-col-item', MoveCollectionItemCommand, {
        direction: 'up',
        commandGroup: 'collection'
      });
      config.addCommand('move-up-metadata-field', MoveCustomMetadataFieldCommand, {
        direction: 'up',
        commandGroup: 'custom-metadata-fields'
      });
      config.addCommand('move-up-figure-panel', MoveFigurePanelCommand, {
        direction: 'up',
        commandGroup: 'figure-panel'
      });
      config.addCommand('open-figure-panel-image', OpenFigurePanelImageCommand, {
        commandGroup: 'figure-panel'
      });
      config.addCommand('open-manuscript', SwitchViewCommand, {
        viewName: 'manuscript',
        commandGroup: 'switch-view'
      });
      config.addCommand('open-metadata', SwitchViewCommand, {
        viewName: 'metadata',
        commandGroup: 'switch-view'
      });
      config.addCommand('remove-col-item', RemoveCollectionItemCommand, {
        commandGroup: 'collection'
      });
      config.addCommand('remove-footnote', RemoveItemCommand, {
        nodeType: 'footnote',
        commandGroup: 'footnote'
      });
      config.addCommand('remove-metadata-field', RemoveCustomMetadataFieldCommand, {
        commandGroup: 'custom-metadata-fields'
      });
      config.addCommand('remove-figure-panel', RemoveFigurePanelCommand, {
        commandGroup: 'figure-panel'
      });
      config.addCommand('remove-reference', RemoveReferenceCommand, {
        commandGroup: 'reference'
      });
      config.addCommand('replace-figure-panel-image', ReplaceFigurePanelImageCommand, {
        commandGroup: 'figure-panel'
      });
      config.addCommand('toggle-bold', substance.AnnotationCommand, {
        nodeType: 'bold',
        accelerator: 'CommandOrControl+B',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-italic', substance.AnnotationCommand, {
        nodeType: 'italic',
        accelerator: 'CommandOrControl+I',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-monospace', substance.AnnotationCommand, {
        nodeType: 'monospace',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-overline', substance.AnnotationCommand, {
        nodeType: 'overline',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-small-caps', substance.AnnotationCommand, {
        nodeType: 'small-caps',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-strike-through', substance.AnnotationCommand, {
        nodeType: 'strike-through',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-subscript', substance.AnnotationCommand, {
        nodeType: 'sub',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-superscript', substance.AnnotationCommand, {
        nodeType: 'sup',
        commandGroup: 'formatting'
      });
      config.addCommand('toggle-underline', substance.AnnotationCommand, {
        nodeType: 'underline',
        commandGroup: 'formatting'
      });

      // Tools
      config.addComponent('add-figure-panel', InsertFigurePanelTool);
      config.addComponent('open-figure-panel-image', OpenFigurePanelImageTool);
      config.addComponent('replace-figure-panel-image', ReplaceFigurePanelTool);

      // KeyboardShortcuts
      config.addKeyboardShortcut('CommandOrControl+Alt+Up', { command: 'move-up-col-item' });
      config.addKeyboardShortcut('CommandOrControl+Alt+Down', { command: 'move-down-col-item' });
      config.addKeyboardShortcut('CommandOrControl+Alt+Delete', { command: 'remove-col-item' });

      // Labels
      config.addLabel('article', 'Article Information');
      config.addLabel('article-information', 'Article Information');
      config.addLabel('authors', 'Authors');
      config.addLabel('figures', 'Figures');
      config.addLabel('footnotes', 'Footnotes');
      config.addLabel('groups', 'Groups');
      config.addLabel('issueTitle', 'Issue Title');
      config.addLabel('keywords', 'Keywords');
      config.addLabel('subjects', 'Subjects');
      config.addLabel('organisations', 'Affiliations');
      config.addLabel('references', 'References');
      config.addLabel('tables', 'Tables');
      config.addLabel('translations', 'Translations');
      config.addLabel('add-reference-title', 'Add Reference(s)');
      config.addLabel('add-ref-manually', 'Or create manually');
      config.addLabel('fetch-datacite', 'Fetch from DataCite');
      config.addLabel('enter-doi-placeholder', 'Enter one or more DOIs');
      config.addLabel('add-action', 'Add');
      config.addLabel('enter-url-placeholder', 'Enter url');
      config.addLabel('import-refs', 'Import');
      config.addLabel('supported-ref-formats', 'Supported formats');
      config.addLabel('original-translation', 'Original');
      config.addLabel('add-translation', 'Add Translation');
      config.addLabel('select-language', 'Select language');
      config.addLabel('add', 'Add');
      config.addLabel('edit', 'Edit');
      config.addLabel('remove', 'Remove');
      config.addLabel('workflows', 'Workflows');
      config.addLabel('select-license', 'Select license');
      config.addLabel('select-item', 'Choose');
      config.addLabel('move-down-figure-panel', 'Move Down Sub-Figure');
      config.addLabel('enter-custom-field-name', 'Enter name');
      config.addLabel('enter-custom-field-value', 'Enter value');
      config.addLabel('article-metadata', 'Article Metadata');
      config.addLabel('subtitle', 'Subtitle');
      config.addLabel('empty-figure-metadata', 'No fields specified');
      // Icons
      config.addIcon('move-down-figure-panel', { 'fontawesome': 'fa-caret-square-o-down' });
      config.addIcon('input-loading', { 'fontawesome': 'fa-spinner fa-spin' });
      config.addIcon('input-error', { 'fontawesome': 'fa-exclamation-circle' });

      // TODO: need to rethink this a some point
      registerCollectionCommand$1(config, 'author', ['metadata', 'authors'], { keyboardShortcut: 'CommandOrControl+Alt+A', nodeType: 'person' });
      registerCollectionCommand$1(config, 'funder', ['metadata', 'funders'], { keyboardShortcut: 'CommandOrControl+Alt+Y' });
      registerCollectionCommand$1(config, 'editor', ['metadata', 'editors'], { keyboardShortcut: 'CommandOrControl+Alt+E', nodeType: 'person' });
      registerCollectionCommand$1(config, 'footnote', ['article', 'footnotes'], { automaticOrder: true, Command: InsertFootnoteCommand });
      registerCollectionCommand$1(config, 'group', ['metadata', 'groups'], { keyboardShortcut: 'CommandOrControl+Alt+G' });
      registerCollectionCommand$1(config, 'keyword', ['metadata', 'keywords'], { keyboardShortcut: 'CommandOrControl+Alt+K' });
      registerCollectionCommand$1(config, 'organisation', ['metadata', 'organisations'], { keyboardShortcut: 'CommandOrControl+Alt+O' });
      registerCollectionCommand$1(config, 'subject', ['metadata', 'subjects']);
      config.addCommand('insert-reference', AddEntityCommand, {
        workflow: 'add-reference',
        commandGroup: 'add-entity',
        type: 'bibr'
      });
    }
  }

  // TODO: this is like an overkill, registering one collection item command
  // for every collection type
  // it would be better to have just one set of commands
  // which is detecting the collection automagically
  // The challenge will then be how to control certain things,
  // such as disabling move up/down etc.
  function registerCollectionCommand$1 (config, itemType, collectionPath, options = {}) {
    let nodeType = options.nodeType || itemType;
    let xpathSelector = substance.getKeyForPath(collectionPath);
    let Command = options.Command || AddEntityCommand;
    config.addCommand(`insert-${itemType}`, Command, {
      type: nodeType,
      collection: collectionPath,
      commandGroup: 'add-entity'
    });
    if (options.keyboardShortcut) {
      config.addKeyboardShortcut(options.keyboardShortcut, { command: `add-${itemType}` });
    }
    if (!options.automaticOrder) {
      config.addCommand(`move-up-${itemType}`, MoveCollectionItemCommand, {
        direction: 'up',
        commandGroup: 'collection',
        xpathSelector
      });
      config.addIcon(`move-up-${itemType}`, { 'fontawesome': 'fa-caret-square-o-up' });
      config.addLabel(`move-up-${itemType}`, {
        en: 'Move item up'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+Up', { command: `move-up-${itemType}` });
      config.addCommand(`move-down-${itemType}`, MoveCollectionItemCommand, {
        direction: 'down',
        commandGroup: 'collection',
        xpathSelector
      });
      config.addIcon(`move-down-${itemType}`, { 'fontawesome': 'fa-caret-square-o-down' });
      config.addLabel(`move-down-${itemType}`, {
        en: 'Move item down'
      });
      config.addKeyboardShortcut('CommandOrControl+Alt+Down', { command: `move-down-${itemType}` });
      config.addCommand(`remove-${itemType}`, RemoveCollectionItemCommand, {
        commandGroup: 'collection',
        xpathSelector
      });

      config.addIcon('remove', { 'fontawesome': 'fa-trash' });
      config.addIcon('checked-item', { 'fontawesome': 'fa-check-square-o' });
      config.addIcon('unchecked-item', { 'fontawesome': 'fa-square-o' });
    }
    config.addIcon(`remove-${itemType}`, { 'fontawesome': 'fa-trash' });
    config.addLabel(`remove-${itemType}`, {
      en: 'Remove item'
    });
    config.addKeyboardShortcut('CommandOrControl+Alt+Delete', { command: `remove-${itemType}` });
  }

  var DefaultSettings = {
    'article-ref.authors': { required: true },
    'article-ref.containerTitle': { required: true },
    'article-ref.title': { required: true },
    'book-ref.authors': { required: true },
    'book-ref.title': { required: true },
    'chapter-ref.authors': { required: true },
    'chapter-ref.containerTitle': { required: true },
    'chapter-ref.title': { required: true },
    'conference-paper-ref.authors': { required: true },
    'conference-paper-ref.title': { required: true },
    'data-publication-ref.authors': { required: true },
    'data-publication-ref.containerTitle': { required: true },
    'data-publication-ref.title': { required: true },
    'figure-panel.title': { required: true },
    'funder.institution': { required: true },
    'group.name': { required: true },
    'journal-article-ref.authors': { required: true },
    'journal-article-ref.containerTitle': { required: true },
    'journal-article-ref.title': { required: true },
    'keyword.name': { required: true },
    'magazine-article-ref.authors': { required: true },
    'magazine-article-ref.containerTitle': { required: true },
    'magazine-article-ref.title': { required: true },
    'newspaper-article-ref.authors': { required: true },
    'newspaper-article-ref.containerTitle': { required: true },
    'newspaper-article-ref.title': { required: true },
    'patent-ref.containerTitle': { required: true },
    'patent-ref.inventors': { required: true },
    'patent-ref.title': { required: true },
    'person.givenNames': { required: true },
    'person.surname': { required: true },
    'ref-contrib.givenNames': { required: true },
    'ref-contrib.name': { required: true },
    'report-ref.authors': { required: true },
    'report-ref.title': { required: true },
    'software-ref.authors': { required: true },
    'software-ref.title': { required: true },
    'subject.name': { required: true },
    'thesis-ref.authors': { required: true },
    'thesis-ref.title': { required: true },
    'thesis-ref.year': { required: true },
    'webpage-ref.authors': { required: true },
    'webpage-ref.containerTitle': { required: true },
    'webpage-ref.title': { required: true }
  }

  const EMPTY = Object.freeze({});

  // ATTENTION: this is a prototype implementation and will be redesigned when the requirements clear.
  class ExperimentalEditorSettings {
    constructor () {
      this._settings = new substance.TreeIndex();
    }

    // getConfiguration (xpath) {
    //   // ATTENTION: for the moment only non-hierarchical selectors
    //   let current = last(xpath)
    //   let config = this._settings
    //   let nodeConfig = config[current.type]
    //   let result = EMPTY
    //   if (nodeConfig) {
    //     let propConfig = nodeConfig[current.property]
    //     if (propConfig) {
    //       result = propConfig
    //     }
    //   }
    //   return result
    // }

    getSettingsForValue (path) {
      return this._settings.get(path) || EMPTY
    }

    load (settings) {
      this._settings.clear();
      this.extend(settings);
    }

    extend (settings) {
      let selectors = Object.keys(settings);
      for (let selector of selectors) {
        this._extendValueSettings(selector, settings[selector]);
      }
    }

    _extendValueSettings (selector, spec) {
      if (selector.indexOf('<') !== -1) throw new Error('hierarchical selectors not supported yet')
      let path = selector.trim().split('.');
      let valueSettings = this._settings.get(path);
      if (!valueSettings) {
        valueSettings = {};
        this._settings.set(path, valueSettings);
      }
      Object.assign(valueSettings, spec);
    }
  }

  var FigurePackageSettings = {}

  const DEFAULT_VIEW = 'manuscript';
  const VIEWS = ['manuscript', 'metadata'];

  class ArticlePanel extends substance.Component {
    constructor (...args) {
      super(...args);

      // Store the viewports, so we can restore scroll positions
      this._viewStates = new Map();

      // TODO: should we really (ab-)use the regular Component state as AppState?
      this._initialize(this.props, this.state);

      this.handleActions({
        'updateViewName': this._updateViewName
      });
    }

    _initialize (props) {
      // TODO: I want to move to a single-layer setup for all views in this panel,
      // i.e. no extra configurations and if possible no extra editor session
      // and instead contextualize commands tools etc.
      const { archive, config, documentSession } = props;
      const doc = documentSession.getDocument();

      this.context = Object.assign(this.context, createComponentContext(config), {
        urlResolver: archive,
        appState: this.state
      });

      // setup view states
      for (let viewName of VIEWS) {
        let viewConfig = props.config.getConfiguration(viewName);
        let editorState = EditorSession.createEditorState(documentSession, {
          workflowId: null,
          viewName,
          settings: this._createSettings(doc)
        });
        this._viewStates.set(viewName, {
          config: viewConfig,
          editorState,
          // Note: used to retain scroll position when switching between views
          viewport: null
        });
      }
    }

    getInitialState () {
      // using AppState as Component state
      return this._createAppState(this.props.config)
    }

    willReceiveProps (props) {
      if (props.documentSession !== this.props.documentSession) {
        let state = this._createAppState(props.config);
        this._initialize(props, state);
        // wipe children and update state
        this.empty();
        this.setState(state);
      }
    }

    getChildContext () {
      return {
        articlePanel: this,
        appState: this.state
      }
    }

    didMount () {
      let router = this.context.router;
      if (router) {
        this._onRouteChange(router.readRoute());
        router.on('route:changed', this._onRouteChange, this);
      }
    }

    dispose () {
      let router = this.context.router;
      if (router) {
        router.off(this);
      }
    }

    shouldRerender (newProps, newState) {
      return (
        newProps.documentSession !== this.props.documentSession ||
        newProps.config !== this.props.config ||
        newState !== this.state
      )
    }

    render ($$) {
      let el = $$('div').addClass('sc-article-panel');
      el.append(
        this._renderContent($$)
      );
      return el
    }

    _renderContent ($$) {
      const props = this.props;
      const viewName = this.state.viewName;
      const api = this.api;
      const archive = props.archive;
      const articleSession = props.documentSession;
      const { config, editorState, viewport } = this._viewStates.get(viewName);

      let ContentComponent;
      switch (viewName) {
        case 'manuscript': {
          ContentComponent = this.getComponent('manuscript-editor');
          break
        }
        case 'metadata': {
          ContentComponent = this.getComponent('metadata-editor');
          break
        }
        default:
          throw new Error('Unsupported view: ' + viewName)
      }
      return $$(ContentComponent, {
        api,
        archive,
        articleSession,
        config,
        editorState,
        viewName,
        viewport
      }).ref('content')
    }

    _createAppState (config) { // eslint-disable-line no-unused-vars
      const appState = new AppState({
        viewName: DEFAULT_VIEW
      });
      appState.addObserver(['viewName'], this.rerender, this, { stage: 'render' });
      return appState
    }

    // EXPERIMENTAL:
    // this is a first prototype for settings used to control editability and required fields
    // On the long run we need to understand better what different means of configuration we want to offer
    _createSettings (doc) {
      let settings = new ExperimentalEditorSettings();
      let metadata = doc.get('metadata');
      // Default settings
      settings.load(DefaultSettings);
      // Article type specific settings
      if (metadata.articleType === 'figure-package') {
        settings.extend(FigurePackageSettings);
      }
      return settings
    }

    _updateViewName (viewName) {
      let oldViewName = this.state.viewName;
      if (oldViewName !== viewName) {
        this._viewStates.get(oldViewName).viewport = this.refs.content.getViewport();
        let router = this.context.router;
        // ATTENTION: do not change the route when running tests otherwise the test url get's lost
        if (router && !substance.platform.test) {
          router.writeRoute({ viewName });
        }
        this.extendState({ viewName });
      }
    }

    _handleKeydown (e) {
      // console.log('ArticlePanel._handleKeydown', e)
      // ATTENTION: asking the currently active content to handle the keydown event first
      let handled = this.refs.content._onKeydown(e);
      // Note: if we had a keyboardManager here we could ask it to handle the event
      // if (!handled) {
      //   handled = this.context.keyboardManager.onKeydown(e, this.context)
      // }
      if (handled) {
        e.stopPropagation();
        e.preventDefault();
      }
      return handled
    }

    _onRouteChange (data) {
      // EXPERIMENTAL: taking an object from the router
      // and interpreting it to navigate to the right location in the app
      let { viewName, nodeId, section } = data;
      let el;
      if (viewName && viewName !== this.state.viewName) {
        this.extendState({ viewName });
      }
      if (nodeId) {
        // NOTE: we need to search elements only inside editor
        // since TOC contains the same attributes
        el = this.el.find(`.se-content [data-id='${nodeId}']`);
      } else if (section) {
        // NOTE: since we are using dots inside id attributes,
        // we need to be careful with a dom query
        el = this.el.find(`.se-content [data-section='${section}']`);
      }
      if (el) {
        // forcing scroll, i.e. bringing target element always to the top
        this.refs.content.send('scrollElementIntoView', el, true);
      }
    }
  }

  /**
   * An artificial collection model, that is generated from the article body
   */
  class FigureCollectionModel {
    constructor (api) {
      this._api = api;
    }

    get id () {
      return '@figures'
    }

    get type () {
      return '@figures'
    }

    get length () {
      return this.getItems().length
    }

    get isCollection () {
      return true
    }

    getItems () {
      let doc = this._api.getDocument();
      return doc.get('body').findAll('figure')
    }
  }

  /**
   * An artificial collection model, that is generated from the article body
   */
  class TableFigureCollectionModel {
    constructor (api) {
      this._api = api;
    }

    get id () { return '@tables' }

    get type () { return 'collection' }

    get isCollection () {
      return true
    }

    getItems () {
      let doc = this._api.getDocument();
      return doc.get('body').findAll('table-figure')
    }

    get length () {
      return this.getItems().length
    }
  }

  class ArticleInformationSectionModel {
    constructor (api) {
      this._api = api;
      const doc = api.getDocument();
      this.cards = [
        { name: 'title', model: createValueModel(api, ['article', 'title']), placeholder: 'title-placeholder' },
        { name: 'subtitle', model: createValueModel(api, ['article', 'subTitle']), placeholder: 'subtitle-placeholder' },
        { name: 'abstract', model: createValueModel(api, ['article', 'abstract']), placeholder: 'abstract-placeholder' },
        { name: 'article-metadata', model: { id: 'article-metadata', node: doc.get('metadata') } }
      ];
    }

    get id () {
      return 'article-information'
    }
  }

  /**
   * This is an artificial Model used to control the content displayed in the Metadata view.
   */
  class MetadataModel {
    constructor (api) {
      this._api = api;
      this._sections = [
        { name: 'article-information', model: new ArticleInformationSectionModel(api) },
        { name: 'authors', model: createValueModel(api, ['metadata', 'authors']) },
        { name: 'editors', model: createValueModel(api, ['metadata', 'editors']) },
        { name: 'groups', model: createValueModel(api, ['metadata', 'groups']) },
        { name: 'organisations', model: createValueModel(api, ['metadata', 'organisations']) },
        { name: 'funders', model: createValueModel(api, ['metadata', 'funders']) },
        { name: 'keywords', model: createValueModel(api, ['metadata', 'keywords']) },
        { name: 'subjects', model: createValueModel(api, ['metadata', 'subjects']) },
        // HACK: 'article-section' is a fake model
        // TODO: we should allow sections without model and create the section via name
        { name: 'figures', model: new FigureCollectionModel(api) },
        { name: 'tables', model: new TableFigureCollectionModel(api) },
        { name: 'references', model: createValueModel(api, ['article', 'references']) },
        { name: 'footnotes', model: createValueModel(api, ['article', 'footnotes']) }
      ];
    }

    getSections () {
      return this._sections
    }
  }

  class MetadataSectionTOCEntry extends ModelComponent {
    render ($$) {
      const name = this.props.name;
      const model = this.props.model;
      let el = $$('div').addClass('sc-meta-section-toc-entry sc-toc-entry')
        .attr({ 'data-section': name })
        .on('click', this.handleClick);

      let label = this.getLabel(name);
      if (model.isCollection) {
        const items = model.getItems();
        if (items.length > 0) {
          label = label + ' (' + items.length + ')';
          el.append(label);
        } else {
          el.addClass('sm-empty');
        }
      } else {
        el.append(label);
      }

      return el
    }

    handleClick (event) {
      event.stopPropagation();
      event.preventDefault();
      // this is handled by MetadataEditor
      this.send('scrollTo', { section: this.props.name });
    }
  }

  /* eslint-disable no-use-before-define */

  /*
    EXPERIMENTAL: This should only be used as a prototype.
    After that must consolidate requirements and refactor.
  */

  class ExperimentalArticleValidator {
    // TODO: maybe we want to use ArticleAPI here
    constructor (api) {
      this._api = api;
    }

    initialize () {
      let article = this._getArticle();
      let editorState = this._getEditorState();
      substance.forEach(article.getNodes(), node => {
        CheckRequiredFields.onCreate(this, node);
      });
      // TODO: or should we bind to editorState updates?
      editorState.addObserver(['document'], this._onDocumentChange, this, { stage: 'update' });
    }

    dispose () {
      let editorState = this._getEditorState();
      editorState.removeObserver(this);
    }

    /*
      Thought: potentially there are different kind of issues
    */
    clearIssues (path, type) {
      // Note: storing the issues grouped by propertyName in node['@issues']
      let nodeIssues = this._getNodeIssues(path[0]);
      nodeIssues.clear(substance.getKeyForPath(path.slice(1)), type);
      this._markAsDirty(path);
    }

    /*
      Thoughts: adding issues one-by-one, and clearing by type
    */
    addIssue (path, issue) {
      // console.log('ArticleValidator: adding issue for %s', getKeyForPath(path), issue)
      let nodeIssues = this._getNodeIssues(path[0]);
      nodeIssues.add(substance.getKeyForPath(path.slice(1)), issue);
      this._markAsDirty(path);
    }

    _getEditorState () {
      return this._api.editorSession.editorState
    }

    _markAsDirty (path) {
      let editorState = this._getEditorState();
      // Note: marking both the node and the property as dirty
      const documentObserver = editorState._getDocumentObserver();
      const nodeId = path[0];
      let issuesPath = [nodeId, '@issues'];
      documentObserver.setDirty(issuesPath);
      documentObserver.setDirty(issuesPath.concat(path.slice(1)));
    }

    _getNodeIssues (nodeId) {
      const article = this._getArticle();
      let node = article.get(nodeId);
      let issues = node['@issues'];
      if (!issues) {
        issues = new NodeIssues();
        node['@issues'] = issues;
      }
      return issues
    }

    /*
      Thoughts: the validator is triggered on document change, analyzing the change
      and triggering registered validators accordingly.
    */
    _onDocumentChange (change) {
      // ATTENTION: this is only a prototype implementation
      // This must be redesigned/rewritten when we move further
      const article = this._getArticle();
      // TODO: a DocumentChange could carry a lot more information
      // e.g. uodated[key] = { path, node, value }
      // It would also be better to separate explicit updates (~op.path) from derived updates (node id, annotation updates)
      Object.keys(change.created).forEach(id => {
        let node = article.get(id);
        if (node) {
          CheckRequiredFields.onCreate(this, node);
        }
      });
      Object.keys(change.updated).forEach(key => {
        let path = key.split('.');
        let node = article.get(path[0]);
        if (node) {
          CheckRequiredFields.onUpdate(this, node, path, article.get(path));
        }
      });
    }

    _getArticle () {
      return this._api.getDocument()
    }

    _getApi () {
      return this._api
    }
  }

  const FIELD_IS_REQUIRED = {
    type: 'required-fields',
    label: 'field-is-required',
    message: 'Field is required'
  };

  const CheckRequiredFields = {
    onCreate (validator, node) {
      const api = validator._getApi();
      let data = node.toJSON();
      Object.keys(data).forEach(name => {
        if (api._isFieldRequired([node.type, name])) {
          this.onUpdate(validator, node, [node.id, name], data[name]);
        }
      });
    },
    onUpdate (validator, node, path, value) {
      const api = validator._getApi();
      if (api._isFieldRequired([node.type].concat(path.slice(1)))) {
        validator.clearIssues(path, FIELD_IS_REQUIRED.type);
        // TODO: we probably want to use smarter validators than this
        if (substance.isNil(value) || value === '') {
          validator.addIssue(path, FIELD_IS_REQUIRED);
        }
      }
    }
  };

  class NodeIssues {
    constructor () {
      this._issuesByProperty = new Map();
    }

    get (propName) {
      return this._issuesByProperty.get(propName)
    }

    add (propName, issue) {
      if (!this._issuesByProperty.has(propName)) {
        this._issuesByProperty.set(propName, []);
      }
      let issues = this._issuesByProperty.get(propName);
      issues.push(issue);
    }

    clear (propName, type) {
      if (this._issuesByProperty.has(propName)) {
        let issues = this._issuesByProperty.get(propName);
        for (let i = issues.length - 1; i >= 0; i--) {
          if (issues[i].type === type) {
            issues.splice(i, 1);
          }
        }
        if (issues.length === 0) {
          this._issuesByProperty.delete(propName);
        }
      }
    }

    get size () {
      let size = 0;
      this._issuesByProperty.forEach(issues => {
        size += issues.length;
      });
      return size
    }
  }

  class MetadataEditor extends EditorPanel {
    _initialize (props) {
      super._initialize(props);

      this.articleValidator = new ExperimentalArticleValidator(this.api);
      this.model = new MetadataModel(this.editorSession);

      // ATTENTION/HACK: this is making all properties dirty, so we have to reset the appState after that
      this.articleValidator.initialize();
      this.appState._reset();
    }

    didMount () {
      super.didMount();
      this._showHideTOC();
      this._restoreViewport();
      substance.DefaultDOMElement.getBrowserWindow().on('resize', this._showHideTOC, this);
    }

    didUpdate () {
      super.didUpdate();
      this._restoreViewport();
    }

    dispose () {
      super.dispose();
      this.articleValidator.dispose();
      substance.DefaultDOMElement.getBrowserWindow().off(this);
    }

    getViewport () {
      return {
        x: this.refs.contentPanel.getScrollPosition()
      }
    }

    render ($$) {
      let el = $$('div').addClass('sc-metadata-editor');
      el.append(
        this._renderMainSection($$)
      );
      el.on('keydown', this._onKeydown);
      return el
    }

    setSelection (sel) {
      let editorSession = this.editorSession;
      editorSession.setSelection(sel);
    }

    _createModelSelection (modelId) {
      return {
        type: 'custom',
        customType: 'model',
        nodeId: modelId,
        data: {
          modelId
        }
      }
    }

    _renderMainSection ($$) {
      const appState = this.context.appState;
      let mainSection = $$('div').addClass('se-main-section');
      mainSection.append(
        this._renderToolbar($$),
        $$('div').addClass('se-content-section').append(
          this._renderTOCPane($$),
          this._renderContentPanel($$)
        // TODO: do we need this ref?
        ).ref('contentSection'),
        this._renderFooterPane($$)
      );
      if (appState.workflowId) {
        mainSection.append(
          this._renderWorkflow($$, appState.workflowId)
        );
      }
      return mainSection
    }

    _renderToolbar ($$) {
      const Toolbar$$1 = this.getComponent('toolbar');
      let config = this.props.config;
      const items = config.getToolPanel('toolbar');
      return $$('div').addClass('se-toolbar-wrapper').append(
        $$(Managed(Toolbar$$1), {
          items,
          bindings: ['commandStates']
        // TODO: do we need this ref?
        }).ref('toolbar')
      )
    }

    _renderTOCPane ($$) {
      const sections = this.model.getSections();

      let el = $$('div').addClass('se-toc-pane').ref('tocPane');
      let tocEl = $$('div').addClass('se-toc');

      sections.forEach(({ name, model }) => {
        let id = model.id;
        tocEl.append(
          $$(MetadataSectionTOCEntry, {
            id,
            name,
            model
          })
        );
      });

      el.append(tocEl);
      return el
    }

    _renderContentPanel ($$) {
      const sections = this.model.getSections();
      const ScrollPane$$1 = this.getComponent('scroll-pane');

      let contentPanel = $$(ScrollPane$$1, {
        contextMenu: 'custom',
        scrollbarPosition: 'right'
      // NOTE: this ref is needed to access the root element of the editable content
      }).ref('contentPanel');

      let sectionsEl = $$('div').addClass('se-sections');

      sections.forEach(({ name, model }) => {
        let SectionComponent = this._getSectionComponent(name, model);
        let content = $$(SectionComponent, { name, model }).ref(name);
        sectionsEl.append(content);
      });

      contentPanel.append(sectionsEl);

      return contentPanel
    }

    _getSectionComponent (name, model) {
      return MetadataSection
    }

    _renderFooterPane ($$) {
      const FindAndReplaceDialog = this.getComponent('find-and-replace-dialog');
      let el = $$('div').addClass('se-footer-pane');
      el.append(
        $$(FindAndReplaceDialog, {
          theme: this._getTheme(),
          viewName: 'metadata'
        // TODO: do we need this ref?
        }).ref('findAndReplace')
      );
      return el
    }

    _getContentPanel () {
      return this.refs.contentPanel
    }

    _showHideTOC () {
      let contentSectionWidth = this.refs.contentSection.el.width;
      if (contentSectionWidth < 960) {
        this.el.addClass('sm-compact');
      } else {
        this.el.removeClass('sm-compact');
      }
    }
  }

  var ArticlePackage = {
    name: 'Article',
    configure (parentConfig) {
      parentConfig.addComponent('article', ArticlePanel);
      // create a configuration scope
      let config = parentConfig.createScope('article');

      // used during import
      let modelConfig = new ArticleConfigurator().import(ArticleModelPackage);
      config.setConfiguration('model', modelConfig);
      // used for the manuscript editor view
      let manuscriptEditorConfig = ArticleConfigurator.createFrom(modelConfig).import(EditorPackage);
      config.setConfiguration('manuscript', manuscriptEditorConfig);
      // used for the metadata editor view
      let metadataEditorConfig = ArticleConfigurator.createFrom(modelConfig).import(MetadataPackage);
      config.setConfiguration('metadata', metadataEditorConfig);

      config.import(BasePackage);
      // UI stuff for the ArticlePanel
      config.addComponent('manuscript-editor', ManuscriptEditor);
      config.addComponent('metadata-editor', MetadataEditor);
    }
  }

  class TextureArticleExporter extends substance.XMLExporter {

  }

  const DOT = '.'.charCodeAt(0);

  /*
    Retrieves a list of entries recursively, including file names and stats.
  */
  async function listDir (dir, opts = {}) {
    return new Promise((resolve, reject) => {
      _list(dir, opts, (err, records) => {
        if (err) reject(err);
        else resolve(records);
      });
    })
  }

  function _list (dir, opts, done) {
    let fs = opts.fs || require('fs');
    let path = opts.path || require('path');
    let results = [];
    fs.readdir(dir, (err, list) => {
      if (err) return done(err)
      let pending = list.length;
      if (!pending) return done(null, results)
      function _continue () {
        if (!--pending) done(null, results);
      }
      list.forEach((name) => {
        if (opts.ignoreDotFiles && name.charCodeAt(0) === DOT) {
          return _continue()
        }
        let absPath = path.resolve(dir, name);
        fs.stat(absPath, (err, stat) => {
          if (err) return done(err)
          if (stat && stat.isDirectory()) {
            _list(name, opts, (err, res) => {
              if (err) return done(err)
              results = results.concat(res);
              _continue();
            });
          } else {
            results.push(Object.assign({}, stat, {
              name,
              path: absPath
            }));
            _continue();
          }
        });
      });
    });
  }

  async function isDocumentArchive (archiveDir, opts = {}) {
    let path = opts.path || require('path');
    // assuming it is a DAR if the folder exists and there is a manifest.xml
    return _fileExists(path.join(archiveDir, 'manifest.xml'), opts)
  }

  function _fileExists (archivePath, opts) {
    let fs = opts.fs || require('fs');
    return new Promise((resolve, reject) => {
      fs.stat(archivePath, (err, stats) => {
        if (err) reject(err);
        else resolve(stats && stats.isFile());
      });
    })
  }

  // these extensions are considered to have text content
  const TEXTISH = ['txt', 'html', 'xml', 'json'];

  /*
    Provides a list of records found in an archive folder.

    @param {object} opts
      - `noBinaryData`: do not load the content of binary files
      - `ignoreDotFiles`: ignore dot-files
      - versioning: set to true if versioning should be enabled
  */
  async function readArchive (archiveDir, opts = {}) {
    // make sure that the given path is a dar
    if (await isDocumentArchive(archiveDir, opts)) {
      // first get a list of stats
      const entries = await listDir(archiveDir, opts);
      // then get file records as specified TODO:link
      let resources = {};
      for (var i = 0; i < entries.length; i++) {
        let entry = entries[i];
        let record = await _getFileRecord(entry, opts);
        resources[record.path] = record;
      }
      return {
        resources,
        version: '0'
      }
    } else {
      throw new Error(archiveDir + ' is not a valid document archive.')
    }
  }

  /*
    Provides a record for a file as it is used for the DocumentArchive persistence protocol.

    Binary files can be exluced using `opts.noBinaryData`.

    @example

    ```
    {
      id: 'manuscript.xml',
      encoding: 'utf8',
      data: '<article>....</article>',
      size: 5782,
      createdAt: 123098123098,
      updatedAt: 123234567890,
    }
    ```
  */
  async function _getFileRecord (fileEntry, opts) {
    let fs = opts.fs || require('fs');
    // for text files load content
    // for binaries use a url
    let record = {
      path: fileEntry.name,
      encoding: null,
      size: fileEntry.size,
      createdAt: fileEntry.birthtime.getTime(),
      updatedAt: fileEntry.mtime.getTime()
    };
    if (_isTextFile(fileEntry.name)) {
      return new Promise((resolve, reject) => {
        fs.readFile(fileEntry.path, 'utf8', (err, content) => {
          if (err) return reject(err)
          record.encoding = 'utf8';
          record.data = content;
          resolve(record);
        });
      })
    } else {
      // used internally only
      record._binary = true;
      if (opts.noBinaryContent) {
        return Promise.resolve(record)
      } else {
        return new Promise((resolve, reject) => {
          fs.readFile(fileEntry.path, 'hex', (err, content) => {
            if (err) return reject(err)
            record.encoding = 'hex';
            record.data = content;
            resolve(record);
          });
        })
      }
    }
  }

  function _isTextFile (f) {
    return new RegExp(`\\.(${TEXTISH.join('|')})$`).exec(f)
  }

  async function writeArchive (archiveDir, rawArchive, opts = {}) {
    const fs = opts.path || require('fs');
    const path = opts.path || require('path');

    let resourceNames = Object.keys(rawArchive.resources);
    let newVersion = '0';

    if (opts.versioning) {
      console.warn('Git based versioning is not yet implemented.');
    }

    return Promise.all(resourceNames.map(f => {
      let record = rawArchive.resources[f];
      let absPath = path.join(archiveDir, f);
      switch (record.encoding) {
        case 'utf8': {
          return _writeFile(fs, absPath, record.data, 'utf8')
        }
        case 'blob': {
          return _writeFile(fs, absPath, record.data)
        }
        // TODO: are there other encodings which we want to support?
        default:
          return false
      }
    })).then(() => {
      return newVersion
    })
  }

  function _writeFile (fs, p, data, encoding) {
    return new Promise((resolve, reject) => {
      if (typeof data.pipe === 'function') {
        let file = fs.createWriteStream(p);
        data.pipe(file);
        file.on('close', () => {
          resolve();
        });
      } else {
        fs.writeFile(p, data, encoding, (err) => {
          if (err) reject(err);
          else resolve();
        });
      }
    })
  }

  // FIXME: this file should only get bundled in commonjs version
  let fsExtra;
  if (substance.platform.inNodeJS || substance.platform.inElectron) {
    fsExtra = require('fs-extra');
  }

  async function cloneArchive (archiveDir, newArchiveDir, opts = {}) {
    // make sure that the given path is a dar
    if (await isDocumentArchive(archiveDir, opts)) {
      await fsExtra.copy(archiveDir, newArchiveDir);
      return true
    } else {
      throw new Error(archiveDir + ' is not a valid document archive.')
    }
  }

  /* global Buffer */

  // FIXME: this file should only get bundled in commonjs version
  let fs, path;
  if (substance.platform.inNodeJS || substance.platform.inElectron) {
    fs = require('fs');
    path = require('path');
  }

  /*
    A storage client optimised for Desktop clients

    NOTE: No versioning is done atm, but users can do a git init in their Dar
    folders.
  */
  class FSStorage {
    constructor (rootDir) {
      this._rootDir = rootDir;
    }

    read (archiveDir, cb) {
      archiveDir = this._normalizeArchiveDir(archiveDir);
      readArchive(archiveDir, { noBinaryContent: true, ignoreDotFiles: true })
        .then(rawArchive => {
          // Turn binaries into urls
          Object.keys(rawArchive.resources).forEach(recordPath => {
            let record = rawArchive.resources[recordPath];
            if (record._binary) {
              delete record._binary;
              record.encoding = 'url';
              record.data = path.join(archiveDir, record.path);
            }
          });
          cb(null, rawArchive);
        })
        .catch(cb);
    }

    write (archiveDir, rawArchive, cb) {
      archiveDir = this._normalizeArchiveDir(archiveDir);
      _convertBlobs(rawArchive)
        .then(() => {
          return writeArchive(archiveDir, rawArchive)
        })
        .then((version) => {
          cb(null, JSON.stringify({ version }));
        })
        .catch(cb);
    }

    clone (archiveDir, newArchiveDir, cb) {
      archiveDir = this._normalizeArchiveDir(archiveDir);
      newArchiveDir = this._normalizeArchiveDir(newArchiveDir);
      cloneArchive(archiveDir, newArchiveDir)
        .then(success => {
          if (success) cb();
          else cb(new Error('Could not clone archive'));
        })
        .catch(cb);
    }

    _normalizeArchiveDir (archiveDir) {
      if (this._rootDir) {
        archiveDir = path.join(this._rootDir, archiveDir);
      }
      return archiveDir
    }
  }

  /*
    Convert all blobs to array buffers
  */
  async function _convertBlobs (rawArchive) {
    let resources = rawArchive.resources;
    let paths = Object.keys(resources);
    for (var i = 0; i < paths.length; i++) {
      let record = resources[paths[i]];
      if (record.encoding === 'blob') {
        record.data = await _blobToArrayBuffer(record.data);
      }
    }
  }

  function _blobToArrayBuffer (blob) {
    return new Promise((resolve, reject) => {
      // TODO: is there other way to get buffer out of Blob without browser APIs?
      fs.readFile(blob.path, (err, buffer) => {
        if (err) return reject(err)
        resolve(buffer);
      });
    })
  }

  // FIXME: this file should only get bundled in commonjs version
  let fs$1, fsExtra$1, path$1, yazl, yauzl;
  if (substance.platform.inNodeJS || substance.platform.inElectron) {
    fs$1 = require('fs');
    fsExtra$1 = require('fs-extra');
    path$1 = require('path');
    yazl = require('yazl');
    yauzl = require('yauzl');
  }

  /*
    This storage is used to store working copies of '.dar' files that are located somewhere else on the file-system.
    Texture will first update the working copy, and then updates (rewrites) the `.dar` file.

    The implementation will be done in three major iterations

    Phase I: bare-metal file-system, without versioning etc.
    - open: `dar` file is unpacked into the corresponding internal folder
    - save: internal folder is packed replacing the 'dar' file
    - new: internal folder is created and somehow seeded
    - saveas: internal folder is updated first (like in the current implementation), then cloned into a new internal folder corresponding
        to the new 'dar' file location, and packing the folder into the target 'dar'

    Phase II: basic versioning
    The idea is to have a `.dar` folder within a `dar` file that contains data used to implement versioning. We will use `hyperdrive` for that
    TODO: flesh out the concept

    Phase III: collaboration
    In addition to `hyperdrive` data we will store Texture DAR changes in the `.dar` folder. E.g., this would allow to merge two `dar` files that have a common
    version in their history.

    Status: Phase I
  */
  class DarFileStorage {
    constructor (rootDir, baseUrl) {
      this.rootDir = rootDir;
      this.baseUrl = baseUrl;

      this._internalStorage = new FSStorage();
    }

    read (darpath, cb) {
      // console.log('DarFileStorage::read', darpath)
      /*
        - unpack `dar` file as it is into the corresponding folder replacing an existing one
        - only bare-metal fs
      */
      let id = this._path2Id(darpath);
      let wcDir = this._getWorkingCopyPath(id);
      fsExtra$1.removeSync(wcDir);
      fsExtra$1.mkdirpSync(wcDir);
      this._unpack(darpath, wcDir, err => {
        if (err) return cb(err)
        this._internalStorage.read(wcDir, cb);
      });
    }

    write (darpath, rawArchive, cb) { // eslint-disble-line
      let id = this._path2Id(darpath);
      let wcDir = this._getWorkingCopyPath(id);
      this._internalStorage.write(wcDir, rawArchive, err => {
        if (err) return cb(err)
        this._pack(wcDir, darpath, cb);
      });
    }

    clone (darpath, newDarpath, cb) { // eslint-disble-line
      let id = this._path2Id(darpath);
      let wcDir = this._getWorkingCopyPath(id);
      let newId = this._path2Id(newDarpath);
      let newWcDir = this._getWorkingCopyPath(newId);
      this._internalStorage.clone(wcDir, newWcDir, err => {
        if (err) return cb(err)
        this._pack(newWcDir, newDarpath, cb);
      });
    }

    _path2Id (darpath) {
      darpath = String(darpath);
      darpath = path$1.normalize(darpath);
      // convert: '\\' to '/'
      darpath = darpath.replace(/\\+/g, '/');
      // split path into fragments: dir, name, extension
      let { dir, name } = path$1.parse(darpath);
      // ATTENTION: it is probably possible to create collisions here if somebody uses '@' in a bad way.
      // For now, this is acceptable because it is not realistic.
      // Adding an extra slash that got dropped by path.parse().
      dir += '/';
      // replace '/' with '@slash@'
      dir = dir.replace(/\//g, '@slash@');
      // replace ':' with '@colon@'
      dir = dir.replace(/:/g, '@colon@');
      return dir + name
    }

    _getWorkingCopyPath (id) {
      return path$1.join(this.rootDir, id)
    }

    _unpack (darpath, wcDir, cb) {
      // console.log('DarFileStorage::_unpack', darpath, wcDir)
      yauzl.open(darpath, { lazyEntries: true }, (err, zipfile) => {
        if (err) cb(err);
        zipfile.readEntry();
        zipfile.on('entry', (entry) => {
          // dir entry
          if (/\/$/.test(entry.fileName)) {
            zipfile.readEntry();
          // file entry
          } else {
            // console.log('... unpacking', entry.fileName)
            zipfile.openReadStream(entry, (err, readStream) => {
              if (err) throw err
              readStream.on('end', () => {
                zipfile.readEntry();
              });
              let absPath = path$1.join(wcDir, entry.fileName);
              fsExtra$1.ensureDirSync(path$1.dirname(absPath));
              readStream.pipe(fs$1.createWriteStream(absPath));
            });
          }
        });
        zipfile.on('error', err => {
          cb(err);
        });
        zipfile.once('end', () => {
          cb();
        });
      });
    }

    _pack (wcDir, darpath, cb) {
      // console.log('DarFileStorage::_pack')
      let zipfile = new yazl.ZipFile();
      listDir(wcDir).then(entries => {
        for (let entry of entries) {
          let relPath = path$1.relative(wcDir, entry.path);
          // console.log('... adding "%s" as %s', entry.path, relPath)
          zipfile.addFile(entry.path, relPath);
        }
        zipfile.outputStream.pipe(fs$1.createWriteStream(darpath)).on('close', () => {
          cb();
        });
        // call end() after all the files have been added
        zipfile.end();
      }).catch(cb);
    }

    // used by tests
    _getRawArchive (darpath, cb) {
      let id = this._path2Id(darpath);
      let wcDir = this._getWorkingCopyPath(id);
      this._internalStorage.read(wcDir, cb);
    }
  }

  /* global FormData */

  class HttpStorageClient {
    constructor (apiUrl) {
      this.apiUrl = apiUrl;
    }

    /*
      @returns a Promise for a raw archive, i.e. the data for a DocumentArchive.
    */
    read (archiveId, cb) {
      let url = this.apiUrl;
      if (archiveId) {
        url = url + '/' + archiveId;
      }
      return substance.sendRequest({
        method: 'GET',
        url
      }).then(response => {
        cb(null, JSON.parse(response));
      }).catch(err => {
        cb(err);
      })
    }

    write (archiveId, data, cb) {
      let form = new FormData();
      substance.forEach(data.resources, (record, filePath) => {
        if (record.encoding === 'blob') {
          // removing the blob from the record and submitting it as extra part
          form.append(record.id, record.data, filePath);
          delete record.data;
        }
      });
      form.append('_archive', JSON.stringify(data));
      let url = this.apiUrl;
      if (archiveId) {
        url = url + '/' + archiveId;
      }
      return substance.sendRequest({
        method: 'PUT',
        url,
        data: form
      }).then(response => {
        cb(null, response);
      }).catch(err => {
        cb(err);
      })
    }
  }

  var ManifestSchemaData = {"start":"dar","elements":{"dar":{"name":"dar","type":"element","attributes":{},"elements":{"name":"dar","content":{"type":",","blocks":["documents","assets"]}}},"documents":{"name":"documents","type":"element","attributes":{},"elements":{"name":"documents","content":{"type":"*","block":"document"}}},"assets":{"name":"assets","type":"element","attributes":{},"elements":{"name":"assets","content":{"type":"*","block":"asset"}}},"document":{"name":"document","type":"element","attributes":{"id":{"name":"id"},"name":{"name":"name"},"type":{"name":"type"},"path":{"name":"path"}},"elements":{"name":"document","content":{"type":",","blocks":[]}}},"asset":{"name":"asset","type":"element","attributes":{"id":{"name":"id"},"name":{"name":"name"},"type":{"name":"type"},"path":{"name":"path"}},"elements":{"name":"asset","content":{"type":",","blocks":[]}}}}}

  const ManifestSchema = substance.XMLSchema.fromJSON(ManifestSchemaData);

  // TODO: this should come from compilation
  ManifestSchema.getName = function () {
    return 'RDC-Manifest'
  };

  ManifestSchema.getVersion = function () {
    return '1.0'
  };

  ManifestSchema.getDocTypeParams = function () {
    return ['manifest', 'RDC-Manifest 1.0', ManifestSchema.uri]
  };

  // TODO: this does not make sense
  ManifestSchema.getDefaultTextType = function () {
    return 'text'
  };

  ManifestSchema.uri = '//Manifest-1.0.dtd';

  class ManifestDocument extends substance.XMLDocument {
    getRootNode () {
      if (!this.root) {
        let nodes = this.getNodes();
        let ids = Object.keys(nodes);
        for (var i = 0; i < ids.length; i++) {
          let node = nodes[ids[i]];
          if (node.type === 'dar') {
            this.root = node;
          }
        }
      }
      return this.root
    }

    getDocTypeParams () {
      return ManifestSchema.getDocTypeParams()
    }

    getXMLSchema () {
      return ManifestSchema
    }

    getDocumentNodes () {
      return this.findAll('documents > document')
    }

    getAssetNodes () {
      return this.findAll('assets > asset')
    }

    getDocumentEntries () {
      let documents = this.findAll('documents > document');
      return documents.map(_getEntryFromDocumentNode)
    }

    getDocumentEntry (id) {
      let entryNode = this.get(id);
      if (entryNode && entryNode.type === 'document') {
        return _getEntryFromDocumentNode(entryNode)
      }
    }
  }

  function _getEntryFromDocumentNode (documentNode) {
    return Object.assign({ id: documentNode.id }, documentNode.getAttributes())
  }

  function loadManifest (xmlStr) {
    let configurator = new substance.Configurator();
    substance.registerSchema(configurator, ManifestSchema, ManifestDocument, {
      ImporterClass: substance.XMLDocumentImporter
    });
    let importer = configurator.createImporter(ManifestSchema.getName());
    let manifest = importer.importDocument(xmlStr);
    return new substance.DocumentSession(manifest)
  }

  var ManifestLoader = {
    load (manifestXml) {
      return loadManifest(manifestXml)
    }
  }

  class InMemoryDarBuffer {
    constructor () {
      this._version = null;
      this._changes = [];
      this._isDirty = {};
      this._blobs = {};
    }

    getVersion () {
      return this._version
    }

    load(archiveId, cb) { // eslint-disable-line
      cb();
    }

    addChange (docId, change) {
      // HACK: if there are no ops we skip
      if (change.ops.length === 0) return
      // console.log('RECORD CHANGE', docId, change)
      this._isDirty[docId] = true;
      this._changes.push({
        docId, change
      });
    }

    hasPendingChanges () {
      return this._changes.length > 0
    }

    getChanges () {
      return this._changes.slice()
    }

    hasResourceChanged (docId) {
      return this._isDirty[docId]
    }

    hasBlobChanged (assetId) {
      return Boolean(this._isDirty[assetId])
    }

    addBlob (assetId, blob) {
      this._isDirty[assetId] = true;
      this._blobs[assetId] = blob;
    }

    getBlob (assetId) {
      return this._blobs[assetId]
    }

    reset (version) {
      this._version = version;
      this._changes = [];
      this._blobs = {};
      this._isDirty = {};
    }
  }

  class ManifestEditorSession extends substance.AbstractEditorSession {
    // nothing special about this yet
  }

  /*
    A PersistedDocumentArchive is a 3-tier stack representing a document archive
    at different application levels:

    1. Editor: an application such as Texture works on an in-memory data model,
       managed by EditorSessions. There may be multiple sessions for different parts of the
       document archive, e.g. the manuscript and an entity db.
    2. Buffer: a short-term storage for pending changes. Until the document archive
       is saved permanently, changes are recorded and can be persisted, e.g. to
       avoid loosing changes when the browser is closed inadvertently.
    3. Storage: a long-term storage where the document archive is persisted and versioned.

    PersistedDocumentArchive manages the communication between the three layers, e.g.
    when the user changes a document, it records the change and stores it into the buffer,
    and eventually saving a new version of the ardhive.
  */
  class PersistedDocumentArchive extends substance.EventEmitter {
    constructor (storage, buffer, context, config) {
      super();
      this.storage = storage;
      this.buffer = buffer;

      this._archiveId = null;
      this._upstreamArchive = null;
      this._sessions = null;
      this._pendingFiles = new Map();
      this._config = config;
    }

    addDocument (type, name, xml) {
      let documentId = substance.uuid();
      let sessions = this._sessions;
      let session = this._loadDocument(type, { data: xml }, sessions);
      sessions[documentId] = session;
      this._registerForSessionChanges(session, documentId);
      this._addDocumentRecord(documentId, type, name, documentId + '.xml');
      return documentId
    }

    addAsset (file) {
      let assetId = substance.uuid();
      let [name, ext] = _getNameAndExtension(file.name);
      let filePath = this._getUniqueFileName(name, ext);
      this._getManifestEditorSession().transaction(tx => {
        let assets = tx.find('assets');
        let asset = tx.createElement('asset', { id: assetId }).attr({
          path: filePath,
          type: file.type
        });
        assets.appendChild(asset);
      });
      this.buffer.addBlob(assetId, {
        id: assetId,
        path: filePath,
        blob: file
      });
      // FIXME: what to do in NodeJS?
      if (substance.platform.inBrowser) {
        this._pendingFiles.set(filePath, URL.createObjectURL(file));
      }
      return filePath
    }

    getAsset (fileName) {
      return this._sessions.manifest.getDocument().find(`asset[path="${fileName}"]`)
    }

    getDocumentEntries () {
      return this.getDocumentSession('manifest').getDocument().getDocumentEntries()
    }

    getDownloadLink (fileName) {
      let manifest = this._sessions.manifest.getDocument();
      let asset = manifest.find(`asset[path="${fileName}"]`);
      if (asset) {
        return this.resolveUrl(fileName)
      }
    }

    getDocumentSession (docId) {
      return this._sessions[docId]
    }

    hasAsset (fileName) {
      // TODO: at some point I want to introduce an index for files by fileName/path
      return Boolean(this.getAsset(fileName))
    }

    hasPendingChanges () {
      return this.buffer.hasPendingChanges()
    }

    load (archiveId, cb) {
      const storage = this.storage;
      const buffer = this.buffer;
      storage.read(archiveId, (err, upstreamArchive) => {
        if (err) return cb(err)
        buffer.load(archiveId, err => {
          if (err) return cb(err)
          // Ensure that the upstream version is compatible with the buffer.
          // The buffer may contain pending changes.
          // In this case the buffer should be based on the same version
          // as the latest version in the storage.
          if (!buffer.hasPendingChanges()) {
            let localVersion = buffer.getVersion();
            let upstreamVersion = upstreamArchive.version;
            if (localVersion && upstreamVersion && localVersion !== upstreamVersion) {
              // If the local version is out-of-date, it would be necessary to 'rebase' the
              // local changes.
              console.error('Upstream document has changed. Discarding local changes');
              this.buffer.reset(upstreamVersion);
            } else {
              buffer.reset(upstreamVersion);
            }
          }
          // convert raw archive into sessions (=ingestion)
          let sessions = this._ingest(upstreamArchive);
          // contract: there must be a manifest
          if (!sessions['manifest']) {
            throw new Error('There must be a manifest session.')
          }
          // apply pending changes
          if (!buffer.hasPendingChanges()) ; else {
            buffer.reset(upstreamArchive.version);
          }
          // register for any changes in each session
          this._registerForAllChanges(sessions);

          this._archiveId = archiveId;
          this._upstreamArchive = upstreamArchive;
          this._sessions = sessions;

          // Run through a repair step (e.g. remove missing files from archive)
          this._repair();
          cb(null, this);
        });
      });
    }

    removeDocument (documentId) {
      let session = this._sessions[documentId];
      this._unregisterFromSession(session);
      this._getManifestEditorSession().transaction(tx => {
        let documents = tx.find('documents');
        let docEntry = tx.find(`#${documentId}`);
        documents.removeChild(docEntry);
      });
    }

    renameDocument (documentId, name) {
      this._getManifestEditorSession().transaction(tx => {
        let docEntry = tx.find(`#${documentId}`);
        docEntry.attr({ name });
      });
    }

    resolveUrl (path) {
      // until saved, files have a blob URL
      let blobUrl = this._pendingFiles.get(path);
      if (blobUrl) {
        return blobUrl
      } else {
        let fileRecord = this._upstreamArchive.resources[path];
        if (fileRecord && fileRecord.encoding === 'url') {
          return fileRecord.data
        }
      }
    }

    save (cb) {
      // FIXME: buffer.hasPendingChanges() is not working
      this.buffer._isDirty['manuscript'] = true;
      this._save(this._archiveId, cb);
    }

    /*
      Save as is implemented as follows.

      1. clone: copy all files from original archive to new archive (backend)
      2. save: perform a regular save using user buffer (over new archive, including pending
         documents and blobs)
    */
    saveAs (newArchiveId, cb) {
      this.storage.clone(this._archiveId, newArchiveId, (err) => {
        if (err) return cb(err)
        this._save(newArchiveId, cb);
      });
    }

    /*
      Adds a document record to the manifest file
    */
    _addDocumentRecord (documentId, type, name, path) {
      this._getManifestEditorSession().transaction(tx => {
        let documents = tx.find('documents');
        let docEntry = tx.createElement('document', { id: documentId }).attr({
          name: name,
          path: path,
          type: type
        });
        documents.appendChild(docEntry);
      });
    }

    _getManifestEditorSession () {
      if (!this._manifestEditorSession) {
        this._manifestEditorSession = new ManifestEditorSession('manifest', this._sessions.manifest);
      }
      return this._manifestEditorSession
    }

    _getUniqueFileName (name, ext) {
      let candidate;
      // first try the canonical one
      candidate = `${name}.${ext}`;
      if (this.hasAsset(candidate)) {
        let count = 2;
        // now use a suffix counting up
        while (true) {
          candidate = `${name}_${count++}.${ext}`;
          if (!this.hasAsset(candidate)) break
        }
      }

      return candidate
    }

    _loadManifest (record) {
      if (!record) {
        throw new Error('manifest.xml is missing')
      }
      return ManifestLoader.load(record.data)
    }

    _registerForAllChanges (sessions) {
      substance.forEach(sessions, (session, docId) => {
        this._registerForSessionChanges(session, docId);
      });
    }

    _registerForSessionChanges (session, docId) {
      session.on('change', (change) => {
        this.buffer.addChange(docId, change);
        // Apps can subscribe to this (e.g. to show there's pending changes)
        this.emit('archive:changed');
      }, this);
    }

    _repair () {
      // no-op
    }

    /*
      Create a raw archive for upload from the changed resources.
    */
    _save (archiveId, cb) {
      const buffer = this.buffer;
      const storage = this.storage;
      const sessions = this._sessions;

      let rawArchive = this._exportChanges(sessions, buffer);

      // CHALLENGE: we either need to lock the buffer, so that
      // new changes are interfering with ongoing sync
      // or we need something pretty smart caching changes until the
      // sync has succeeded or failed, e.g. we could use a second buffer in the meantime
      // probably a fast first-level buffer (in-mem) is necessary anyways, even in conjunction with
      // a slower persisted buffer
      storage.write(archiveId, rawArchive, (err, res) => {
        // TODO: this need to implemented in a more robust fashion
        // i.e. we should only reset the buffer if storage.write was successful
        if (err) return cb(err)

        // TODO: if successful we should receive the new version as response
        // and then we can reset the buffer
        let _res = { version: '0' };
        if (substance.isString(res)) {
          try {
            _res = JSON.parse(res);
          } catch (err) {
            console.error('Invalid response from storage.write()');
          }
        }
        // console.log('Saved. New version:', res.version)
        buffer.reset(_res.version);
        // revoking object urls
        if (substance.platform.inBrowser) {
          for (let blobUrl of this._pendingFiles.values()) {
            window.URL.revokeObjectURL(blobUrl);
          }
        }
        this._pendingFiles.clear();

        // After successful save the archiveId may have changed (save as use case)
        this._archiveId = archiveId;
        this.emit('archive:saved');
        cb();
      });
    }

    _unregisterFromSession (session) {
      session.off(this);
    }

    /*
      Uses the current state of the buffer to generate a rawArchive object
      containing all changed documents
    */
    _exportChanges (sessions, buffer) {
      let rawArchive = {
        version: buffer.getVersion(),
        diff: buffer.getChanges(),
        resources: {}
      };
      this._exportManifest(sessions, buffer, rawArchive);
      this._exportChangedDocuments(sessions, buffer, rawArchive);
      this._exportChangedAssets(sessions, buffer, rawArchive);
      return rawArchive
    }

    // TODO: generalize the implementation so that it can live here
    _exportChangedDocuments (sessions, buffer, rawArchive) {
      throwMethodIsAbstract();
    }

    _exportChangedAssets (sessions, buffer, rawArchive) {
      let manifest = sessions.manifest.getDocument();
      let assetNodes = manifest.getAssetNodes();
      assetNodes.forEach(asset => {
        let assetId = asset.id;
        if (buffer.hasBlobChanged(assetId)) {
          let path = asset.attr('path') || assetId;
          let blobRecord = buffer.getBlob(assetId);
          rawArchive.resources[path] = {
            assetId,
            data: blobRecord.blob,
            encoding: 'blob',
            createdAt: Date.now(),
            updatedAt: Date.now()
          };
        }
      });
    }
  }

  function _getNameAndExtension (name) {
    let frags = name.split('.');
    let ext = '';
    if (frags.length > 1) {
      ext = substance.last(frags);
      name = frags.slice(0, frags.length - 1).join('.');
    }
    return [name, ext]
  }

  /**
   * A storage implementation that is bound to a single folder.
   */
  class UnpackedDarFolderStorage extends FSStorage {
    constructor (darFolder) {
      super();

      this.darFolder = darFolder;
    }

    _normalizeArchiveDir () {
      return this.darFolder
    }

    clone (archiveDir, newArchiveDir, cb) {
      cb(new Error('Cloning is not supported by this storage type.'));
    }
  }

  class VfsStorageClient {
    constructor (vfs, baseUrl) {
      this.vfs = vfs;

      // an url rom where the assets are served statically
      this.baseUrl = baseUrl;
    }

    read (archiveId, cb) {
      let rawArchive = _readRawArchive(this.vfs, archiveId, this.baseUrl);
      cb(null, rawArchive);
    }

    write (archiveId, data, cb) { // eslint-disable-line
      _updateRawArchive(this.vfs, archiveId, data, this.baseUrl);
      cb(null, true);
    }
  }

  function _readRawArchive (fs, archiveId, baseUrl = '') {
    let manifestXML = fs.readFileSync(`${archiveId}/manifest.xml`);
    let manifestSession = ManifestLoader.load(manifestXML);
    let manifest = manifestSession.getDocument();
    let docs = manifest.findAll('documents > document');
    let assets = manifest.findAll('assets > asset');
    let rawArchive = {
      version: '0',
      resources: {
        'manifest.xml': {
          encoding: 'utf8',
          data: manifestXML
        }
      }
    };

    docs.forEach(entry => {
      let path = entry.attr('path');
      if (fs.existsSync(`${archiveId}/${entry.path}`)) {
        let content = fs.readFileSync(`${archiveId}/${entry.path}`);
        rawArchive.resources[path] = {
          encoding: 'utf8',
          data: content
        };
      } else {
        console.warn(`${archiveId}/${entry.path} not found in vfs`);
      }
    });
    assets.forEach(asset => {
      let path = asset.attr('path');
      // TODO: we could store other stats and maybe mime-types in VFS
      rawArchive.resources[path] = {
        encoding: 'url',
        data: baseUrl + archiveId + '/' + path
      };
    });
    return rawArchive
  }

  function _updateRawArchive (fs, archiveId, rawArchive, baseUrl = '') {
    let paths = Object.keys(rawArchive.resources);
    for (let path of paths) {
      let resource = rawArchive.resources[path];
      let data = resource.data;
      fs.writeFileSync(`${archiveId}/${path}`, data);
    }
  }

  function checkLoadArchive (ArchiveClass, rawArchive) {
    let testArchive = new ArchiveClass();
    try {
      testArchive._ingest(rawArchive);
    } catch (error) {
      /* istanbul ignore next */
      return error
    }
  }

  /* istanbul ignore file */

  function vfsSaveHook (storage, ArchiveClass) {
    // monkey patch VfsStorageClient so that we can check if the stored data
    // can be loaded
    storage.write = (archiveId, rawArchive, cb) => {
      console.info('Writing archive:', rawArchive); // eslint-disable-line
      storage.read(archiveId, (err, originalRawArchive) => {
        if (err) return cb(err)
        rawArchive.resources = Object.assign({}, originalRawArchive.resources, rawArchive.resources);
        err = checkLoadArchive(ArchiveClass, rawArchive);
        if (err) {
          if (substance.platform.inBrowser) {
            console.error(err);
            window.alert('Exported archive is corrupt!'); // eslint-disable-line no-alert
          }
          console.error(err.detail);
          return cb(err)
        } else {
          return cb(null, true)
        }
      });
    };
  }

  // TODO: this should incoporate the 'Project' stuff that we have in Stencila
  class Texture extends substance.Component {
    constructor (...args) {
      super(...args);

      this.config = this._getConfiguration();
    }

    render ($$) {
      const archive = this.props.archive;
      let el = $$('div').addClass('sc-texture');

      // TODO: switch by current document tab
      const currentDocumentName = 'manuscript';
      const ResourceComponent = this.config.getComponent('article');
      const config = this.config.getConfiguration('article');
      const documentSession = archive.getDocumentSession(currentDocumentName);
      let props = {
        archive,
        config,
        documentSession
      };
      el.append(
        $$(ResourceComponent, props).ref('resource')
      );
      if (substance.platform.inBrowser && !substance.platform.isChromium && !substance.platform.inElectron) {
        el.append(
          $$(PinnedMessage, { icon: 'fa-warning', label: 'Attention! Current version of Texture supports only Chrome browser.' })
        );
      }
      return el
    }

    _getConfiguration () {
      let config = new TextureConfigurator();
      // TODO: in future we want to make this configurable (plugin framework)
      config.import(ArticlePackage);
      return config
    }

    _handleKeydown (event) {
      this.refs.resource._handleKeydown(event);
    }
  }

  class TextureAppChrome extends substance.Component {
    constructor (...args) {
      super(...args);

      this._router = new substance.Router();
    }

    didMount () {
      // if debug is turned on do not 'forward' to an error display and instead
      // leave the app in its failed state
      if (this.props.debug) {
        this._init();
      } else {
        this._init(err => {
          if (err) {
            console.error(err);
            this.setState({ error: err });
          }
        });
      }
      // Note: adding global handlers causes problems in the test suite
      if (!substance.platform.test) {
        substance.DefaultDOMElement.getBrowserWindow().on('keydown', this._keyDown, this);
        substance.DefaultDOMElement.getBrowserWindow().on('drop', this._supressDnD, this);
        substance.DefaultDOMElement.getBrowserWindow().on('dragover', this._supressDnD, this);
      }
      this._router.start();
      this.handleActions({
        'save': this._handleSave
      });
    }

    _handleSave () {
      this._save((err) => {
        if (err) console.error(err);
      });
    }

    dispose () {
      substance.DefaultDOMElement.getBrowserWindow().off(this);
    }

    getChildContext () {
      return this._childContext || {}
    }

    getInitialState () {
      return {
        archive: undefined,
        error: undefined
      }
    }

    /*
      4 initialisation stages:
      - _setupChildContext
      - _initContext
      - _loadArchive
      - _initArchive
    */
    _init (cb) {
      if (!cb) cb = (err) => { if (err) throw err };
      this._setupChildContext((err, context) => {
        if (err) return cb(err)
        this._initContext(context, (err, context) => {
          if (err) return cb(err)
          this._loadArchive(this.props.archiveId, context, (err, archive) => {
            if (err) return cb(err)
            this._initArchive(archive, context, (err, archive) => {
              if (err) return cb(err)
              this._childContext = context;
              this.setState({ archive });
              this._afterInit();
              this.emit('archive:ready');
            });
          });
        });
      });
    }

    _setupChildContext (cb) {
      cb(null, { router: this._router });
    }

    _initContext (context, cb) {
      cb(null, context);
    }

    _loadArchive () {
      throw new Error('_loadArchive not implemented')
    }

    _initArchive (archive, context, cb) {
      cb(null, archive);
    }

    _afterInit () {}

    _save (cb) {
      this.state.archive.save(err => {
        if (err) return cb(err)
        this._updateTitle(false);
        cb(null);
      });
    }

    _updateTitle () {}

    _keyDown (event) {
      // TODO: should this really be suppressed here?
      if (event.key === 'Dead') return
      if (this._handleKeydown) {
        this._handleKeydown(event);
      }
    }

    _supressDnD (event) {
      event.preventDefault();
    }
  }

  class TextureArchive extends PersistedDocumentArchive {
    /*
      Creates EditorSessions from a raw archive.
      This might involve some consolidation and ingestion.
    */
    _ingest (rawArchive) {
      let sessions = {};
      let manifestXML = _importManifest(rawArchive);
      let manifestSession = this._loadManifest({ data: manifestXML });
      sessions['manifest'] = manifestSession;
      let entries = manifestSession.getDocument().getDocumentEntries();

      entries.forEach(entry => {
        let record = rawArchive.resources[entry.path];
        // Note: this happens when a resource is referenced in the manifest
        // but is not there actually
        // we skip loading here and will fix the manuscript later on
        if (!record) {
          return
        }
        // Load any document except pub-meta (which we prepared manually)
        if (entry.type !== 'pub-meta') {
          // TODO: we need better concept for handling errors
          let session;
          // Passing down 'sessions' so that we can add to the pub-meta session
          session = this._loadDocument(entry.type, record, sessions);
          sessions[entry.id] = session;
        }
      });
      return sessions
    }

    _repair () {
      let manifestSession = this.getDocumentSession('manifest');
      let entries = manifestSession.getDocument().getDocumentEntries();
      let missingEntries = [];

      entries.forEach(entry => {
        let session = this.getDocumentSession(entry.id);
        if (!session) {
          missingEntries.push(entry.id);
          console.warn(`${entry.path} could not be found in the archive`);
        }
      });
    }

    _exportManifest (sessions, buffer, rawArchive) {
      let manifest = sessions.manifest.getDocument();
      if (buffer.hasResourceChanged('manifest')) {
        let manifestDom = manifest.toXML();
        let manifestXmlStr = substance.prettyPrintXML(manifestDom);
        rawArchive.resources['manifest.xml'] = {
          id: 'manifest',
          data: manifestXmlStr,
          encoding: 'utf8',
          updatedAt: Date.now()
        };
      }
    }

    // TODO: this should be generalized and then live in the base class
    _exportChangedDocuments (sessions, buffer, rawArchive) {
      // Note: we are only adding resources that have changed
      // and only those which are registered in the manifest
      let entries = this.getDocumentEntries();
      for (let entry of entries) {
        let { id, type, path } = entry;
        const hasChanged = buffer.hasResourceChanged(id);
        // skipping unchanged resources
        if (!hasChanged) continue
        // We mark a resource dirty when it has changes, or if it is an article
        // and pub-meta has changed
        if (type === 'article') {
          let session = sessions[id];
          // TODO: how should we communicate file renamings?
          rawArchive.resources[path] = {
            id,
            // HACK: same as when loading we pass down all sessions so that we can do some hacking there
            data: this._exportDocument(type, session, sessions),
            encoding: 'utf8',
            updatedAt: Date.now()
          };
        }
      }
    }

    _loadDocument (type, record, sessions) {
      switch (type) {
        case 'article': {
          return ArticleLoader.load(record.data, {}, this._config)
        }
        default:
          throw new Error('Unsupported document type')
      }
    }

    _exportDocument (type, session, sessions) { // eslint-disable-line no-unused-vars
      switch (type) {
        case 'article': {
          let exporter = new JATSExporter();
          let doc = session.getDocument();
          let res = exporter.export(doc);
          // TODO: we need a way to report this problem, i.e. make us at least aware of it
          // if (!res.ok) {
          //   throw new Error('FIXME: generated XML is not JATS compliant!')
          // }
          let jats = res.jats;
          console.info('saving jats', jats.getNativeElement());
          let xmlStr = substance.prettyPrintXML(jats);
          return xmlStr
        }
        default:
          throw new Error('Unsupported document type')
      }
    }

    getTitle () {
      let editorSession = this.getDocumentSession('manuscript');
      let title = 'Untitled';
      if (editorSession) {
        let doc = editorSession.getDocument();
        let articleTitle = doc.getTitle();
        if (articleTitle) {
          title = articleTitle;
        }
      }
      return title
    }
  }

  /*
    Create an explicit entry for pub-meta.json, which does not
    exist in the serialisation format
  */
  function _importManifest (rawArchive) {
    let manifestXML = rawArchive.resources['manifest.xml'].data;
    let dom = substance.DefaultDOMElement.parseXML(manifestXML);
    return dom.serialize()
  }

  function TextureAppMixin (ParentAppChrome) {
    return class TextureApp extends ParentAppChrome {
      render ($$) {
        let el = $$('div').addClass('sc-app');
        let { archive, error } = this.state;
        if (archive) {
          const Texture$$1 = this._getAppClass();
          el.append(
            $$(Texture$$1, { archive }).ref('texture')
          );
        } else if (error) {
          if (error.type === 'jats-import-error') {
            el.append(
              $$(JATSImportDialog, { errors: error.detail._errors })
            );
          } else {
            el.append('ERROR:', error.message);
          }
        }
        return el
      }

      _getAppClass () {
        return Texture
      }

      _getArchiveClass () {
        return TextureArchive
      }
    }
  }

  class TextureDesktopAppChrome extends TextureAppChrome {
    didMount () {
      super.didMount();

      substance.DefaultDOMElement.getBrowserWindow().on('click', this._click, this);
    }

    // emit an event on this component. The Electron binding in app.js listens to it and
    // handles it
    _handleSave () {
      this.emit('save');
    }

    // TODO: try to share implementation with TextureDesktopAppChrome
    // move as much as possible into TextureAppChrome
    // and only add browser specific overrides here
    _handleKeydown (event) {
      // let key = parseKeyEvent(event)
      // console.log('Texture received keydown for combo', key)
      let handled = false;
      // CommandOrControl+S
      // if (key === 'META+83' || key === 'CTRL+83') {
      //   this._save(err => {
      //     if (err) console.error(err)
      //   })
      //   handled = true
      // }
      // if (!handled) {
      handled = this.refs.texture._handleKeydown(event);
      // }
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }

    _loadArchive (archiveId, context, cb) {
      const ArchiveClass = this._getArchiveClass();
      let storage = this.props.storage;
      let buffer = new InMemoryDarBuffer();
      let archive = new ArchiveClass(storage, buffer, context);
      // HACK: this should be done earlier in the lifecycle (after first didMount)
      // and later disposed properly. However we can accept this for now as
      // the app lives as a singleton atm.
      // NOTE: _archiveChanged is implemented by DesktopAppChrome
      archive.on('archive:changed', this._archiveChanged, this);
      // ATTENTION: we want to treat new archives as 'read-only' in the
      // sense that a new archive is essentially one of several dar templates.
      archive.load(archiveId, (err, archive) => {
        if (err) return cb(err)
        if (this.props.isReadOnly) {
          archive.isReadOnly = true;
        }
        cb(null, archive);
      });
    }

    _saveAs (newDarPath, cb) {
      console.info('saving as', newDarPath);
      let archive = this.state.archive;
      archive.saveAs(newDarPath, err => {
        if (err) {
          console.error(err);
          return cb(err)
        }
        // HACK: this is kind of an optimization but formally it is not
        // 100% correct to continue with the same archive instance
        // Instead one would expect that cloning an archive returns
        // a new archive instance
        // Though, this would have other undesired implications
        // such as loosing the scroll position or undo history
        // Thus we move on with this solution, but we need to clear
        // the isReadOnly flag now.
        archive.isReadOnly = false;
        this._updateTitle();
        cb();
      });
    }

    _archiveChanged () {
      this._updateTitle();
    }

    _updateTitle () {
      const archive = this.state.archive;
      if (!archive) return
      let newTitle = archive.getTitle();
      if (archive.hasPendingChanges()) {
        newTitle += ' *';
      }
      document.title = newTitle;
    }

    _afterInit () {
      // Update window title after archive loading to display title
      this._updateTitle();
    }

    _click (event) {
      const target = substance.DefaultDOMElement.wrapNativeElement(event.target);
      let url = target.getAttribute('href');
      if (target.is('a') && url !== '#') {
        event.preventDefault();
        this.emit('openExternal', url);
      }
    }
  }

  class TextureDesktopApp extends TextureAppMixin(TextureDesktopAppChrome) {}

  /* global vfs */

  class TextureWebAppChrome extends TextureAppChrome {
    _loadArchive (archiveId, context, cb) {
      let storage = this._getStorage(this.props.storageType);
      let buffer = new InMemoryDarBuffer();
      let ArchiveClass = this._getArchiveClass();
      let archive = new ArchiveClass(storage, buffer, context);
      // Don't catch exception in debug mode
      if (this.props.debug) {
        archive.load(archiveId, cb);
      } else {
        try {
          archive.load(archiveId, cb);
        } catch (err) {
          this.setState({
            error: err
          });
          console.error(err);
        }
      }
    }

    _getStorage (storageType) {
      if (storageType === 'vfs') {
        return new VfsStorageClient(vfs, this._getDefaultDataFolder())
      } else {
        return new HttpStorageClient(this.props.storageUrl)
      }
    }

    // TODO: try to share implementation with TextureDesktopAppChrome
    // move as much as possible into TextureAppChrome
    // and only add browser specific overrides here
    _handleKeydown (event) {
      let key = substance.parseKeyEvent(event);
      // console.log('Texture received keydown for combo', key)
      let handled = false;
      // CommandOrControl+S
      if (key === 'META+83' || key === 'CTRL+83') {
        this._save(err => {
          if (err) console.error(err);
        });
        handled = true;
      }
      if (!handled) {
        handled = this.refs.texture._handleKeydown(event);
      }
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }

    _getArchiveClass () { throw new Error('This method is abstract') }

    _getDefaultDataFolder () { throw new Error('This method  is abstract') }
  }

  class TextureWebApp extends TextureAppMixin(TextureWebAppChrome) {
    _getDefaultDataFolder () {
      return './data/'
    }
  }

  const _global = (typeof global !== 'undefined') ? global : window;
  const textureGlobals = _global.hasOwnProperty('Texture') ? _global.Texture : _global.Texture = {
    DEBUG: false
  };

  exports.Texture = Texture;
  exports.TextureAppChrome = TextureAppChrome;
  exports.TextureArchive = TextureArchive;
  exports.TextureConfigurator = TextureConfigurator;
  exports.TextureDesktopApp = TextureDesktopApp;
  exports.TextureDesktopAppChrome = TextureDesktopAppChrome;
  exports.TextureWebApp = TextureWebApp;
  exports.TextureWebAppChrome = TextureWebAppChrome;
  exports.textureGlobals = textureGlobals;
  exports.ArticleAPI = ArticleAPI;
  exports.ArticleLoader = ArticleLoader;
  exports.ArticlePackage = ArticlePackage;
  exports.ArticleModelPackage = ArticleModelPackage;
  exports.ArticleSession = ArticleSession;
  exports.JATS = JATS;
  exports.TextureArticleSchema = TextureArticleSchema;
  exports.InternalArticleSchema = InternalArticleSchema;
  exports.InternalArticleDocument = InternalArticleDocument;
  exports.TextureArticleExporter = TextureArticleExporter;
  exports.JATSImportDialog = JATSImportDialog;
  exports.JATSImporter = JATSImporter;
  exports.JATSExporter = JATSExporter;
  exports.createEmptyJATS = createEmptyJATS;
  exports.jats2internal = jats2internal;
  exports.internal2jats = internal2jats;
  exports.createJatsImporter = createJatsImporter;
  exports.createJatsExporter = createJatsExporter;
  exports.jats2restrictedJats = jats2restrictedJats;
  exports.EditorPackage = EditorPackage;
  exports.InsertNodeCommand = InsertNodeCommand;
  exports.SaveHandler = SaveHandler;
  exports.tableHelpers = tableHelpers;
  exports.CustomMetadataFieldComponent = CustomMetadataFieldComponent;
  exports.FigureLabelGenerator = FigureLabelGenerator;
  exports.FigureManager = FigureManager;
  exports.FootnoteManager = FootnoteManager;
  exports.NumberedLabelGenerator = NumberedLabelGenerator;
  exports.ReferenceManager = ReferenceManager;
  exports.TableComponent = TableComponent;
  exports.TableManager = TableManager;
  exports.updateEntityChildArray = updateEntityChildArray;
  exports.getLabel = getLabel;
  exports.getPos = getPos;
  exports.findParentByType = findParentByType;
  exports.ifNodeOrRelatedHasChanged = ifNodeOrRelatedHasChanged;
  exports.REF_TYPES = REF_TYPES;
  exports.XREF_TARGET_TYPES = XREF_TARGET_TYPES;
  exports.getXrefTargets = getXrefTargets;
  exports.getXrefLabel = getXrefLabel;
  exports.MANUSCRIPT_MODE = MANUSCRIPT_MODE;
  exports.PREVIEW_MODE = PREVIEW_MODE;
  exports.METADATA_MODE = METADATA_MODE;
  exports.JOURNAL_ARTICLE_REF = JOURNAL_ARTICLE_REF;
  exports.BOOK_REF = BOOK_REF;
  exports.CHAPTER_REF = CHAPTER_REF;
  exports.CONFERENCE_PAPER_REF = CONFERENCE_PAPER_REF;
  exports.DATA_PUBLICATION_REF = DATA_PUBLICATION_REF;
  exports.PATENT_REF = PATENT_REF;
  exports.ARTICLE_REF = ARTICLE_REF;
  exports.NEWSPAPER_ARTICLE_REF = NEWSPAPER_ARTICLE_REF;
  exports.MAGAZINE_ARTICLE_REF = MAGAZINE_ARTICLE_REF;
  exports.REPORT_REF = REPORT_REF;
  exports.SOFTWARE_REF = SOFTWARE_REF;
  exports.THESIS_REF = THESIS_REF;
  exports.WEBPAGE_REF = WEBPAGE_REF;
  exports.JATS_BIBR_TYPES_TO_INTERNAL = JATS_BIBR_TYPES_TO_INTERNAL;
  exports.INTERNAL_BIBR_TYPES_TO_JATS = INTERNAL_BIBR_TYPES_TO_JATS;
  exports.JATS_BIBR_TYPES = JATS_BIBR_TYPES;
  exports.INTERNAL_BIBR_TYPES = INTERNAL_BIBR_TYPES;
  exports.LICENSES = LICENSES;
  exports.CARD_MINIMUM_FIELDS = CARD_MINIMUM_FIELDS;
  exports.LATIN_LETTERS_LOWER_CASE = LATIN_LETTERS_LOWER_CASE;
  exports.LATIN_LETTERS_UPPER_CASE = LATIN_LETTERS_UPPER_CASE;
  exports.ROMAN_NUMBERS = ROMAN_NUMBERS;
  exports.ARABIC_NUMBERS = ARABIC_NUMBERS;
  exports.SYMBOLS = SYMBOLS;
  exports.DarFileStorage = DarFileStorage;
  exports.FSStorage = FSStorage;
  exports.HttpStorageClient = HttpStorageClient;
  exports.ManifestLoader = ManifestLoader;
  exports.InMemoryDarBuffer = InMemoryDarBuffer;
  exports.PersistedDocumentArchive = PersistedDocumentArchive;
  exports.UnpackedDarFolderStorage = UnpackedDarFolderStorage;
  exports.VfsStorageClient = VfsStorageClient;
  exports.checkArchive = checkLoadArchive;
  exports.vfsSaveHook = vfsSaveHook;
  exports.BasePackage = BasePackage;
  exports.EditorBasePackage = EditorBasePackage;
  exports.AppState = AppState;
  exports.createComponentContext = createComponentContext;
  exports.createEditorContext = createEditorContext;
  exports.DocumentObserver = DocumentObserver;
  exports.EditorSession = EditorSession;
  exports.EditorState = EditorState;
  exports.FindAndReplacePackage = FindAndReplacePackage;
  exports.SwitchTextTypeCommand = SwitchTextTypeCommand;
  exports.addModelObserver = addModelObserver;
  exports.BooleanModel = BooleanModel;
  exports.ChildModel = ChildModel;
  exports.CollectionModel = CollectionModel;
  exports.createNodePropertyModels = createNodePropertyModels;
  exports.createValueModel = createValueModel;
  exports.JSONConverterNew = JSONConverterNew;
  exports.ManyRelationshipModel = ManyRelationshipModel;
  exports.ObjectModel = ObjectModel;
  exports.removeModelObserver = removeModelObserver;
  exports.SingleRelationshipModel = SingleRelationshipModel;
  exports.StringModel = StringModel;
  exports.TextModel = TextModel;
  exports.ValueModel = ValueModel;
  exports.throwMethodIsAbstract = throwMethodIsAbstract;
  exports.AbstractScrollPane = AbstractScrollPane;
  exports.AnnotationComponent = AnnotationComponent;
  exports.BodyScrollPane = BodyScrollPane;
  exports.BooleanComponent = BooleanComponent;
  exports.Button = Button;
  exports.CheckboxInput = CheckboxInput;
  exports.ChildComponent = ChildComponent;
  exports.CollectionComponent = CollectionComponent;
  exports.Clipboard = ClipboardNew;
  exports.ContainerEditor = ContainerEditorNew;
  exports.ContextMenu = ContextMenu;
  exports.DialogSectionComponent = DialogSectionComponent;
  exports.FormRowComponent = FormRowComponent;
  exports.getComponentForModel = getComponentForModel;
  exports.InputWithButton = InputWithButton;
  exports.IsolatedInlineNodeComponent = IsolatedInlineNodeComponentNew;
  exports.IsolatedNodeComponent = IsolatedNodeComponentNew;
  exports.Managed = Managed;
  exports.ManyRelationshipComponent = ManyRelationshipComponent;
  exports.ModalDialog = ModalDialog;
  exports.ModelComponent = ModelComponent;
  exports.ModelComponentPackage = ModelComponentPackage;
  exports.MultiSelectInput = MultiSelectInput;
  exports.NodeComponent = NodeComponent;
  exports.NodeComponentMixin = NodeComponentMixin;
  exports.ObjectComponent = ObjectComponent;
  exports.Overlay = Overlay;
  exports.OverlayMixin = OverlayMixin;
  exports.PinnedMessage = PinnedMessage;
  exports.renderModel = renderModel;
  exports.renderNode = renderNode;
  exports.renderValue = renderValue;
  exports.ScrollPane = ScrollPane;
  exports.SingleRelationshipComponent = SingleRelationshipComponent;
  exports.StringComponent = StringComponent;
  exports.Surface = SurfaceNew;
  exports.TextComponent = TextComponent;
  exports.TextInput = TextInput;
  exports.TextNodeComponent = TextNodeComponent;
  exports.TextPropertyComponent = TextPropertyComponentNew;
  exports.TextPropertyEditor = TextPropertyEditorNew;
  exports.ToggleTool = ToggleTool;
  exports.Tool = Tool;
  exports.Toolbar = Toolbar;
  exports.ToolDropdown = ToolDropdown;
  exports.ToolGroup = ToolGroup;
  exports.ToolPanel = ToolPanel;
  exports.ToolPrompt = ToolPrompt;
  exports.ToolSpacer = ToolSpacer;
  exports.ToolSwitcher = ToolSwitcher;
  exports.Tooltip = Tooltip;
  exports.ValueComponent = ValueComponent;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=./texture.js.map